<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>马克得烂笔头</title>
  
  <subtitle>Mark&#39;s Book</subtitle>
  <link href="https://mkdbook.com/atom.xml" rel="self"/>
  
  <link href="https://mkdbook.com/"/>
  <updated>2023-12-27T03:59:17.515Z</updated>
  <id>https://mkdbook.com/</id>
  
  <author>
    <name>Mark</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>42--NAND的ODT功能</title>
    <link href="https://mkdbook.com/blog042.html"/>
    <id>https://mkdbook.com/blog042.html</id>
    <published>2023-12-27T03:34:51.000Z</published>
    <updated>2023-12-27T03:59:17.515Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1、ODT支持的接口"><a href="#1、ODT支持的接口" class="headerlink" title="1、ODT支持的接口"></a>1、ODT支持的接口</h1><ul><li>NV-DDR2</li><li>NV-DDR3</li><li>NV-LPDDR4</li></ul><h1 id="2、什么是ODT？"><a href="#2、什么是ODT？" class="headerlink" title="2、什么是ODT？"></a>2、什么是ODT？</h1><ul><li>ODT 的全称是 On-Die Termination，即片内终端。它是一种用于<code>降低 NAND 芯片输入阻抗</code>的技术，用于优化信号传输，提高信号完整性，并降低信号反射。</li></ul><h1 id="3、ODT如何降低NAND的输入阻抗？"><a href="#3、ODT如何降低NAND的输入阻抗？" class="headerlink" title="3、ODT如何降低NAND的输入阻抗？"></a>3、ODT如何降低NAND的输入阻抗？</h1><ul><li>ODT可以通过将NAND芯片的输入端连接到一个低阻抗的输出端来降低输入端电流，从而降低输入阻抗。</li></ul><h1 id="4、为什么需要ODT？"><a href="#4、为什么需要ODT？" class="headerlink" title="4、为什么需要ODT？"></a>4、为什么需要ODT？</h1><ul><li>1、<code>提高I/O速度</code>：通过降低NAND芯片的输入阻抗。在没有个ODT的情况下，NAND芯片的输入阻抗较高，这会导致I&#x2F;O信号的上升和下降时间变长，从而降低I&#x2F;O速度。ODT可以通过降低NAND芯片的输入阻抗来缩短I&#x2F;O信号的上升和下降时间，从而提高I&#x2F;O速度。</li><li>2、<code>降低功耗</code>：在没有ODT的情况下，NAND芯片的输入端会一直处于高阻状态，这会导致NAND芯片的输入端电流一直保持在一个较高的水平，从而增加NAND芯片的功耗。ODT可以通过将NAND芯片的输入端连接到一个低阻抗的输出端来降低输入端电流，从而降低NAND芯片的功耗。</li></ul><h1 id="5、如何工作？"><a href="#5、如何工作？" class="headerlink" title="5、如何工作？"></a>5、如何工作？</h1><ul><li><strong>读操作时：</strong> ODT 输出端被<code>拉高</code>，将 NAND 芯片的<code>输入端</code>连接到 <code>ODT 输出端</code>。<br>由于 ODT 输出端的阻抗较低，NAND 芯片的<code>输入阻抗</code>也降低，从而缩短 I&#x2F;O 信号的上升和下降时间，<code>提高 I/O 速度</code>。</li><li><strong>写操作时：</strong> ODT 输出端被<code>拉低</code>，将 NAND 芯片的<code>输入端</code>连接到 <code>I/O 线</code>。<br>由于 ODT 输出端的阻抗较低，NAND 芯片的<code>输入端电流</code>也降低，从而<code>降低功耗</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1、ODT支持的接口&quot;&gt;&lt;a href=&quot;#1、ODT支持的接口&quot; class=&quot;headerlink&quot; title=&quot;1、ODT支持的接口&quot;&gt;&lt;/a&gt;1、ODT支持的接口&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;NV-DDR2&lt;/li&gt;
&lt;li&gt;NV</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="NAND" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/NAND/"/>
    
    
    <category term="NAND" scheme="https://mkdbook.com/tags/NAND/"/>
    
  </entry>
  
  <entry>
    <title>41--NAND的ZQCalibration功能</title>
    <link href="https://mkdbook.com/blog041.html"/>
    <id>https://mkdbook.com/blog041.html</id>
    <published>2023-12-27T03:34:38.000Z</published>
    <updated>2023-12-27T03:56:08.681Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1、什么情况需要ZQ-Calibration？"><a href="#1、什么情况需要ZQ-Calibration？" class="headerlink" title="1、什么情况需要ZQ Calibration？"></a>1、什么情况需要ZQ Calibration？</h1><ul><li>NV-DDR2：可选；</li><li>NV-DDR3：可选，但是当接口速率达到400MT&#x2F;s时推荐使用；</li><li>NV_LPDDR4：必选，无论接口速率多少；</li></ul><h1 id="2、ZQ-Calibration的作用？"><a href="#2、ZQ-Calibration的作用？" class="headerlink" title="2、ZQ Calibration的作用？"></a>2、ZQ Calibration的作用？</h1><ul><li>1、校准NAND Ron阻值；</li><li>2、校准ODT值；</li></ul><h1 id="3、ZQCL-和-ZQCS的区别？"><a href="#3、ZQCL-和-ZQCS的区别？" class="headerlink" title="3、ZQCL 和 ZQCS的区别？"></a>3、ZQCL 和 ZQCS的区别？</h1><ul><li><strong>ZQ long calibration：</strong><code>F9h</code>命令。<br>Power-on初始化校准时，需要较长时间；<br>host也可随时主动发出ZQCL命令。</li><li><strong>ZQ short calibration：</strong><code>D9h</code>命令。<br>定期的校准，需要的时间比较短；<br>需要定期的原因：随时考虑到电压和温度的变化。</li></ul><h1 id="4、ZQCL-过程"><a href="#4、ZQCL-过程" class="headerlink" title="4、ZQCL 过程"></a>4、ZQCL 过程</h1><ul><li>ZQCL 会触发 <code>NAND 内部</code>的Calibration engine，一旦完成校准，校准值就会传输到 NAND IO，从而更新output driver和ODT的值。</li></ul><h1 id="5、ZQCS-的间隔周期如何计算？"><a href="#5、ZQCS-的间隔周期如何计算？" class="headerlink" title="5、ZQCS 的间隔周期如何计算？"></a>5、ZQCS 的间隔周期如何计算？</h1><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/41.1.png" width="80%" height="80%" alt="41.1"/></center><p><strong>如果 ：</strong></p><ul><li>TSens &#x3D; 0.5 %&#x2F;°C，定义了温度灵敏度。它等于 TSens &#x3D; max（dRTTdT，dRONdTM）。</li><li>VSens &#x3D; 0.2 %&#x2F;mV，定义了电压灵敏度。它等于 VSens &#x3D; max（dRTTdV，dRONdVM）。</li><li>Tdriftrate &#x3D; 1 °C&#x2F;sec，定义了温度漂移率。</li><li>Vdriftrate &#x3D;15 mV&#x2F;sec， 定义了电压漂移率。</li></ul><p> <strong>计算方法举例如下：</strong></p><ul><li>1.5&#x2F; [(0.5 X 1) + (0.2 X 15)] &#x3D; 0.429 &#x3D; 429ms</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/41.2.png" width="80%" height="80%" alt="41.2"/></center><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/41.3.png" width="80%" height="80%" alt="41.3"/></center><h1 id="6、其它事项"><a href="#6、其它事项" class="headerlink" title="6、其它事项"></a>6、其它事项</h1><ul><li>1、在ZQCL和ZQCS进行的过程中，NAND总线上不能执行任何操作，包括读取status。</li><li>2、对于multi-channel packages，当一个channel正在进行ZQ Calibration时，所有其它通道也都不能执行其它数据传输操作。</li><li>3、ZQ Calibration完成后，NAND应该断开ZQ的电流消耗路径，以节省电压。</li><li>4、ZQ Calibration过程中，RESET命令会导致校准失效，host需要重新执行ZQ Calibration操作。</li></ul><h1 id="7、为什么需要ZQ-Calibration？"><a href="#7、为什么需要ZQ-Calibration？" class="headerlink" title="7、为什么需要ZQ Calibration？"></a>7、为什么需要ZQ Calibration？</h1><p>ZQ Calibration 可以确保 NAND 控制器和 NAND 闪存芯片之间的数据传输质量。</p><p>NAND 闪存芯片的 I&#x2F;O 端口使用差分信号传输数据。差分信号由两个信号线组成，一个是差分信号的正端，一个是差分信号的负端。在理想情况下，两个信号线的阻抗应该相等。如果两个信号线的阻抗不相等，就会导致差分信号的振幅发生变化，从而影响数据传输的质量。</p><p>ZQ Calibration 就是通过一个被称为 ZQ 电阻的参考电阻，来校准 NAND 控制器和 NAND 闪存芯片之间的差分信号阻抗。ZQ 电阻的阻值通常为 300 Ω。在 ZQ Calibration 过程中，NAND 控制器会通过 ZQ 电阻向 NAND 闪存芯片发送一个参考信号。NAND 闪存芯片会根据这个参考信号，来校准自己的差分信号阻抗。</p><p>ZQ Calibration 通常在 NAND 闪存芯片初始化时进行一次，也可以在运行过程中定期进行。定期进行 ZQ Calibration，可以确保 NAND 控制器和 NAND 闪存芯片之间的差分信号阻抗始终保持一致，从而提高数据传输的质量。</p><p>具体来说，ZQ Calibration 可以带来以下好处：</p><ul><li>提高数据传输的可靠性：ZQ Calibration 可以确保 NAND 控制器和 NAND 闪存芯片之间的差分信号阻抗始终保持一致，从而提高数据传输的可靠性。</li><li>降低数据传输的错误率：ZQ Calibration 可以降低数据传输的错误率，从而提高数据传输的效率。</li><li>延长 NAND 闪存芯片的使用寿命：ZQ Calibration 可以延长 NAND 闪存芯片的使用寿命，因为它可以降低数据传输过程中的损耗。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1、什么情况需要ZQ-Calibration？&quot;&gt;&lt;a href=&quot;#1、什么情况需要ZQ-Calibration？&quot; class=&quot;headerlink&quot; title=&quot;1、什么情况需要ZQ Calibration？&quot;&gt;&lt;/a&gt;1、什么</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="NAND" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/NAND/"/>
    
    
    <category term="NAND" scheme="https://mkdbook.com/tags/NAND/"/>
    
  </entry>
  
  <entry>
    <title>40--eMMC的Power Up操作</title>
    <link href="https://mkdbook.com/blog040.html"/>
    <id>https://mkdbook.com/blog040.html</id>
    <published>2023-12-27T03:18:08.000Z</published>
    <updated>2023-12-27T03:30:44.391Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1、Power-Up-流程（状态转换）"><a href="#1、Power-Up-流程（状态转换）" class="headerlink" title="1、Power Up 流程（状态转换）"></a>1、Power Up 流程（状态转换）</h1><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/40.1.png" width="100%" height="100%" alt="40.1"/></center><ul><li>1、VCC 和 VCCQ 上电到指定电压范围内（同时或先后均可，上电最大持续时长受tPRU约束）；</li><li>2、进入 <code>pre-idle</code> 状态，若不支持boot（或 BOOT_PARTITION_ENABLE 关闭），则直接进入<code>idle</code>状态；</li><li>3、若开启boot模式（BOOT_PARTITION_ENABLE 开启），则进入 <code>Pre-boot</code> 状态，接下来就进行boot初始化序列了；<br>3.1、如果接收 <strong>boot 操作序列</strong>，完成 boot 操作之后，进入 <code>idle</code> 状态；<br>3.2、如果接收的不是 <strong>boot 操作序列</strong> 和 <strong>CMD 1</strong>，也进入 <code>idle</code> 状态；<br>3.3、如果直接接收到 <strong>CMD 1</strong>，则会返回 CMD 1请求的内容，并跳出 boot mode ，直接进入到 <strong>Device identification mode</strong>；</li><li>4、<code>idle</code> 状态下发送CMD 1，然后进入<strong>Device identification mode；</strong></li></ul><h1 id="2、Power-Up-遵循原则（注意事项）"><a href="#2、Power-Up-遵循原则（注意事项）" class="headerlink" title="2、Power Up 遵循原则（注意事项）"></a>2、Power Up 遵循原则（注意事项）</h1><ul><li>1、处于 <code>idle</code> 状态，必须要发送 <code>CMD 1</code> 之后才能做其他操作（其他会被忽略）；</li><li>2、eMMC v4.2之前的版本，Power Up后直接进入 <code>idle</code> 状态；</li><li>3、Boot 的操作序列<a href="https://mkdbook.com/blog022.html#:~:text=%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%89-,3.1%20%E8%AE%BF%E9%97%AEboot%E5%88%86%E5%8C%BA,-%E5%9C%A8boot%E6%A8%A1%E5%BC%8F">如blog22 3.1所示</a>：keeping the CMD line low for at least 74 clock cycles, or issuing CMD0 with the argument of 0xFFFFFFFA；</li><li>4、上电完成后，host开始发送CLK和CMD；</li><li>5、每组总线的master都必须执行CMD1；</li></ul><h1 id="3、CMD-1-作用"><a href="#3、CMD-1-作用" class="headerlink" title="3、CMD 1 作用"></a>3、CMD 1 作用</h1><ul><li>1、在eMMC上电过程中，处于idle state时，发送CMD 1，请求设备状态，OCR寄存器<a href="https://mkdbook.com/blog025.html#:~:text=%E4%BA%8C%E3%80%81-,OCR%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%86%85%E5%AE%B9,-Operation%20condition%20register">如blog25所示</a>。</li><li>2、CMD 1是用来协商工作电压范围，并轮询设备直至其结束上电过程的专用同步命令。</li><li>3、CMD 1的应答还包含一个busy标志位，表示设备仍工作于上电例程，没有准备好识别。主机必须等到此位清除，若CMD 1在device初始化完成之前发送，则device会给host端反馈一个含busy flag的CMD 1应答。</li><li>4、如果busy标志位一直未清除，则主机可以再次发送CMD 1。但是，根据eMMC标准，设备必须在具有有效OCR范围的 CMD1 发送1秒内完成其初始化。因此，一般情况下，只需要发送一次CMD 1即可。</li><li>5、若在power up之前，已经完成分区（<code>EXT_CSD byte [155]表示分区设置是否完成</code>），则初始化延迟要通过<code>INI_TIMEOUT_PA（EXT_CSD byte [241]）</code>计算，而不是固定的1s；<br>但这个超时时间仅用于设置后的第一次启动，对于所有连续的初始化，还是使用1s超时。</li></ul><h1 id="4、Sleep-状态，Power-电压的变化"><a href="#4、Sleep-状态，Power-电压的变化" class="headerlink" title="4、Sleep 状态，Power 电压的变化"></a>4、Sleep 状态，Power 电压的变化</h1><ul><li>1、Master 必须在VCC和VCCQ稳定之后，才能发 command。</li><li>2、处于<code>sleep mode</code>时，master可以<code>关断VCC</code>减少功耗，但VCCQ需要保持，用来接收唤醒命令。</li><li>3、CMD 5唤醒处于sleep mode的device前，需要先拉高VCC。</li><li>如果 VCC or VCCQ 低于 0.5 V 超过 1 ms，则会回到 <code>pre-idle</code> 状态。（Sleep 状态除外）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1、Power-Up-流程（状态转换）&quot;&gt;&lt;a href=&quot;#1、Power-Up-流程（状态转换）&quot; class=&quot;headerlink&quot; title=&quot;1、Power Up 流程（状态转换）&quot;&gt;&lt;/a&gt;1、Power Up 流程（状态</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>39--关于eMMC的一些个人总结</title>
    <link href="https://mkdbook.com/blog039.html"/>
    <id>https://mkdbook.com/blog039.html</id>
    <published>2023-12-27T03:00:16.000Z</published>
    <updated>2023-12-27T03:16:11.760Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一些个人理解结合网上文章，不一定正确；</p><h1 id="1、eMMC中VCC、VDD、VSS、VCCQ-的关系理解"><a href="#1、eMMC中VCC、VDD、VSS、VCCQ-的关系理解" class="headerlink" title="1、eMMC中VCC、VDD、VSS、VCCQ 的关系理解"></a>1、eMMC中VCC、VDD、VSS、VCCQ 的关系理解</h1><ul><li><p>在MOS管中，它们是可以这样对应的：<br><code>VCC</code>：栅极电压，Control Gate，给栅极加压打开珪衬底的隧道；<br><code>VDD</code>：漏极电压，Drain Gate，电子或者空穴在漏极耗尽，类似GND（低电压）；<br><code>VSS</code>：源极电压，Source Gate，储存负电子或正空穴；<br>VCCQ：给信号线（I&#x2F;O口）供电，Q一般表示数字电路中的数据线，如DQ。<br>在eMMC中，供电方式如<a href="https://mkdbook.com/blog028.html#:~:text=28.2-,%E8%BF%98%E6%9C%89%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%8A%9F%E8%83%BD%E7%BA%BF%EF%BC%9A,-RST%EF%BC%9A%E7%A1%AC%E4%BB%B6%E5%A4%8D">blog028所示</a>。</p></li><li><p><strong>高电压3.3V</strong>：<code>2.7--3.6</code>；<br><strong>低电压1.8V</strong>：<code>1.7--1.95</code>；<br><strong>更低电压1.2V</strong>：<code>1.1--1.3</code>；(为了获得更高的I&#x2F;O速度)</p></li><li><p><code>tPRUH</code>：3.3伏高电压上电时间，35ms；<br><code>tPRUL</code>：1.8伏低电压上电时间，25ms；</p></li><li><p><code>tPRUV</code>：1.2伏低电压上电时间，20ms；</p></li></ul><h1 id="2、eMMC的工作流程"><a href="#2、eMMC的工作流程" class="headerlink" title="2、eMMC的工作流程"></a>2、eMMC的工作流程</h1><ul><li>eMMC 5.1A协议中p31、p36、p39、p40，有四个状态机转移图，这几个状态转移图可以连起来的。</li><li>Power on之后eMMC设备依次进入<code>Boot mode</code>（可跳过），然后CMD 1之后进入<code>Device identification mode</code>，再然后进入到<code>Data transfer mode</code>，最后可以在<code>Interrupt mode</code>之间切换。还有一个<code>inactive mode</code> ，它出现在eMMC协议Figure 25中，通过CMD 15主动进入或在对应情况下自动进入。</li><li><strong>Boot mode</strong>：是eMMC设备启动的初始模式，用于检查eMMC的健康状况（温度、电压、电容等）并加载配置信息（容量、扇区大小、坏块表等），初始化eMMC存储空间等。</li><li><strong>Device identification mode</strong>：用于向主机提供设备信息，如设备类型、容量、版本等。</li><li><strong>Data transfer mode</strong>：是eMMC设备的主要工作模式，用于执行主机的命令，eMMC的读、写、擦除等数据传输功能都在此模式下实现。</li><li><strong>Interrupt mode</strong>：eMMC device可以向host发送中断，用于通知主机发生了某些事件。eMMC支持多种中断，包括写完成中断、擦除完成中断等。</li><li><strong>Inactive mode</strong>：通常是eMMC设备的一种低功耗状态，用于降低功耗和延长设备寿命，尤其在设备长时间不被访问时。在非活动模式下，eMMC设备通常处于一种较低的功耗状态，以节省电能。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一些个人理解结合网上文章，不一定正确；&lt;/p&gt;
&lt;h1 id=&quot;1、eMMC中VCC、VDD、VSS、VCCQ-的</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="存储" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/%E5%AD%98%E5%82%A8/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>38--关于NAND的一些个人总结</title>
    <link href="https://mkdbook.com/blog038.html"/>
    <id>https://mkdbook.com/blog038.html</id>
    <published>2023-12-27T01:41:33.000Z</published>
    <updated>2023-12-27T02:48:34.872Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一些个人理解结合网上文章，不一定正确；</p><h1 id="一、ONFI协议和DataSheet"><a href="#一、ONFI协议和DataSheet" class="headerlink" title="一、ONFI协议和DataSheet"></a>一、ONFI协议和DataSheet</h1><p><a href="http://www.onfi.org/">ONFI（Open NAND Flash Interface）协议</a>是ONFI公开组织制定的一种用于闪存芯片的开放接口标准，它定义了闪存芯片与主控制器之间的通信协议和信号传输规范。</p><p>DataSheet（数据手册）是不同厂商根据ONFI协议制造出Flash产品之后，对自家Flash产品进行说明的一份技术文档，其中包含了该芯片的详细规格、功能描述、引脚定义、电气特性等信息。</p><ul><li>区别和联系：ONFI是蓝图，厂商的NAND Flash产品必须符合ONFI协议。但是ONFI预留了一些未定义的指令可供不同厂商自定义。故而不同厂商的<code>功能和时序</code>可能会有一些差异，甚至同一功能的实现需要不同命令（例如Erase Suspen&#x2F;Resume，Micron是61h&#x2F;D2h，YMTC是67h&#x2F;D7h）。</li><li>ONFI指令集及预留给厂商的指令集，如图1所示：</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/38.1.png" width="80%" height="80%" alt="38.1"/></center>    <h1 id="二、一些值得注意的点"><a href="#二、一些值得注意的点" class="headerlink" title="二、一些值得注意的点"></a>二、一些值得注意的点</h1><h2 id="2-1、SLC-x2F-TLC模式切换（DAh-x2F-DFh）"><a href="#2-1、SLC-x2F-TLC模式切换（DAh-x2F-DFh）" class="headerlink" title="2.1、SLC&#x2F;TLC模式切换（DAh&#x2F;DFh）"></a>2.1、SLC&#x2F;TLC模式切换（DAh&#x2F;DFh）</h2><p>默认上电后处于TLC模式，可通过DAh命令切换到SLC模式。但是由于NAND物理特性，同一Block的Page是共用一个衬底的，所以不能在同一个Block中进行不同模式的Program操作。</p><p>1、SLC模式写入后，再切换为TLC模式，不能对SLC模式下已经Program的Block进行写入（其它Block可以）。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/38.2.png" width="100%" height="100%" alt="38.2"/></center><p>2、并且不能在TLC模式下，读取SLC模式下Program的数据。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/38.3.png" width="100%" height="100%" alt="38.3"/></center><p>3、需要在TLC模式下发送Erase命令将之前SLC模式下Program的Block擦除，才能写入。注意：在SLC模式下Erase之后再切换为TLC模式，依然不能在TLC模式下写入.</p><h2 id="2-2、Copyback的作用"><a href="#2-2、Copyback的作用" class="headerlink" title="2.2、Copyback的作用"></a>2.2、Copyback的作用</h2><p>命令序列为：00h-35h-85h-10h；</p><p>Copyback用于在<code>同一个LUN</code>中，将data从一个page中读出来，再写入到<code>同一plane</code>中的其他page，可以用于固件做Block Management和wear leveling。</p><blockquote><p>为什么是用同一plane的不同page？</p><p>美光是这样描述的：COPYBACK operations make it possible to transfer data within a plane from one page to another using the cache register.<br>因为不同plane是拥有不同cache、page register的最小单位。</p></blockquote><p>在NAND parameter的byte[7:6]的bit[4]中，定义了是（1）否（0）允许<code>读取奇数page——&gt;复制到偶数page</code>。</p><h2 id="2-3、NAND-Reset命令FFh、FCh、FAh、FDh的区别和联系"><a href="#2-3、NAND-Reset命令FFh、FCh、FAh、FDh的区别和联系" class="headerlink" title="2.3、NAND Reset命令FFh、FCh、FAh、FDh的区别和联系"></a>2.3、NAND Reset命令FFh、FCh、FAh、FDh的区别和联系</h2><p>FCh和FFh类似，但是FCh专门设计出来作用于Synchronous模式，FAh专门设计出来只对单个的LUN作用。FDh在ONFI中并没有定义，但是厂家定义了此命令，尚不清楚它的实际意义。YMTC规定FDh会reset ODT（E2h）设置、以及disabled Vpp feature。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/38.4.png" width="100%" height="100%" alt="38.4"/></center><h2 id="2-3、Read-Status-Register"><a href="#2-3、Read-Status-Register" class="headerlink" title="2.3、Read Status Register"></a>2.3、Read Status Register</h2><h3 id="1、Status-Register和Rb-n信号的关系"><a href="#1、Status-Register和Rb-n信号的关系" class="headerlink" title="1、Status Register和Rb_n信号的关系"></a>1、Status Register和Rb_n信号的关系</h3><p><strong>一个LUN一个独立Status Register</strong>，一个Plane一个独立的Page Register，一个Block是一个独立的擦除单元（因为物理上共用一块衬底），一个page是一个独立的数据读写存储单元。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/38.5.png" width="80%" height="80%" alt="38.5"/></center><p>Rb_n信号反映了一条target或volume上，<code>每个LUN</code>的<code>SR [6]</code>的值的”<code>与逻辑</code>“，即任何一个LUN处于Busy状态Rb_n都会拉低。</p><h2 id="2-4、Change-Read-Column-05h-E0h-or-Change-Read-Column-Enhanced-06h-E0h-的区别"><a href="#2-4、Change-Read-Column-05h-E0h-or-Change-Read-Column-Enhanced-06h-E0h-的区别" class="headerlink" title="2.4、Change Read Column (05h-E0h) or Change Read Column Enhanced(06h-E0h)的区别"></a>2.4、Change Read Column (05h-E0h) or Change Read Column Enhanced(06h-E0h)的区别</h2><ul><li><code>05h-E0h</code>中间只有<code>两个周期</code>的Column地址，假如读一个page时不想从Column 0开始输出数据，可以通过此命令修改data out时的Column地址。实际上这个命令只是选择从page buffer中读取数据。</li><li><code>06h-E0h</code>中间有<code>完整的六个周期</code>的Row+Column地址，可以用于Multi-plane Read的时候切换Plane来进行data out或者独立的LUN的操作。</li><li>ONFI还定义了一种组合方式的Change Read Column Enhanced方式：</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/38.6.png" width="100%" height="100%" alt="38.6"/></center>    <p>注意：我在测试DDR3的时候发现，修改起始的Column地址时，只能（0，2，4，6……）这样偶数，不能从（0修改成1）这样。</p><h1 id="三、经验上的技巧"><a href="#三、经验上的技巧" class="headerlink" title="三、经验上的技巧"></a>三、经验上的技巧</h1><ul><li>1、可以先看NAND datasheet的Command define table，它定义了NAND有哪些功能，分别用了哪些命令，以及这些命令可以在什么时候发送。可以结合Command的功能，着重理解每个命令的作用域（Command Level）。</li><li>2、NAND的Parameter区域（Datasheet一般有这个table）定义了NAND产品的规格，以及各种支持的功能，写验证计划时可以从此入手。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一些个人理解结合网上文章，不一定正确；&lt;/p&gt;
&lt;h1 id=&quot;一、ONFI协议和DataSheet&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="存储" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/%E5%AD%98%E5%82%A8/"/>
    
    
    <category term="Flash" scheme="https://mkdbook.com/tags/Flash/"/>
    
  </entry>
  
  <entry>
    <title>37--SystemC基本语法：数据类型、进程、仿真波形</title>
    <link href="https://mkdbook.com/blog037.html"/>
    <id>https://mkdbook.com/blog037.html</id>
    <published>2023-08-04T09:49:13.000Z</published>
    <updated>2023-08-04T14:49:01.788Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、SystemC专有数据类型"><a href="#一、SystemC专有数据类型" class="headerlink" title="一、SystemC专有数据类型"></a>一、SystemC专有数据类型</h1><ul><li><code>sc_bit</code>：2值单比特（1、0）</li><li><code>sc_logic</code>：4值单比特（1、0、X、Z）</li><li><code>sc_int</code>：1到64比特有符号整型（即类似于C++中int通常对8&#x2F;16&#x2F;32位的数据操作）</li><li><code>sc_uint</code>：1到64比特无符号整型</li><li><code>sc_bigint</code>：任意宽度的有符号整型（不限制位数）</li><li><code>sc_biuint</code>：任意宽度的无符号整型</li></ul><pre><code class="cpp">//例1sc_int&lt;4&gt; x, y;sc_int&lt;8&gt; z;z = (x,y);       //将x和y转脸后赋值给zx=z.range(7,4);  //取z的高4位赋值给x</code></pre><ul><li><code>sc_bv</code>：任意宽度的2值比特向量（适用于只需要二值逻辑向量而不需要算数运算的场合）</li><li><code>sc_lv</code>：任意宽度的4值比特向量</li></ul><pre><code class="cpp">//例2sc_bv&lt;6&gt; val;val=&quot;110011&quot;;bool temp=val.xor_reduce();  //将val的各个位异或后赋值给temp</code></pre><ul><li><code>sc_fixed</code>：模板类有符定点</li><li><code>sc_ufixed</code>：模板类无符号定点</li><li><code>sc_fix</code>：非模板类有符定点</li><li><code>sx_ufix</code>：非模板类无符号定点</li></ul><h1 id="二、进程（process）"><a href="#二、进程（process）" class="headerlink" title="二、进程（process）"></a>二、进程（process）</h1><p><code>进程</code>是程序在并发环境中的<code>执行过程</code>，具有动态性、并发性、独立性、异步性、结构性。</p><p>在SystemC中，进程不是层次化的，即一个进程中不能包含或直接调用其它进程，但进程可以调用非进程的函数和方法。</p><ul><li><code>进程</code>：<br>1、动态概念；<br>2、强调执行，是程序在数据集上的一次执行，有创建、有撤销，存在是暂时的；<br>3、有并发性；<br>4、竞争计算机资源的<strong>基本单位</strong>；<br>5、进程是程序在数据集上的一次执行；<br><code>程序</code>：<br>1、静态概念；<br>2、指令的有序集合，永远存在；<br>3、无并发性；<br>4、不是；<br>5、一个程序可对应多个进程，一个进程可包括多个程序；</li></ul><h2 id="2-1-方法进程：SC-METHOD"><a href="#2-1-方法进程：SC-METHOD" class="headerlink" title="2.1  方法进程：SC_METHOD"></a>2.1  方法进程：SC_METHOD</h2><p>特点：唯一的可以综合的REL级别进程，当敏感列表中的事件发生时，它会被调用，调用后会立刻返回。该进程中<code>不能</code>使用 wait() 类语句。</p><pre><code class="cpp">//用DC_METHOD进程构建异步D触发器SC_MODULE(dff)&#123;&#125;        sc_in_clk clk;        sc_in&lt;bool&gt; rst;        sc_in&lt;bool&gt; din;        sc_in&lt;bool&gt; dout;        void do_it()&#123;                    if (rst)                            dout = false;                    else                            dout = din;        &#125;;        SC_CTOR(dff)&#123;                SC_METHOD(do_it);  //do_it时SC_METHOD进程，当clk或rst有上升沿发生时，do_it就会被触发执行                sensitive_pos(rst);                sensitive_pos(clk);    &#125;&#125;;</code></pre><h2 id="2-2-线程进程：SC-THREAD"><a href="#2-2-线程进程：SC-THREAD" class="headerlink" title="2.2  线程进程：SC_THREAD"></a>2.2  线程进程：SC_THREAD</h2><p>特点：能够<code>被挂起</code>和<code>重新激活</code>。</p><p>SC_THREAD 使用 wait() 挂起，当敏感列表中有事件发生，线程进程被重新激活运行，当遇到新的 wait() 语句再重新挂起。</p><p>多用于 Testbench 中输入激励和输出获取。</p><pre><code class="cpp">//用DC_THREAD进程构建一个监视全加器输入输出变化值的变化情况//File1：monitor.h#include&quot;systemc.h&quot;SC_MODULE(Monitor)&#123;        sc_in&lt;sc_bit&gt; m_a, m_b, m_cin, m_sum, m_cout;        void prc_monitor();        SC_CTOR(Monitor)&#123;                SC_THREAD(prc_monitor); //进程对以下数据敏感，初始化时被执行，并挂起在wait()语句                sensitive&lt;&lt;m_a, m_b, m_cin, m_sum, m_cout;        &#125;&#125;;//File2:monitor.cpp#include&quot;monitor.h&quot;void Monitor::prc_monitor()&#123;            while(1)&#123;                cout&lt;&lt;&quot;At time&quot;&lt;&lt;sc_time_stamp()&lt;&lt;&quot;::&quot;;                cout&lt;&lt;&quot;(a, b, carry_in):&quot;;                cout&lt;&lt;m_a.read()&lt;&lt;m_b.read()&lt;&lt;m_cin.read()&lt;&lt;&quot;,&quot;;                cout&lt;&lt;&quot;(sum, carry_out):&quot;;                cout&lt;&lt;m_sum.read()&lt;&lt;m_cout.read()&lt;&lt;endl;                wait();            &#125;&#125;</code></pre><h2 id="2-3-钟控线程进程：SC-CTHREAD"><a href="#2-3-钟控线程进程：SC-CTHREAD" class="headerlink" title="2.3  钟控线程进程：SC_CTHREAD"></a>2.3  钟控线程进程：SC_CTHREAD</h2><p>clock thread process 特点：只能在时钟沿降时被触发或激活，这种行为更接近硬件。</p><p>引入的目的：产生更好的行为综合（行为综合时从高层次描述综合为 RTL 级描述的过程）。</p><pre><code class="cpp">//例子SC_MODULE(Driver)&#123;            void prc_diver();            SC_CTOR(DRIVER)&#123;                SC_CTHREAD(prc_driver, clk.ps()); //只有在时钟上升沿时prc_driver才被激活。                //必须在指定线程名字的同时，指定时钟和它的边沿。                //下降沿表示方法为 clk.neg()            &#125;&#125;</code></pre><h2 id="2-4-wait-until-、wait-和-next-trigger"><a href="#2-4-wait-until-、wait-和-next-trigger" class="headerlink" title="2.4  wait_until()、wait()和 next_trigger()"></a>2.4  wait_until()、wait()和 next_trigger()</h2><p><code>wait_until</code>：将进程挂起直达指定的表达式的值为真，只能用于线程进程和钟控线程进程。</p><pre><code class="cpp">//wait_until举例wait_until(clock.delayed()==true &amp;&amp; reset.de;ayed()==false);</code></pre><p><code>wait()</code>：等待函数，只能用于线程进程和钟控线程进程。</p><pre><code class="cpp">//1、等;待敏感列表中有事件发生；wait()//2、等待事件发生；sc_event e1;......wait(e1);//3、等待事件之一发生；sc_event e1, e2, e3;......wait(e1|e1|e2);//4、等待事件全部发生；sc_event e1, e2, e3;......wait(e1 &amp; e1 &amp; e2);//5、等待100ns后，后面的语句会被执行；wait(100, SC_NS);//6、如果100ns内事件e1发生，或时间超过了100ns，进程将被激活；sc_event e1;......wait(100, SC_NS, e1); //e1、e2、e3也可以换成第3、4条所述//7、sc_time定义等效替代sc_time t(100, SC_NS);wait(t, e1); //等效于wait(100, SC_NS, e1);</code></pre><p><code>next_trigger()</code>：和 wait() 参数一样，只能用于SC_METHOD进程。</p><p>特点：调用后立刻返回，在一个 SC_METHOD 进程中可以多次调用 next_trigger()，但由最后一个 next_trigger() 决定进程的下一次激活时间。</p><h1 id="三、波形追踪"><a href="#三、波形追踪" class="headerlink" title="三、波形追踪"></a>三、波形追踪</h1><h2 id="3-1-顶层函数sc-main"><a href="#3-1-顶层函数sc-main" class="headerlink" title="3.1  顶层函数sc_main()"></a>3.1  顶层函数sc_main()</h2><p>所有 SystemC 的最顶层函数都是 sc_main()，没有该函数的代码无法编译成功。</p><p>作用：将设计中的所有模块连接在一起，并引入时钟和波形跟踪（wave trace）</p><p>格式：<code>int sc_main(int argc, char* argv[]) &#123;…/Body&#125;</code>，前一个表示参数的数目，后一个是用字符串表示的参数的值。</p><h2 id="3-2-波形追踪"><a href="#3-2-波形追踪" class="headerlink" title="3.2  波形追踪"></a>3.2  波形追踪</h2><pre><code class="cpp">#include &lt;systemc.h&gt;int sc_main(int argc, char* argv[]) &#123;    // 创建VCD波形跟踪文件    sc_trace_file *wf = sc_create_vcd_trace_file(&quot;counter&quot;);    // 定义信号或模块    sc_signal&lt;bool&gt; clk;    sc_signal&lt;int&gt; counter;    // 将信号与波形跟踪文件相关联，所有于wf关联的信号值都会被记录在counter.vcd文件中    sc_trace(wf, clk, &quot;clk&quot;);    sc_trace(wf, counter, &quot;counter&quot;);    // 创建模块等其他初始化操作    // ...        // 开始仿真运行，持续1000个时间单位    sc_start(1000, SC_NS);    // 仿真结束后关闭波形跟踪文件    sc_close_vcd_trace_file(wf);    return 0; //返回之前必须关闭波形文件&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、SystemC专有数据类型&quot;&gt;&lt;a href=&quot;#一、SystemC专有数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、SystemC专有数据类型&quot;&gt;&lt;/a&gt;一、SystemC专有数据类型&lt;/h1&gt;&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="语言" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="SystemC" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/SystemC/"/>
    
    
    <category term="SystemC" scheme="https://mkdbook.com/tags/SystemC/"/>
    
  </entry>
  
  <entry>
    <title>36--SystemC基本语法：模块、端口、信号、时钟</title>
    <link href="https://mkdbook.com/blog036.html"/>
    <id>https://mkdbook.com/blog036.html</id>
    <published>2023-08-04T09:23:32.000Z</published>
    <updated>2023-08-04T09:46:42.126Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、模块的定义：SC-MODULE"><a href="#一、模块的定义：SC-MODULE" class="headerlink" title="一、模块的定义：SC_MODULE"></a>一、模块的定义：SC_MODULE</h1><p>关键字：<code>SC_MODULE</code></p><p>解释：SC_MODULE 是 SystemC 库中定义的一个宏，使用它定义一个模块实际上是定义了一个新的 C++ 类。</p><h1 id="二、模块的端口：sc-in、sc-out、sc-inout"><a href="#二、模块的端口：sc-in、sc-out、sc-inout" class="headerlink" title="二、模块的端口：sc_in、sc_out、sc_inout"></a>二、模块的端口：sc_in、sc_out、sc_inout</h1><p><code>端口</code>使数据能够在模块间通过。</p><p>端口分为三种类型：<code>sc_in</code>、<code>sc_out</code>、<code>sc_inout</code>。</p><p>在端口定义时可指定数据类型：如 bool、int、short、char 等。</p><p>举例，如下：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/36.1.png" width="75%" height="75%" alt="36.1"/></center><pre><code class="cpp">SC_MODULE(fifo)&#123;            sc_in_clk              clk;                 //clock            sc_in&lt;bool&gt;            rst;                 //reset            sc_in&lt;bool&gt;            wr_en;               //FIFO write enable            sc_in&lt;bool&gt;            rd_en;               //FIFO read enable            sc_in&lt;int&gt;             din;                 //data input, 32 bit bus            sc_out&lt;bool&gt;           full, almost_full;            sc_out&lt;bool&gt;           enpty, almost_empty;            sc_out&lt;unsigned short&gt; data_count;          //FIFO data count      sc_out&lt;int&gt;            dout;                //FIFO data out&#125;</code></pre><h1 id="三、模块的信号：sc-signal"><a href="#三、模块的信号：sc-signal" class="headerlink" title="三、模块的信号：sc_signal"></a>三、模块的信号：sc_signal</h1><p>模块之间通过<code>信号</code>将端口连接起来，信号是数据的载体，可以认为信号就是<code>连线</code>（类比于 Verilog 中的 wire）。</p><p>关键字：<code>sc_signal&lt;T&gt;</code></p><p>举例，如下：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/36.2.png" width="75%" height="75%" alt="36.2"/></center><p>如图36.2所示：<code>operator_ctrl</code>、 <code>operand_ctrla</code>、<code>operand_ctrlb</code>、<code>a</code>、<code>b</code>、<code>c</code>、<code>result</code>，为 7 个信号。</p><p>注：信号和子模块的端口处于不同的设计层次，所以允许信号和端口同名，如：ALU 的 <code>result 端口</code>和<code>信号 result</code>。</p><h2 id="3-1-端口和信号的关系"><a href="#3-1-端口和信号的关系" class="headerlink" title="3.1  端口和信号的关系"></a>3.1  端口和信号的关系</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/36.3.png" width="75%" height="75%" alt="36.3"/></center><p>如图36.3所示，模块1和模块2分别有一个进程，假设这两个模块之间的信号为D；</p><p>在T1时刻，<code>Clk</code>从<code>0 ——&gt; 1</code>，恰好模块1中的进程也将<code>信号 D</code> 从<code>0 ——&gt; 1</code>，但是模块1和模块2中的进程都在同一个上升沿被同时触发，它们工作在同一个时间步内，<br><strong>所以在T1时刻，模块2中的进程看到的 D 值是 0（旧值）。</strong></p><h2 id="3-2-多端口和信号的快速声明"><a href="#3-2-多端口和信号的快速声明" class="headerlink" title="3.2  多端口和信号的快速声明"></a>3.2  多端口和信号的快速声明</h2><pre><code class="cpp">sc_in&lt;sc_logic&gt; a[32];  //a[0]到a[31]，32个端口，方向为输入，数据类型为sc_logicsc_signal&lt;sc_logic&gt; abus[16];  //abus[0]到abus[15]，16个信号</code></pre><h2 id="3-3-隐式类型转换，助手函数read-和write"><a href="#3-3-隐式类型转换，助手函数read-和write" class="headerlink" title="3.3  隐式类型转换，助手函数read()和write()"></a>3.3  隐式类型转换，助手函数read()和write()</h2><pre><code class="cpp">//如果定义了如下端口sc_in&lt;bool&gt;  data_in;sc_out&lt;int&gt;  data_out;//data_out=data_in;//在进程中直接赋值是非法的，因为两者类型不同data_out.write(data_in.read());</code></pre><h1 id="四、名字关联"><a href="#四、名字关联" class="headerlink" title="四、名字关联"></a>四、名字关联</h1><p>如图36.2所示，顶层模块 Top 的作用是：将各个子模块连接起来，子模块的端口是通过 Top 中定义的信号来关联的。</p><p>如何将 Top 的信号和子模块的信号关联，<code>名字关联</code>和<code>位置关联</code>。</p><p>例子：Top.h 文件如下</p><pre><code class="cpp">#include &quot;systemc.h&quot;#include &quot;DataGenerator.h&quot;  //For Gen_a and Gen_b#include &quot;Control.h&quot;#include &quot;ALU.h&quot;#include &quot;OperatorGenerator.h&quot;#include &quot;DisplayResult.h&quot;SC_MODULE(Top) &#123;//指针定义Control             *Ctrll;DataGenerator       *Gen_a, *Gen_b;OperatorGenerator   *OpGenl;ALU                 *ALU1;DisplayResult       *DispResultl;//端口定义，Top层可以没有端口， 这里只有一个Clock端口sc_in_clk   clk；//信号定义sc_signal&lt;int&gt;   a, b, result;sc_sign&lt;sc_unit&lt;&gt; &gt;   c;//知识点：sc_unit&lt;&gt;是SystemC中专有的数据类型，4表示数据只有4位，故可表示16中=种操作；//在声明中，sc_sign&lt;sc_unit&lt;&gt; &gt;，中间有个额外的空格不能省略。sc_sign&lt;bool&gt;   operator_ctrl, operand_ctrla, opcrand_ctrlb;//Constructor1 位置关联（不推荐）SC_CTOR(Top) &#123;    Ctrl1 = new Control(&quot;Ctrl1&quot;);  //创建一个新的对象指向它的指针    (*Ctrl1) (clk, operand_ctrla, operand_ctrlb, operator_ctrl);//用对象的指针把信号关联到对象端口//其它模块省略…………&#125;//Constructor2 名字关联（推荐）SC_CTOR(Top)&#123;    Ctrl1 = new Control(&quot;Ctrl1&quot;);    Ctrl1 -&gt; clk (clk);    Ctrl1 -&gt; op  (operator_ctrl)    Ctrl1 -&gt; or_b(operand_ctrlb);    Ctrl1 -&gt; or_a(operand_ctrla);//其它模块省略…………&#125;&#125;</code></pre><h1 id="五、模块的构造函数：SC-CTOR"><a href="#五、模块的构造函数：SC-CTOR" class="headerlink" title="五、模块的构造函数：SC_CTOR"></a>五、模块的构造函数：SC_CTOR</h1><p>关键字：<code>SC_CTOR</code></p><p>作用：1、创建模块内部数据结构，并把这些数据结构初始化为已知值。<br>　　　2、初始化进程的类型，并创建进程的敏感列表。</p><p>举例：</p><pre><code class="cpp">//ConstructorSC_CTOR(asyn_fifo)&#123;     SC_METHOD(write);  //进程write()对写时钟和复位信号敏感，工作在写时钟，异步复位。        sensitive&lt;&lt;wr_clk&lt;&lt;rst;         SC_METHOD(read);  //进程read()工作在读时钟，异步复位。                sensitive&lt;&lt;rd_clk&lt;&lt;rst;         SC_METHOD(synchronize_pointer);  //进程synchronize_pointer完成指针交换工作。                sensitive&lt;&lt;wr_clk&lt;&lt;rd_clk&lt;&lt;rst&lt;&lt;ptr_wr&lt;&lt;ptr_rd;  //后两个是写指针和读指针//定义为：sc_signal&lt;int&gt;  ptr_wr, ptr_rd; //write pointer and read pointer;…………for(i=0;i++;i&lt;DEPTH) &#123;mem[i]=0;&#125;  //for循环把FIFO的存储空间初始化为0.&#125;</code></pre><p>注意：构造函数的名字必须与模块的名字相同</p><h1 id="六、SystemC时钟和时间模型"><a href="#六、SystemC时钟和时间模型" class="headerlink" title="六、SystemC时钟和时间模型"></a>六、SystemC时钟和时间模型</h1><pre><code class="cpp">//名称为clk1，表示20个时间单位，单位是ns，占空比是0.5(高电平持续0.5个周期)，//在5ns时第一次变化（相位偏移5个单位）。//ture：信号将从高电平开始，false：则信号从低电平开始。sc_clock clk1(&quot;clk1&quot;, 20, SC_NS, 0.5, 5, true);//名称为clk2，…………，在0ns时第一次变化sc_clock clk2(&quot;clk2&quot;, 20, SC_NS, 0.5, 0, true);//或者引入一个sc_time类型常量time1，通过time1初始化clk3；sc_time time1(20， SC_NS);sc_clock clk3(&quot;clk3&quot;, time1);</code></pre><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/36.4.png" width="75%" height="75%" alt="36.4"/></center><pre><code class="cpp">//设置时间分辨率sc_set_time_resolution(10, SC_PS);//分辨率为10ps//1、时间分辨率必须是10的幂；//2、……只能在仿真开始之前设置；//3、……只能设置1次；//4、必须在任何的非零的sc_time声明之前设置</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、模块的定义：SC-MODULE&quot;&gt;&lt;a href=&quot;#一、模块的定义：SC-MODULE&quot; class=&quot;headerlink&quot; title=&quot;一、模块的定义：SC_MODULE&quot;&gt;&lt;/a&gt;一、模块的定义：SC_MODULE&lt;/h1&gt;</summary>
      
    
    
    
    <category term="语言" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="SystemC" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/SystemC/"/>
    
    
    <category term="SystemC" scheme="https://mkdbook.com/tags/SystemC/"/>
    
  </entry>
  
  <entry>
    <title>35--SystemC简介及环境配置</title>
    <link href="https://mkdbook.com/blog035.html"/>
    <id>https://mkdbook.com/blog035.html</id>
    <published>2023-08-04T08:17:29.000Z</published>
    <updated>2023-08-04T09:00:42.181Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1、SystemC简介及环境配置"><a href="#1、SystemC简介及环境配置" class="headerlink" title="1、SystemC简介及环境配置"></a>1、SystemC简介及环境配置</h1><h1 id="一、SystemC简介"><a href="#一、SystemC简介" class="headerlink" title="一、SystemC简介"></a>一、SystemC简介</h1><ul><li>SystemC 是一种基于 C++ 的用于系统级建模和仿真的语言，本质上是在 C++ 的基础上添加的硬件扩展库和仿真核，这使得SystemC 可以建模不同抽象级别的包括软件和硬件的复杂电子系统。<br>它由<code>Open SystemC Initiative（OSCI）</code>开发（1999年），与 Accellera Systems Initiative 联合将其标准化为 IEEE Std. 1666-2011™。</li><li>SystemC目的：<strong>实现用单一语言完成设计规范、系统体系结构分析、验证平台和行为模型。</strong><br>但是RTL级和门级建模并非其擅长领域。</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/35.1.png" width="75%" height="75%" alt="35.1  systemc-architecture"/></center><h2 id="1-1-开发顺序"><a href="#1-1-开发顺序" class="headerlink" title="1.1  开发顺序"></a>1.1  开发顺序</h2><p>系统级建模  ——&gt;  RTL级设计  ——&gt;  验证               <br>system C                  Verilog            SystemVerilog</p><h2 id="1-2-为什么使用-SystemC？"><a href="#1-2-为什么使用-SystemC？" class="headerlink" title="1.2  为什么使用 SystemC？"></a>1.2  为什么使用 SystemC？</h2><p>传统的硬件描述语言和 SystemVerilog 的 C 接口不支持硬件设计中的<code>并发性</code>、<code>层次性</code>和<code>互联</code>，所以不适合描述复杂多样的系统行为。</p><ul><li>SystemC 支持在系统级进行设计和验证，独立于任何详细的硬件和软件实现，通过 SystemC 建模可以用于验证和固件开发 ，使得硬件设计和软件设计可以同步进行，缩短整个芯片上市时间。</li><li>SystemC 可以与 RTL 设计进行联合验证，这使得可以更早地发现错误。</li><li>SystemC 的抽象级别更高，这使得可以更快、更有效率地进行架构权衡分析、设计和重新设计。</li><li>SystemC 是一个开源标准，这使得可以由任何公司使用。</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/35.2.png" width="75%" height="75%" alt="35.2  SystemC作用"/></center>    <h2 id="1-3-SystemC-和-SystemVerilog"><a href="#1-3-SystemC-和-SystemVerilog" class="headerlink" title="1.3  SystemC 和 SystemVerilog"></a>1.3  SystemC 和 SystemVerilog</h2><p>当时的系统语言发展方向有两个：</p><p><code>SystemVerilog</code>：扩充传统的硬件描述语言VHDL和Verilog HDL，使它们支持抽象数据类型，从而具有系统描述能力。<br><code>SystemC</code>：扩展传统的软件语言C&#x2F;C++，使他们支持硬件描述。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/35.3.png" width="75%" height="75%" alt="35.3  硬件描述语言工作的层级"/></center><h1 id="二、SystemC-环境搭建"><a href="#二、SystemC-环境搭建" class="headerlink" title="二、SystemC 环境搭建"></a>二、SystemC 环境搭建</h1><ul><li>1、下载OSCI库并解压<br>下载地址：<a href="https://www.accellera.org/downloads/standards/systemc">https://www.accellera.org/downloads/standards/systemc</a></li></ul><pre><code class="bash">tar xvf systemc-2.3.3.tar.gz</code></pre><ul><li>2、构建和编译</li></ul><pre><code class="bash">cd systemc-2.3.3mkdir buildcd buildcmake ../ -DCMAKE_CXX_STANDARD=17 -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=/usr/local/systemcmake -j8</code></pre><p><code>--prefix</code>：设置安装的位置。这里将安装位置设置为<code>/usr/local/systemc</code>，安装的内容包含：</p><pre><code class="bash">Installation prefix (aka SYSTEMC_HOME):      /usr/local   Header files  : &lt;SYSTEMC_HOME&gt;/include   Libraries     : &lt;SYSTEMC_HOME&gt;/lib-linux64   Documentation : &lt;SYSTEMC_HOME&gt;/docs   Examples      : &lt;SYSTEMC_HOME&gt;/examples</code></pre><ul><li>3、安装</li></ul><pre><code class="bash">make install</code></pre><h1 id="三、环境测试"><a href="#三、环境测试" class="headerlink" title="三、环境测试"></a>三、环境测试</h1><h2 id="3-1-counter-cpp"><a href="#3-1-counter-cpp" class="headerlink" title="3.1  counter.cpp"></a>3.1  counter.cpp</h2><pre><code class="cpp">#include &lt;systemc.h&gt;SC_MODULE (counter) &#123;  sc_in_clk     clock ;      // Clock input of the design  sc_in&lt;bool&gt;   reset ;      // active high, synchronous Reset input  sc_in&lt;bool&gt;   enable;      // Active high enable signal for counter  sc_out&lt;sc_uint&lt;4&gt; &gt; counter_out; // 4 bit vector output of the counter  //Local Variables  sc_uint&lt;4&gt;count;  // Counter logic  void incr_count () &#123;    // At every rising edge of clock we check if reset is active    // If active, we load the counter output with 4&#39;b0000    if (reset.read() == 1) &#123;      count =  0;      counter_out.write(count);    // If enable is active, then we increment the counter    &#125; else if (enable.read() == 1) &#123;      count = count + 1;      counter_out.write(count);      cout&lt;&lt;&quot;@&quot; &lt;&lt; sc_time_stamp() &lt;&lt;&quot; :: Incremented Counter &quot;        &lt;&lt;counter_out.read()&lt;&lt;endl;    &#125;  &#125; // End of function incr_count  // Constructor for the counter  // Since this counter is a positive edge trigged one,  // We trigger the below block with respect to positive  // edge of the clock and also when ever reset changes state  SC_CTOR(counter) &#123;    cout&lt;&lt;&quot;Executing new&quot;&lt;&lt;endl;    SC_METHOD(incr_count);    sensitive &lt;&lt; reset;    sensitive &lt;&lt; clock.pos();  &#125; // End of Constructor&#125;; // End of Module counter</code></pre><h2 id="3-2-counter-tb-cpp"><a href="#3-2-counter-tb-cpp" class="headerlink" title="3.2  counter_tb.cpp"></a>3.2  counter_tb.cpp</h2><pre><code class="cpp">#include &lt;systemc.h&gt;#include &quot;counter.cpp&quot;int sc_main (int argc, char* argv[]) &#123;  sc_signal&lt;bool&gt;   clock;  sc_signal&lt;bool&gt;   reset;  sc_signal&lt;bool&gt;   enable;  sc_signal&lt;sc_uint&lt;4&gt; &gt; counter_out;  int i = 0;  // Connect the DUT  counter counter(&quot;COUNTER&quot;);  counter.clock(clock);  counter.reset(reset);  counter.enable(enable);  counter.counter_out(counter_out);  sc_start(1, SC_NS);  // Open VCD file  sc_trace_file *wf = sc_create_vcd_trace_file(&quot;counter&quot;);  // Dump the desired signals  sc_trace(wf, clock, &quot;clock&quot;);  sc_trace(wf, reset, &quot;reset&quot;);  sc_trace(wf, enable, &quot;enable&quot;);  sc_trace(wf, counter_out, &quot;count&quot;);  // Initialize all variables  reset = 0;       // initial value of reset  enable = 0;      // initial value of enable  for (i=0;i&lt;5;i++) &#123;    clock = 0;     sc_start(1, SC_NS);    clock = 1;     sc_start(1, SC_NS);  &#125;  reset = 1;    // Assert the reset  cout &lt;&lt; &quot;@&quot; &lt;&lt; sc_time_stamp() &lt;&lt;&quot; Asserting reset\n&quot; &lt;&lt; endl;  for (i=0;i&lt;10;i++) &#123;    clock = 0;     sc_start(1, SC_NS);    clock = 1;     sc_start(1, SC_NS);  &#125;  reset = 0;    // De-assert the reset  cout &lt;&lt; &quot;@&quot; &lt;&lt; sc_time_stamp() &lt;&lt;&quot; De-Asserting reset\n&quot; &lt;&lt; endl;  for (i=0;i&lt;5;i++) &#123;    clock = 0;     sc_start(1, SC_NS);    clock = 1;     sc_start(1, SC_NS);  &#125;  cout &lt;&lt; &quot;@&quot; &lt;&lt; sc_time_stamp() &lt;&lt;&quot; Asserting Enable\n&quot; &lt;&lt; endl;  enable = 1;  // Assert enable  for (i=0;i&lt;20;i++) &#123;    clock = 0;     sc_start(1, SC_NS);    clock = 1;     sc_start(1, SC_NS);  &#125;  cout &lt;&lt; &quot;@&quot; &lt;&lt; sc_time_stamp() &lt;&lt;&quot; De-Asserting Enable\n&quot; &lt;&lt; endl;  enable = 0; // De-assert enable  cout &lt;&lt; &quot;@&quot; &lt;&lt; sc_time_stamp() &lt;&lt;&quot; Terminating simulation\n&quot; &lt;&lt; endl;  sc_close_vcd_trace_file(wf);  return 0;// Terminate simulation&#125;</code></pre><h2 id="3-3-Makefile"><a href="#3-3-Makefile" class="headerlink" title="3.3 Makefile"></a>3.3 Makefile</h2><pre><code class="makefile">all:    g++ -I. -I /usr/local/systemc/include -L. -L/usr/local/systemc/lib64 \        -Wl,-rpath=/usr/local/systemc/lib64 -lsystemc -lm -o counter \        counter.cpp counter_tb.cpp    ./counterclean:     rm -rf counter counter.vcd</code></pre><h2 id="3-4-结果"><a href="#3-4-结果" class="headerlink" title="3.4  结果"></a>3.4  结果</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/35.4.png" width="75%" height="75%" alt="35.4  仿真结果"/></center><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/75dbe7f64019">centos7 搭建systemc开发环境 - 简书 (jianshu.com)</a></p><p><a href="https://blog.51cto.com/34144451/3773530">记一次 Centos7 cmake 版本升级（由 v2.8.12.2 升级至 v3.14.5）_51CTO博客_linux cmake升级</a></p><p><a href="https://cloud.tencent.com/developer/article/1538041">Linux目录详解，软件应该安装到哪个目录-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1、SystemC简介及环境配置&quot;&gt;&lt;a href=&quot;#1、SystemC简介及环境配置&quot; class=&quot;headerlink&quot; title=&quot;1、SystemC简介及环境配置&quot;&gt;&lt;/a&gt;1、SystemC简介及环境配置&lt;/h1&gt;&lt;h1 </summary>
      
    
    
    
    <category term="语言" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="SystemC" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/SystemC/"/>
    
    
    <category term="SystemC" scheme="https://mkdbook.com/tags/SystemC/"/>
    
  </entry>
  
  <entry>
    <title>34--NAND Flash协议：ONFI和Toggle</title>
    <link href="https://mkdbook.com/blog034.html"/>
    <id>https://mkdbook.com/blog034.html</id>
    <published>2023-08-04T07:34:49.000Z</published>
    <updated>2023-08-04T08:15:43.453Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>NAND Flash的协议目前主要分为两个阵营：<code>ONFI</code>和<code>Toggle</code>。</p><ul><li><strong>ONFI：Open NAND Flash Interface</strong><br>1、Intel、美光、海力士、SMI、群联、索尼、飞索半导体；<br>2、支持Clock；<br>3、同步&#x2F;异步；<br>4、先出现；</li><li><strong>Toggle：Toggle DDR、Toggle Mode NAND Flash</strong><br>1、东芝、三星、Toshiba；<br>2、没有Clock，写数据用DQS差分信号跳变沿触发；<br>读数据由host发的REN差分信号跳变沿发读request，而后在DQS跳变沿输出数据；<br>3、异步；<br>4、后出现；</li></ul><h1 id="一、Legacy-Interface"><a href="#一、Legacy-Interface" class="headerlink" title="一、Legacy Interface"></a>一、Legacy Interface</h1><ul><li>第一个NAND Flash Device Interface协议为<code>Legacy</code>，ONFI 1.0基于Legacy统一了Flash的规范；</li><li>15个引脚（8个data+7个controller信号）；</li><li>SDR、异步；</li><li>速度只有40MT&#x2F;s；</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/34.1.png" width="75%" height="75%" alt="34.1"/></center><h1 id="二、ONFI-Specification-History"><a href="#二、ONFI-Specification-History" class="headerlink" title="二、ONFI Specification History"></a>二、ONFI Specification History</h1><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/34.2.png" width="75%" height="75%" alt="34.2  ONFI迭代历程"/></center><ul><li><p><strong>ONFI 1.0 ——2006&#x2F;10&#x2F;28</strong><br>（物理接口、封装、工作机制、控制指令、寄存器规范、ECC、带宽<code>50MT/s</code>，统一了Flash接口规范）</p></li><li><p><strong>ONFI 2.0 ——2008&#x2F;2&#x2F;27</strong><br>（带宽133MT&#x2F;s，使用了<code>NV-DDR</code>技术，<code>synchronous</code>传输，引入Clock信号）<br><strong>注</strong>：<code>WE#————&gt;CLK信号</code>、<code>RE#——&gt;W/R#读写方向信号</code>、<code>I/O</code>——&gt;<code>DQ</code>、新增DQS</p></li><li><p><strong>ONFI 2.1 ——2009&#x2F;1&#x2F;14</strong><br>（带宽166MT&#x2F;s和200MT&#x2F;s，新增“Small Data Move”与“Change Row Address”指令）</p></li><li><p><strong>ONFI 2.2  ——2009&#x2F;10&#x2F;7</strong><br>（LUN reset、增强页编程寄存器的清除和ICC测量和规范）</p></li><li><p><strong>ONFI 3.0   ——2011&#x2F;3&#x2F;15</strong><br>（<code>改回asynchronous</code>接口，采用和Togele 2.0一样的<code>NV-DDR2（异步）</code>、带宽400MT&#x2F;s、ODT）<br><strong>注</strong>：NV-DDR：Non-Volatile DDR</p></li><li><p>ONFI 2.3a ——2011&#x2F;10&#x2F;19<br>（EZ-NAND）</p></li><li><p><strong>ONFI 3.1 ——2012&#x2F;9&#x2F;21</strong><br>（LUN SET&#x2F;GET Features、并为NV-DDR2接口实现了额外的<code>data setup and hold</code> values。）</p></li><li><p><strong>ONFI 3.2 ——2013&#x2F;6&#x2F;13</strong><br>（533MT&#x2F;s）</p></li><li><p><strong>ONFI 4.0 ——2014&#x2F;4&#x2F;2</strong><br>（667MT&#x2F;s——NV-DDR2、800MT&#x2F;s——<code>NV-DDR3</code>、ZQ calibration）<br><strong>注</strong>：NV-DDR3是低电压标准，为了支持1.2v的controller</p></li><li><p><strong>ONFI 4.1 ——2017&#x2F;10&#x2F;12</strong><br>（1200MT&#x2F;s、DCC——Duty Cycle Correction、VCC 2.35-3.6可配置，原来为3.3&#x2F;1.8&#x2F;1.2三种）</p></li><li><p><strong>ONFI 4.2 ——2020&#x2F;2&#x2F;12</strong><br>（1600MT&#x2F;s）</p></li><li><p><strong>ONFI 5.0 ——2021&#x2F;3&#x2F;25</strong><br>（<code>NV-LPDDR4</code> 、2400MT&#x2F;s）</p></li><li><p><strong>ONFI 5.1 ——2022&#x2F;8&#x2F;11</strong><br>（3600MT&#x2F;s）</p></li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/34.3.png" width="75%" height="75%" alt="34.3"/></center><h1 id="三、Toggle"><a href="#三、Toggle" class="headerlink" title="三、Toggle"></a>三、Toggle</h1><h2 id="1、Toggle-NAND-1-0-Asynchronous-DDR-NAND-Interface"><a href="#1、Toggle-NAND-1-0-Asynchronous-DDR-NAND-Interface" class="headerlink" title="1、Toggle NAND 1.0 (Asynchronous DDR NAND Interface)"></a>1、<strong>Toggle NAND 1.0 (Asynchronous DDR NAND Interface)</strong></h2><h3 id="双向DQS作用"><a href="#双向DQS作用" class="headerlink" title="双向DQS作用"></a>双向DQS作用</h3><ul><li>数据在DQS的上升沿和下降沿传输；</li></ul><p>DQS在写操作时，由host驱动；读操作时，由NAND操作；</p><ul><li>异步传输，没有时钟信号，toggle DDR interface和同步传输相比，具有更低的功耗；</li><li>133MT&#x2F;s，对应ONFI 2.0；</li></ul><h2 id="2、Toggle-NAND-2-0-Asynchronous-High-Speed-DDR-NAND-Interface"><a href="#2、Toggle-NAND-2-0-Asynchronous-High-Speed-DDR-NAND-Interface" class="headerlink" title="2、Toggle NAND 2.0 (Asynchronous High-Speed DDR NAND Interface)"></a>2、<strong>Toggle NAND 2.0 (Asynchronous High-Speed DDR NAND Interface)</strong></h2><ul><li>400MT&#x2F;s的吞吐量；</li><li>differential signal support is provided for the DQS and RE# signals，on-die termination (ODT) and VREF voltage support was added；</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/34.4.png" width="75%" height="75%" alt="34.4"/></center><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>Toggle同步模式下不用clock</strong>，写数据通过DQS差分信号边沿触发，读数据Host在REN差分信号跳变沿发送request，DQS跳变沿输出数据。</p><p><strong>ONFI同步模式下有clock</strong>，数据、命令、地址都要与clock同步，但是DQS、clock都不是差分信号，所以边沿容易受干扰。但ONFI 3.0之后引入NV-DDR2模式，就和Toggle一样了，不再用clock，用DQS和REN差分信号实现数据传输。</p><h2 id="1、EZ-NAND协议"><a href="#1、EZ-NAND协议" class="headerlink" title="1、EZ-NAND协议"></a>1、EZ-NAND协议</h2><p><strong>EZ-NAND</strong>协议是ECC Zero NAND，这一协议将NAND闪存的纠错码管理由主控芯片中转移到了闪存自身，减轻了主控芯片负担。</p><p><strong>EZ-NAND</strong>首次出现在2.3的版本中，但是3.0并未全面支持，原因是当时容量、速度、成本是第一要务，集成ECC会增加闪存的成本。</p><h2 id="2、MT-x2F-s传输单位——可以更准确地描述速率"><a href="#2、MT-x2F-s传输单位——可以更准确地描述速率" class="headerlink" title="2、MT&#x2F;s传输单位——可以更准确地描述速率"></a>2、MT&#x2F;s传输单位——可以更准确地描述速率</h2><p>MT&#x2F;s表示每秒传输100万次（Million Transfers per Second）；</p><ul><li><code>1T/s</code>：每秒做了一次传输；<br><code>1Hz</code>：每秒一个时钟周期；<br>区别：例如<code>DDR</code>模式中，可在时钟上升沿和下降沿进行两次数据传输，故实际传输速率为：<br><code>1Hz=2T/s，1MHz=2MT/s</code>；</li></ul><h2 id="3、同步和异步"><a href="#3、同步和异步" class="headerlink" title="3、同步和异步"></a>3、同步和异步</h2><ul><li><code>synchronous</code>：ONFI 2.0中增加了NV-DDR功能，可以在CLK信号同步传输，数据在DQS的上升沿和下降沿传输，W&#x2F;R#信号控制数据方向。<br>特点：使用同一个信号源进行同步，提高了<code>信号采集</code>的<code>准确性</code>，可靠性和传输速率更高。</li><li><code>asynchronous</code>：ONFI 3.0中采用了和Toggle 2.0一样的NV-DDR2技术，采用的是异步的方式。<br>特点：功耗低，设计更简单。</li></ul><h2 id="4、NV-DDR不同版本的特点"><a href="#4、NV-DDR不同版本的特点" class="headerlink" title="4、NV-DDR不同版本的特点"></a>4、NV-DDR不同版本的特点</h2><ul><li><code>NV-DDR</code>：双边沿采样，并采用源同步时钟来精确所存数据、命令、地址信号。</li><li><code>NV-DDR2</code>：引入了差分信号和On-Die Termination (ODT)技术来提升信号质量。</li><li><code>NV-DDR3</code>：NV-DDR3引入了多项校准技术，包括ZQ Calibration、Duty Cycle Correction (DCC)和读&#x2F;写DQ校准。</li><li><code>NV-LPDDR4</code>：和NV-DDR3速率相同，优势在于采用LTT技术后可大幅度降低读操作功耗。</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/34.5.png" width="75%" height="75%" alt="34.5"/></center>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;NAND Flash的协议目前主要分为两个阵营：&lt;code&gt;ONFI&lt;/code&gt;和&lt;code&gt;Toggle&lt;/c</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="存储" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/%E5%AD%98%E5%82%A8/"/>
    
    
    <category term="Flash" scheme="https://mkdbook.com/tags/Flash/"/>
    
  </entry>
  
  <entry>
    <title>33--eMMC的RPMB分区（Replay Protected Memory Block）</title>
    <link href="https://mkdbook.com/blog033.html"/>
    <id>https://mkdbook.com/blog033.html</id>
    <published>2023-06-24T15:10:24.000Z</published>
    <updated>2023-06-24T15:20:57.622Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、RPMB认证（Authentication）"><a href="#一、RPMB认证（Authentication）" class="headerlink" title="一、RPMB认证（Authentication）"></a>一、RPMB认证（Authentication）</h1><p>RPMB使用共享密钥（Shared Secret）的方式进行认证，即host和device 使用相同的身份认证密钥（<code>AuthKey</code>&#x2F;<code>RPMB Key</code>），具体工作方式如下：</p><p>1.1、首先<code>RPMB Key</code>由host写到eMMC device中。（必须在安全的环境中写入，通常在生产线上）<br>1.2、然后，在RPMB区数据进行的读、写操作时，host和device需要使用身份验证密钥（<code>RPMB Key</code>）<code>对信息</code>进行签名（sign）和身份验证（authenticate）。<br>1.3、对信息进行签名时，需要<code>消息身份验证代码 （MAC）</code>，该代码是使用 HMAC SHA-256 算法计算而成的。（详细见2.1-2.4）</p><blockquote><p><code>HMAC</code>是指基于散列的消息认证码（Hash-based Message Authentication Code）。<br>哈希算法特点：即使只改变原数据中1bit的数据，两者的哈希值也是完全不同的。<br><code>AuthKey</code>&#x2F;<code>RPMB Key</code>是不能被泄露的，故host需要在<code>TEE环境</code>中对密钥进行操作。</p></blockquote><blockquote><p><code>TEE环境</code>（trusted execution environment）：可信任执行环境指CPU内部的一个安全区域，该区域可以保证数据的安全性和完整性，外部各方不可见或无法访问，无论请求访问的实体有多大权限。（如指纹识别、密码处理、数据加解密、安全认证、系统升级版本号认证等操作都是在此区域执行）<br><code>REE环境</code>（rich  execution environment）：是所有移动设备通用的环境，运行通用的 OS（Operating System），例如 Android，IOS 系统等。</p></blockquote><h1 id="二、RPMB如何防止Replay-Attack？"><a href="#二、RPMB如何防止Replay-Attack？" class="headerlink" title="二、RPMB如何防止Replay Attack？"></a>二、RPMB如何防止Replay Attack？</h1><p>Replay Protection和基本思想是确保每条信息都是独一无二的。<br>RPMB中，有一个<code>只读的Write Counter</code>，在每次写入信息后，该计数器就会增加，且新值会包含在下一次认证代码的计算中。<br>该计算会把下列内容作为计算的输入（图33.1<code>bit[283:0]</code>相应需要的部分按顺序连接）：</p><ul><li>2.1、The <code>shared/secret key</code>，共享密钥。</li><li>2.2、The <code>message</code>，包括了write command或read result。</li><li>2.3、The <code>write counter</code>，记录了Write RPMB的总次数，此计数器只增不减，32bit，当达到0xFFFF_FFF时，<strong>RPMB就变为只读了</strong>。（<em><strong>用于写操作</strong></em>）</li><li>2.4、A <code>nonce</code>，为每一个read command生成一个随机数。（<em><strong>用于读操作</strong></em>）</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/33.1.png" width="85%" height="85%" alt="33.1"/></center><p>最后，生成的<strong>MAC</strong>是一个256 bit（32 byte）的密码，嵌入在RPMB数据帧中，并与消息数据本身一起发送。</p><h1 id="三、从RPMB读数据"><a href="#三、从RPMB读数据" class="headerlink" title="三、从RPMB读数据"></a>三、从RPMB读数据</h1><p>1、host向eMMC发起读RPMB请求，同时生成一个16 byte的随机数（<code>Nonce</code>）。<br>2、eMMC将请求的数据从RPMB读出，并利用<code>shared/secret key</code>和<code>data</code>、<code>Nonce</code>一起计算得到MAC；<br>3、eMMC再将<code>data</code>、<code>Nonce</code>、和生成的<code>MAC</code>一起发送给host。<br>4、host接收到后，先比较<code>Nonce</code>是否和自己发送的一致，如果一致再利用<code>shared/secret key</code>和<code>data</code>、<code>Nonce</code>一起进行计算，也会得到一个<strong>MAC2</strong>。<br>5、最后，host将生成的<strong>MAC2</strong>和来自eMMC的MAC进行比较，如果一致，就可以确认data不是攻击者伪造的。</p><h1 id="四、向RPMB写数据"><a href="#四、向RPMB写数据" class="headerlink" title="四、向RPMB写数据"></a>四、向RPMB写数据</h1><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/33.2.png" width="75%" height="75%" alt="33.2"/></center><p>1、host先通过读数据流程，读RPMB中的<code>Writer Counter</code>。<br>2、host再将写入相关的<code>Message</code>和<code>Write Counter</code>，利用<code>shared/secret key</code>一起计算生成MAC；<br>3、host再将写入相关的<code>Message</code>、<code>Write Counter</code>、<code>MAC</code>一起发送给eMMC。<br>4、eMMC接收到数据后，先比较<code>Writer Counter</code>是否与当前值一致，如果一致再将接收到的写入相关的<code>Message</code>和<code>Write Counter，</code>利用<code>shared/secret key</code>和一起进行计算，也会得到一个<strong>MAC2</strong>。<br>5、最后，eMMC将生成的<strong>MAC2</strong>和来自host的MAC进行比较，如果相同才会将data写入eMMC的RPMB中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、RPMB认证（Authentication）&quot;&gt;&lt;a href=&quot;#一、RPMB认证（Authentication）&quot; class=&quot;headerlink&quot; title=&quot;一、RPMB认证（Authentication）&quot;&gt;&lt;/a&gt;一</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>32--eMMC password lockunlock</title>
    <link href="https://mkdbook.com/blog032.html"/>
    <id>https://mkdbook.com/blog032.html</id>
    <published>2023-06-24T15:03:24.000Z</published>
    <updated>2023-06-24T15:03:43.514Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1、password存在哪个位置？"><a href="#1、password存在哪个位置？" class="headerlink" title="1、password存在哪个位置？"></a>1、password存在哪个位置？</h2><blockquote><p>128bit的<code>PWD</code>和8bit的<code>PWD_LEN</code>，这两个寄存器是单独的且非易失的（power cycle不会导致被擦除）。</p></blockquote><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/32.1.png" width="75%" height="75%" alt="32.1"/></center><ul><li><code>ERASE</code>：若为“1”则定义forcing erase，所有其他的bit都为0，且只有cmd byte会被发送；</li><li><code>LOCK_UNLOCK</code>：“1”&#x3D; Lock device、“0” &#x3D; Unlock device；<br><strong>注：LOCK_UNLOCK和SET_PWD一起设置是有效的，但是和CLR_PWD一起设置是不允许的！</strong></li><li><code>CLR_PWD</code>：“1” &#x3D; Clear PWD；</li><li><code>SET_PWD</code>：“1” &#x3D; Set new password to PWD；</li><li><code>PWD_LEN</code>：定义后面PWD的长度，有效的password长度为1-16个byte；同时标志，是否设置了password；<br><strong>注：16 * 8 &#x3D; 128bit，说明PWD长度最长为128bit和第一点符合 ；若为0，则说明没有设置password。</strong></li></ul><h2 id="2、在哪里决定是否开启此功能？"><a href="#2、在哪里决定是否开启此功能？" class="headerlink" title="2、在哪里决定是否开启此功能？"></a>2、在哪里决定是否开启此功能？</h2><ul><li>EXT_CSD[171]——<code>USER_WP</code>的<code>bit7（PERM_PSWD_DIS）</code><br>0x0：允许password protect功能；<br>0x1：永久禁止password protect功能——ERASE（Forcing erase）、LOCK、UBLOCK、CLR_PWD、SET_PWD；</li></ul><h1 id="二、Setting-the-password"><a href="#二、Setting-the-password" class="headerlink" title="二、Setting the password"></a>二、Setting the password</h1><ul><li>1、CMD7（SELECT&#x2F;DESELECT_CARD）选定设备，进入Transfer State；</li><li>2、CMD16（SET_BLOCKLEN）定义block长度，长度由图1决定；</li><li>3、CMD42（LOCK_UNLOCK）发送图1中的内容，其中<code>SET_PWD</code>被置位，<code>PWD_LEN</code>应匹配新密码+旧密码的长度，<code>PWD</code>中会包含<code>新/旧密码</code>。</li></ul><blockquote><p><strong>LOCK_UNLOCK_FAILED error</strong>出现的几种情况：<br>1、<code>新/旧密码</code>长度超过16byte；<br>2、设置新密码时，PWD_LEN只设置为旧密码的长度；这时旧密码不会被更改；<br>3、旧密码不正确（seize和content不相等），这时旧密码不改变；<br>如果相符合，则给定的新密码和它的大小将分别保存在PWD和PWD_LEN字段给中。</p></blockquote><h1 id="三、Reset-the-password"><a href="#三、Reset-the-password" class="headerlink" title="三、Reset the password"></a>三、Reset the password</h1><ul><li>1、CMD7（SELECT&#x2F;DESELECT_CARD）选定设备，进入Transfer State；</li><li>2、CMD16（SET_BLOCKLEN）定义block长度，长度由图1决定；</li><li>3、CMD42（LOCK_UNLOCK）发送图1中的内容，其中<code>CLR_PWD</code>被置位，<code>PWD_LEN</code>和<code>PWD</code>应和当前密码长度和密码匹配。<br>3.1、若匹配<code>PWD_LEN ——&gt;0</code>，<code>PWD被清零</code>。<br>3.2、若不匹配，<strong>LOCK_UNLOCK_FAILED error</strong>被报告。</li></ul><h1 id="四、Locking-the-device"><a href="#四、Locking-the-device" class="headerlink" title="四、Locking the device"></a>四、Locking the device</h1><ul><li>1、CMD7（SELECT&#x2F;DESELECT_CARD）选定设备，进入Transfer State；</li><li>2、CMD16（SET_BLOCKLEN）定义block长度，长度由图1决定；</li><li>3、CMD42（LOCK_UNLOCK）发送图1中的内容，<code>LOCK_UNLOCK</code>设置为LOCK（&#x3D;1），PWD_LEN和PWD匹配。<br>3.1、若<code>匹配</code>，LOCK设备成功，<strong>Device-locked status bit</strong>会在状态寄存器中<strong>被标志</strong>；<br>3.2、若<code>不匹配</code>，LOCK_UNLOCK_FAILED error会在状态寄存器中被标志；</li></ul><blockquote><p>1、如果device设置了password，则上电复位后，device会被自动LOCK；<br>2、如果试图LOCK一个没有password的device，或device已经处于LOCK状态，则LOCK_UNLOCK_FAILED error会在状态寄存器中标志；</p></blockquote><h1 id="五、Unlocking-the-device"><a href="#五、Unlocking-the-device" class="headerlink" title="五、Unlocking the device"></a>五、Unlocking the device</h1><ul><li>1、CMD7（SELECT&#x2F;DESELECT_CARD）选定设备，进入Transfer State；</li><li>2、CMD16（SET_BLOCKLEN）定义block长度，长度由图1决定；</li><li>3、CMD42（LOCK_UNLOCK）发送图1中的内容，<code>LOCK_UNLOCK</code>设置为UNLOCK（&#x3D;0），PWD_LEN和PWD匹配。<br>若<code>匹配</code>，UNLOCK设备成功，<strong>Device-locked status bit</strong>会在状态寄存器中<strong>被清除</strong>；<br>若<code>不匹配</code>，LOCK_UNLOCK_FAILED error会在状态寄存器中标志；</li></ul><blockquote><p>1、Unlocking只在当前power下执行，因为上电后会自动LOCK（如果设置了LOCK）；<br>2、如果试图UNLOCK的device已经处于UNLOCK状态，则LOCK_UNLOCK_FAILED error会在状态寄存器中标志；</p></blockquote><h1 id="六、Forcing-ERASE"><a href="#六、Forcing-ERASE" class="headerlink" title="六、Forcing ERASE"></a>六、Forcing ERASE</h1><p>作用：当用户忘记password时，可将PWD和device data一起擦除，故称为<code>强制擦除</code>。</p><ul><li>1、CMD7（SELECT&#x2F;DESELECT_CARD）选定设备，进入Transfer State；</li><li>2、CMD16（SET_BLOCKLEN）定义block长度，<strong>长度为1byte（8bit）</strong>；</li><li>3、CMD42（LOCK_UNLOCK）发送图1中<strong>第一行</strong>的内容，设置ERASE操作；</li></ul><p>Forcing ERASE命令成功后，device所有内容（eMMC4.3之后，Boot、RPMB、GPP不会被擦除了）以及PWD、PWD_LEN都会被擦除，LOCK的device会被UNLOCK，<strong>即使CSD中设置了temporary-write-protect bit也会被擦除</strong>。</p><blockquote><p><strong>LOCK_UNLOCK_FAILED error</strong>出现的几种情况：<br>1、如果图1中，bit[3] ERASE不是唯一为1的bit；<br>2、如果发送Forcing ERASE命令时，decive 存在<code>power-on protected</code> or a <code>permanently-write-protected write protect groups</code>，则Forcing ERASE将会失败；<br>3、在一个Unlocked的device上发送Forcing ERASE命令；</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;h2 id=&quot;1、password存在哪个位置？&quot;&gt;&lt;a href=&quot;#1、password存在哪个位</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>31--eMMC中三种Information Security机制</title>
    <link href="https://mkdbook.com/blog031.html"/>
    <id>https://mkdbook.com/blog031.html</id>
    <published>2023-06-24T14:35:24.000Z</published>
    <updated>2023-06-24T14:59:54.226Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>“信息安全”有三个最基本的目标：</p><ul><li><code>Confidentiality</code>：<strong>机密性</strong>是指，信息只能被授权的用户阅读和理解。</li><li><code>Integrity</code>：<strong>完整性</strong>是指，能够确定信息受到保护，不被篡改、修改或删除的能力。<br>  Integrity of information covers its <code>origin</code>, <code>completeness</code>, and <code>correctness</code> using methods such as identification and authentication.</li><li><code>Availability</code>：<strong>可用性</strong>是指，信息总是可供已经授权的用户使用。</li></ul><p>例如：eMMC的write protect是为了确保data availability，replay protected memory block（RPMB）是为了确保data integrity和data confidentiality。</p><h1 id="二、eMMC-Information-Security的类型"><a href="#二、eMMC-Information-Security的类型" class="headerlink" title="二、eMMC Information Security的类型"></a>二、eMMC Information Security的类型</h1><h2 id="1、Password-Lock-x2F-Unlock"><a href="#1、Password-Lock-x2F-Unlock" class="headerlink" title="1、Password Lock&#x2F;Unlock"></a>1、Password Lock&#x2F;Unlock</h2><ul><li>Password lock&#x2F;Unlock是集成到eMMC协议中的第一个Security feature，该功能来源于传统的SD卡，<strong>可以保护user area的内容不被访问（read、write、erase）</strong>。</li><li>由CMD42（LOCK_UNLOCK）设置。</li><li>当启用password lock之后，host可以执行某些操作（如reset、initialize、select、query for status），但不能访问user area的任何数据。而且host依然可以访问boot分区、RPMB和GPP分区。</li><li>缺点：这种保护可用于防止数据被盗，但它也限制了任何人（包括数据所有者）可以对设备执行的操作，因为不允许访问（任何类型的）受保护的数据。</li></ul><h2 id="2、Write-Protect"><a href="#2、Write-Protect" class="headerlink" title="2、Write Protect"></a>2、Write Protect</h2><ul><li>作用：防止数据损坏或被擦除。</li><li>eMMC4.3之前，write protect只支持user area且整个设备要么是可写的要么是不可写的；<br>eMMC4.4之后，write protect可控制特定的分区被写入或只读；<br>eMMV5.1之后，write protect支持认证，即只有被授权的用户才能改变write protect设置；<br>（演变过程使得write更加灵活和安全。）</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/31.1.png" width="80%" height="80%" alt="31.1"/></center>    <ul><li>Write Protect与Password Lock&#x2F;Unlock区别：前者依然能够从device中读取数据。</li></ul><h2 id="2-1-eMMC-5-1中有4种类型的写保护："><a href="#2-1-eMMC-5-1中有4种类型的写保护：" class="headerlink" title="2.1  eMMC 5.1中有4种类型的写保护："></a>2.1  eMMC 5.1中有4种类型的写保护：</h2><ul><li><code>Permanent</code>：当启用了写保护，就不能改变了。</li><li><code>Power-on</code>：当启用了写保护，只能通过power cycle或通过device RESET pin来改变（会造成设备reboot）。</li><li><code>Temporary</code>：写保护可以启用，也可以取消。</li><li><code>Secured</code>：只有被授权使用RPMB的用户，才可以启用和禁用写保护。</li></ul><h2 id="2-2-eMMC-5-1整个设备都支持写保护"><a href="#2-2-eMMC-5-1整个设备都支持写保护" class="headerlink" title="2.2  eMMC 5.1整个设备都支持写保护"></a>2.2  eMMC 5.1整个设备都支持写保护</h2><ul><li><strong>The entire device</strong>：（包括了Boot Area Partitions, General Purpose Area Partition, RPMB， User&#x2F;Enhanced User Data Area Partition）可以通过CSD中相关bit设置<code>permanent</code>或<code>temporary</code>写保护。</li><li><strong>Boot partitions</strong>：可以设置<code>permanent</code>、<code>secured</code>、<code>power-on</code>写保护。</li><li><strong>UDA和GPP</strong>：可以设置<code>permanent</code>、<code>secured</code>、<code>power-on</code>、<code>temporary</code>写保护，为specific segment（即协议中说的“write protect group”）</li></ul><h2 id="2-3-Write-Protect两种分类"><a href="#2-3-Write-Protect两种分类" class="headerlink" title="2.3  Write Protect两种分类"></a>2.3  Write Protect两种分类</h2><h3 id="2-3-1-Entire-device写保护"><a href="#2-3-1-Entire-device写保护" class="headerlink" title="2.3.1  Entire device写保护"></a>2.3.1  Entire device写保护</h3><ul><li>包括Boot Area Partitions、General Purpose Area Partition、RPMB、User&#x2F;Enhanced User Data Area Partition；</li><li>相比其他保护机制，<code>优先级最高</code>；</li></ul><h3 id="2-3-2-Specific-segments写保护"><a href="#2-3-2-Specific-segments写保护" class="headerlink" title="2.3.2  Specific segments写保护"></a>2.3.2  Specific segments写保护</h3><ul><li>可以将特定的区段设置为<code>permanent</code>、<code>power-on</code>或<code>temporarily</code>写保护。</li><li>segment的长度由EXT_CSD[175]——<code>ERASE_GROUP_DEF</code>决定由哪一个参数决定：<br><code>0x0</code>：CSD[36:32]——<code>WP_GRP_SIZE</code>；（默认）<br><code>0x1</code>：EXT_CSD[221]——<code>HC_WP_GRP_SIZE</code>；使用High-capacity的写保护组大小。</li></ul><h3 id="2-3-3-WP-GRP-SIZE（旧的模式）"><a href="#2-3-3-WP-GRP-SIZE（旧的模式）" class="headerlink" title="2.3.3  WP_GRP_SIZE（旧的模式）"></a>2.3.3  WP_GRP_SIZE（旧的模式）</h3><ul><li>在CSD中，一共有<code>5bit</code>大小。</li><li>故一共可以表示<code>32</code>个erase group。</li></ul><h3 id="2-3-4-HC-WP-GRP-SIZE（高容量模式）"><a href="#2-3-4-HC-WP-GRP-SIZE（高容量模式）" class="headerlink" title="2.3.4  HC_WP_GRP_SIZE（高容量模式）"></a>2.3.4  HC_WP_GRP_SIZE（高容量模式）</h3><ul><li><strong>Write protect group size</strong> &#x3D; <code>512KB</code> * <code>HC_ERASE_GRP_SIZE</code> * <code>HC_WP_GRP_SIZE</code></li><li>注意<code>512KB</code> * <code>HC_ERASE_GRP_SIZE</code>代表的是<strong>Erase-unit size</strong>，最大为<code>512Kbyte * 255</code>。</li><li><code>HC_WP_GRP_SIZE</code>最多表示可以255个<strong>Erase-unit size</strong>，如果为0则表示不支持high-capacity write protect group seize。（详见协议p193）</li></ul><h2 id="3、RPMB（Replay-Protect-Memory-Block）"><a href="#3、RPMB（Replay-Protect-Memory-Block）" class="headerlink" title="3、RPMB（Replay Protect Memory Block）"></a>3、RPMB（Replay Protect Memory Block）</h2><ul><li>此功能首次出现在eMMC4.4，使设备能够在一个小的、特定的区域内存储数据，该区域经过验证并受到保护，以防止重放攻击（replay attack）。</li><li>一些使用RPMB的例子如下：<br>1、software version authentication；<br>2、fingerprint verification；<br>3、secure key storage；<br>4、network vendor information；<br>5、digital rights management（DRM）；<br>6、secure payments；</li></ul><h3 id="3-1-什么是Replay-Attack？"><a href="#3-1-什么是Replay-Attack？" class="headerlink" title="3.1  什么是Replay Attack？"></a>3.1  什么是Replay Attack？</h3><p>重放攻击是一种攻击类型，在这种攻击中，攻击者捕获在两方之间发送的数据，然后在稍后的时间重新发送该数据。</p><p> 这种攻击的目的是：获得对系统的未授权访问或修改先前发送的数据。<br>例如，攻击者可以捕获在用户和服务器之间发送的登录请求。 然后攻击者可以在稍后重播该请求，这将允许他们以用户身份登录到服务器。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/31.2.png" width="70%" height="70%" alt="31.2"/></center>如图31.2所示，关于重放攻击的例子，设想一个数字钱包服务提供商发送一个经过验证的信息，将用户账户余额设置为2000美元。当用户用数字钱包支付1600美元的账单时，可用余额下降到400美元。如果一个运行重放攻击的恶意软件拦截了最初的信息（将账户余额设置为2000美元的信息），在购买1600美元后重新发送相同的信息，就可以将账户余额重置为2000美元。<h3 id="3-2-Replay-Protect的常见机制？"><a href="#3-2-Replay-Protect的常见机制？" class="headerlink" title="3.2  Replay Protect的常见机制？"></a>3.2  Replay Protect的常见机制？</h3><ul><li><code>One-time passwords</code>（OTP）：一次性口令，唯一性。</li><li><code>Timestamps</code>：使得信息传输命令只在一个很短的时间内有效。</li><li><code>Nonce</code>（number used once）：使用一次的随机数字。</li><li><code>Sequence numbers</code>：每个数据传输或请求都被分配一个唯一的序列号。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;“信息安全”有三个最基本的目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Confidentiali</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>30--eMMC的Data Read</title>
    <link href="https://mkdbook.com/blog030.html"/>
    <id>https://mkdbook.com/blog030.html</id>
    <published>2023-06-24T14:25:24.000Z</published>
    <updated>2023-06-24T14:32:20.437Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>传输模式模式有两种：</p><ul><li><code>SDR</code>：每条数据线上有1个CRC，在时钟的上升沿采样</li><li><code>DDR</code>：双沿采样，数据以4-bit或8-bit位宽模式传输。block数据块<code>固定为512 byte</code>，每条数据线上有2个CRC，第一个CRC校验第奇数个byte（共256），第二个CRC校验第奇数个byte（共256）</li></ul><h2 id="1-1-SDR模式下，block大小定义"><a href="#1-1-SDR模式下，block大小定义" class="headerlink" title="1.1  SDR模式下，block大小定义"></a>1.1  SDR模式下，block大小定义</h2><p>在单块传输过程中，数据传输的基本单位是block，它的<strong>最大长度</strong>在<code>CSD[83:80]READ_BL_LEN</code>中定义，它表示数据块大小的方法为<code>2 的 READ_BL_LEN 次方</code> 。完成传输后返回<em><strong>Trasnfer</strong></em>状态。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/30.1.png" width="75%" height="75%" alt="30.1"/></center><p><strong>如果<code>CSD[79]READ_BL_PARTIAL</code>为1，也可以读取比定义的block更小的block（partial block read）。</strong></p><h3 id="1-1-1-READ-BL-PARTIAL-描述"><a href="#1-1-1-READ-BL-PARTIAL-描述" class="headerlink" title="1.1.1 READ_BL_PARTIAL 描述"></a>1.1.1 READ_BL_PARTIAL 描述</h3><p>READ_BL_PARTIAL 定义了partial block size是否可以用于块读命令</p><ol><li>最大2GB容量时（byte访问模式）<ul><li>0：只允许512B和READ_BL_LEN定义的block长度，用于block read</li><li>1：可以使用更小的块，最小为<code>最小可寻址的单位</code>（1byte）</li></ul></li><li>大于2GB容量时（sector 访问模式）<ul><li>0：只允许512B和READ_BL_LEN</li><li>1：可以更小，最小512B</li></ul></li></ol><h2 id="1-2-DDR，固定512B，不支持部分块读"><a href="#1-2-DDR，固定512B，不支持部分块读" class="headerlink" title="1.2 DDR，固定512B，不支持部分块读"></a>1.2 DDR，固定512B，不支持部分块读</h2><h1 id="二、Single-block-read"><a href="#二、Single-block-read" class="headerlink" title="二、Single block read"></a>二、Single block read</h1><p><code>CMD7（SELECT/DESELECT_CARD）</code>选定一个设备用于数据读操作，再用<code>CMD16（SET_BLOCKLEN）</code>设定有效快长度，发送<code>CMD17（READ_SINGLE_ BLOCK）</code>开始读数据。（CMD17的参数位为地址）</p><ul><li>单块读时序图</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/30.2.png" width="75%" height="75%" alt="30.2"/></center>    <h1 id="三、Multiple-block-read"><a href="#三、Multiple-block-read" class="headerlink" title="三、Multiple block read"></a>三、Multiple block read</h1><p>有两种多块读的类型。</p><h2 id="3-1-Open-ended-Multiple-block-read"><a href="#3-1-Open-ended-Multiple-block-read" class="headerlink" title="3.1  Open-ended Multiple block read"></a>3.1  Open-ended Multiple block read</h2><p>读取的块数不指定，直到收到停止传输命令<code>CMD12（STOP_TRANSMISION）</code>。</p><h2 id="3-2-Multiple-block-read-with-pre-defined-count"><a href="#3-2-Multiple-block-read-with-pre-defined-count" class="headerlink" title="3.2  Multiple block read with pre-defined count"></a>3.2  Multiple block read with pre-defined count</h2><p>定义块数，完成传输后返回<em><strong>Transfer</strong></em>状态。</p><p>启动方法为，host使用<code>CMD23（SET_BLOCK_COUNT）</code>后紧跟<code>CMD18（READ_MULTIPLE_BLOCK）</code>，否则设备默认开始Open-ended 多块读。</p><ul><li>Figure 43为多块读时序，Figure 44为收到CMD12的应答</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/30.3.png" width="75%" height="75%" alt="30.3"/></center>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;传输模式模式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SDR&lt;/code&gt;：每条数据线上有1</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>29--eMMC的Data Write</title>
    <link href="https://mkdbook.com/blog029.html"/>
    <id>https://mkdbook.com/blog029.html</id>
    <published>2023-06-24T06:31:24.000Z</published>
    <updated>2023-06-24T14:17:50.555Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、Data-Write"><a href="#一、Data-Write" class="headerlink" title="一、Data Write"></a>一、Data Write</h1><p>写操作的数据传输都带有CRC（SDR带一个，DDR带两个）。在写操作执行之前，设备会对每个接收到的data block进行CRC检查，防止错误数据的写入。</p><h2 id="1-1-数据可靠性设置，WR-REL-SET"><a href="#1-1-数据可靠性设置，WR-REL-SET" class="headerlink" title="1.1  数据可靠性设置，WR_REL_SET"></a>1.1  数据可靠性设置，WR_REL_SET</h2><p>写操作进行过程中被打断，通常不会影响其他地址上已有数据的丢失，所以会在<code>保护已有数据</code>和<code>写性能</code>之间做一个折中。如何折中，host 可以决定，在<code>EXT_CSD[167]的WR_REL_SET</code>定义。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/29.1.png" width="75%" height="75%" alt="29.1"/></center><blockquote><p>如上图所示，当相关的bit位<code>为1</code>：如果写数据的时候发生掉电，设备<strong>会保护先前写入的数据</strong>；<code>为0</code>：写操作执行<strong>性能优化</strong>，掉电后该分区<strong>已有的数据可能有风险</strong>。<br>注：<code>HS_CTRL_REL</code>是<code>EXT_CSD[166]的WR_REL_PARAM</code>中的bit[0]，此位置决定了上述参数是否可以修改（一般全为1）</p></blockquote><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/29.2.png" width="75%" height="75%" alt="29.2"/></center><p>上述<code>WR_REL_SET</code>的设置只影响两个分区<code>main user area</code>和<code>general purpose partion</code>。<strong>boot分区</strong>和<strong>RPMB分区</strong>是默认会保护先前数据的，不受该设置影响。</p><p>host可以通过改变该寄存器的bit（不能单独只改某一个，必须全部作为一个数据写入）选择改变上述分区的write reliability，这个过程必须发生在<code>PARTITION_SETTING_COMPLETED</code>之前。</p><p><code>WR_REL_SET</code>在分区设置之后才有效，且参数中的分区如果不存在不会影响设备。</p><h1 id="二、Block-Write"><a href="#二、Block-Write" class="headerlink" title="二、Block Write"></a>二、Block Write</h1><p><code>SDR模式</code>：数据块由<code>WRITE_BL_LEN</code> 定义。如果CRC失败，则device在DAT0上表示失败，所有的数据都被抛弃，多块写模式接下来的步骤也会被忽略。</p><p><code>DDR模式</code>：数据块为<code>512 Byte</code>。每一个数据块有2个CRC，一个对偶字节校验，一个对奇字节校验。</p><blockquote><p><code>WRITE_BL_LEN</code> 是CRC[25:22]，共4个bit，值为0-15；它表示数据块大小的方法为<code>2 的 WRITE_BL_LEN 次方</code></p></blockquote><h2 id="2-1-多块写介绍"><a href="#2-1-多块写介绍" class="headerlink" title="2.1  多块写介绍"></a>2.1  多块写介绍</h2><p><code>CMD25（WRITE_MULTIPLE_BLOCK）</code>开始几个连续的block传输。定义了3种类型的multiple-block write transactions：</p><h3 id="2-1-1-Open-ended-Multiple-block-write"><a href="#2-1-1-Open-ended-Multiple-block-write" class="headerlink" title="2.1.1  Open-ended Multiple-block write"></a>2.1.1  Open-ended Multiple-block write</h3><p><strong>没有定义</strong>多块写的write block<strong>数目</strong>，device将连续地接受和编写数据块，直到收到停止传输命令<code>CMD12（STOP_TRANSMISSION）</code>。</p><h3 id="2-1-2-Multiple-block-write-with-pre-defined-block-count"><a href="#2-1-2-Multiple-block-write-with-pre-defined-block-count" class="headerlink" title="2.1.2  Multiple-block write with pre-defined block count"></a>2.1.2  Multiple-block write with pre-defined block count</h3><p>device将接收预定义的数据块数，终止传输并返回<em><strong>tansfer</strong></em>状态。这种模式下不需要停止命令。<br>启动方法为<code>CMD23（SET_BLOCK_COUNT）</code>后立即发送<code>CMD25（WRITE_MULTIPLE_BLOCK）</code> 。</p><h3 id="2-1-3-Reliable-write"><a href="#2-1-3-Reliable-write" class="headerlink" title="2.1.3  Reliable write"></a>2.1.3  Reliable write</h3><p>有<code>可靠写参数</code>和<code>pre-defined block count</code>，类似于2.12的模式，附加了如下条件：<br><strong>当数据成功写入之前，逻辑地址指向的旧数据必须保持不变，这样即使在编程过程中突然断电，数据也不会出现undefined。</strong></p><ul><li>1、数据传输以<code>512B sectors大小的倍数</code>传输，或<strong>Large Sector</strong>模式被启用下以<code>8*512B Sectors大小的倍数</code>传输。<code>CMD16（SET_BLOCKLEN）</code>定义的<code>WRITE_BL_LEN</code>被忽略。</li><li>2、启用方法：<code>CMD23（SET_BLOCK_COUNT）</code>的<code>bit[31]</code>设置为<code>1</code>。</li><li>3、必须sector aligned，否则CMD23的Rb响应中bit[19]——ERROR位会置1（<em>详见5.1协议 p139. Table68</em>）</li><li>4、若发生断电，会有三种情况：所有扇区都是<strong>新数据</strong>，所有扇区都是<strong>旧数据</strong>，或有些扇区是<strong>新数据</strong>而其余扇区容纳着<strong>旧数据</strong>。</li><li>5、 Reliable write被高优先级命令（CMD12、CMD13）打断后，<code>寄存器</code>中标记为completed的扇区为新数据，其余扇区为旧数据。</li><li>6、<code>REL_WR_SEC_C[222]</code> 寄存器应设置为 1 且对Reliable write操作无影响</li></ul><h2 id="2-2-单块写时序"><a href="#2-2-单块写时序" class="headerlink" title="2.2  单块写时序"></a>2.2  单块写时序</h2><p>数据写操作前，通过<code>CMD7（SELECT/DESELECT_CARD）</code>选定一个设备，再用<code>CMD16（SET_BLOCKLEN）</code>设定有效块长度，发送<code>CMD24（WRITE_BLOCK）</code>开始写数据。（CMD24的参数位为地址）</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/29.3.png" width="80%" height="80%" alt="29.3"/></center><p>单块写时序如图所示，当host发送完CMD，device应答后，再Nwr时钟周期，host开始传输数据。<br>Ncrc是为HS200和HS400设置的参数。<br>之后device会在<code>DAT0</code>上返回CRC的校验结果，（<code>101：有错</code>；<code>010：正确，然后开始编程</code>）。<br>当设备正在program时，<strong>DAT0会拉低表示busy</strong>，完成后拉高。</p><h2 id="2-3-多块写时序"><a href="#2-3-多块写时序" class="headerlink" title="2.3  多块写时序"></a>2.3  多块写时序</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/29.4.png" width="85%" height="85%" alt="29.4"/></center><p>如果 Host 发送的是 Multiple Block Write Command，那么 eMMC Device 会持续地将接收到的数据写入到存储器中，直到 Host 主动发送 Stop Command（CMD12）。</p><p>eMMC Device 在接收到一个 Block 的数据后，会进行 CRC 校验，然后将校验结果通过 CRC Token 发送给 Host。</p><p>发送完 CRC Token 后，如果 CRC 校验成功，eMMC Device 会将数据写入到内部存储器时，此时 DAT0 信号会拉低，作为 Busy 信号。Host 会持续检测 DAT0 信号，直到为高电平时，才会接着发送下一个 Block 的数据。如果 CRC 校验失败，那么 eMMC Device 不会进行数据写入，此次传输后续的数据都会被忽略。</p><p>NOTE:向 eMMC Device 写数据都是按 Block 写入的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、Data-Write&quot;&gt;&lt;a href=&quot;#一、Data-Write&quot; class=&quot;headerlink&quot; title=&quot;一、Data Write&quot;&gt;&lt;/a&gt;一、Data Write&lt;/h1&gt;&lt;p&gt;写操作的数据传输都带有CRC（SD</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>28--eMMC的Bus Speed Modes</title>
    <link href="https://mkdbook.com/blog028.html"/>
    <id>https://mkdbook.com/blog028.html</id>
    <published>2023-06-24T05:49:24.000Z</published>
    <updated>2023-06-24T06:29:31.770Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、Bus-Speed-mode介绍（eMMC-5-1）"><a href="#一、Bus-Speed-mode介绍（eMMC-5-1）" class="headerlink" title="一、Bus Speed mode介绍（eMMC 5.1）"></a>一、Bus Speed mode介绍（eMMC 5.1）</h1><h2 id="1-1-eMMC-Bus，标准接口"><a href="#1-1-eMMC-Bus，标准接口" class="headerlink" title="1.1  eMMC Bus，标准接口"></a>1.1  eMMC Bus，标准接口</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.1.png" width="60%" height="60%" alt="28.1"/></center><p>如图28.1所示，eMMC总线共有<code>11根信号线</code>，用于Host端和eMMC device端通信。</p><ul><li><code>CLK</code>：<em><strong>单向，host——&gt;eMMC</strong></em>；时钟频率范围为0-200MHz。</li><li><code>Data Strobe</code>：<em><strong>单向，host&lt;——eMMC</strong></em>；频率和CLK相同，用于host端在HS400模式下进行数据同步，<strong>省去总线tuning过程</strong>。</li><li><code>CMD</code>：<em><strong>双向，host&lt;——&gt;eMMC</strong></em>；命令和响应走这条线。</li><li><code>DAT0-7</code>：<em><strong>双向</strong></em>，有三种bus width模式，1bit，4bit，8bit；power-on默认为1bit模式（DAT0）。</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.2.png" width="60%" height="60%" alt="28.2"/></center><p>还有一些重要的功能线：</p><ul><li><code>RST</code>：硬件复位。</li><li><code>Vcc</code>：为flash memory供电，和falsh memory与eMMC core的接口I&#x2F;O提供电压。</li><li><code>Vccq</code>：为host接口<strong>I&#x2F;O</strong>提供电压，为<strong>core</strong>提供电压。</li></ul><blockquote><p>注：Vccq一定小于或等于Vcc。</p></blockquote><ul><li><code>Vss，Vssq</code>：<strong>Ground</strong> for supply voltage core and I&#x2F;O</li></ul><h2 id="1-2-Bus-Speed模式"><a href="#1-2-Bus-Speed模式" class="headerlink" title="1.2  Bus Speed模式"></a>1.2  Bus Speed模式</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.3.png" width="70%" height="70%" alt="28.3"/></center><p>可以看到，<code>High speed</code>模式有两种（SDR和DDR）。<code>HS200</code>最大频率达到了200MHz，<code>HS400</code>是前者的两倍。</p><p>为了兼容旧版本的eMMC，在power-on或reset后，会默认进入兼容模式（Backward Compatible Mode）。</p><p>可以通过EXT_CSD[185]——<code>HS_TIMING</code>配置Bus speed模式，<br>                EXT_CSD[183]——<code>BUS_WIDTH</code>配置Bus width和Data Strobe。</p><h2 id="1-3-HS-TIMING-185"><a href="#1-3-HS-TIMING-185" class="headerlink" title="1.3  HS_TIMING[185]"></a>1.3  HS_TIMING[185]</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.4.png" width="90%" height="90%" alt="28.4"/></center><p><strong>bit[3:0]用于设置接口时序：</strong></p><ul><li>0x0：选择backwards compatibility interface timing</li><li>0x1：选择High Speed</li><li>0x2：选择HS200</li><li>0x3：选择HS400</li></ul><h2 id="1-4-BUS-WIDTH-183"><a href="#1-4-BUS-WIDTH-183" class="headerlink" title="1.4  BUS_WIDTH[183]"></a>1.4  BUS_WIDTH[183]</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.5.png" width="90%" height="90%" alt="28.5"/></center><p>HS400是否支持Enhanced Strobe模式，在EXT_CSD[184]——<code>STROBE_SUPPORT</code>中定义，0x1&#x3D;支持，0x0&#x3D;不支持。</p><p><strong>bit[3:0]用于设置总线的宽度：</strong></p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.6.png" width="85%" height="85%" alt="28.6"/></center><h1 id="二、选择high-speed-mode"><a href="#二、选择high-speed-mode" class="headerlink" title="二、选择high-speed mode"></a>二、选择high-speed mode</h1><p>见协议附录A.6.2，在eMMC设备BUS初始化完成后，通过如下步骤切换BUS mode为high-speed mode。参考Data transfer diagram。</p><ul><li>发送CMD7（带RCA）将设备切换到tran-state。</li><li>发送CMD8（SEND_EXT_CSD）。</li><li>发送<code>CMD6（SWITCH）</code>修改<code>HS_TIMING</code>。参数为<code>0x03B9_0100</code>即可。</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.7.png" width="75%" height="75%" alt="28.7"/></center>    <ul><li>修改clock frequency为high-speed mode支持的范围（0-52MHz）。</li></ul><h1 id="三、选择”HS200“-mode"><a href="#三、选择”HS200“-mode" class="headerlink" title="三、选择”HS200“ mode"></a>三、选择”HS200“ mode</h1><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.8.png" width="70%" height="70%" alt="28.8"/></center><h1 id="四、选择“HS400”-mode"><a href="#四、选择“HS400”-mode" class="headerlink" title="四、选择“HS400” mode"></a>四、选择“HS400” mode</h1><p>HS400有两种模式，tuning模式和Enhanced Strobe，它们的启动流程分别如下：</p><h2 id="4-1-需要Tuning-procedure的HS400"><a href="#4-1-需要Tuning-procedure的HS400" class="headerlink" title="4.1  需要Tuning procedure的HS400"></a>4.1  需要Tuning procedure的HS400</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.9.png" width="65%" height="65%" alt="28.9"/></center><ul><li>1、初始化设备后进入的是”Backward Compatible Timings“，这时发送<code>CMD7</code>选择设备，再读取<code>DEVICE_TYPE [196]</code>判断是否支持HS400；</li><li>2、读取<code>DRIVER_STRENGTH [197]</code>判断支持的device Driver Strengths，再通过修改<code>HS_TIMING[185]</code>设置HS400的<em><strong>device Driver Strength</strong></em>，并通过<code>0x2</code>将其切换为<em><strong>HS200</strong></em>；</li><li>3、要切换为<code>HS200</code>进行<code>tuning</code> procedure。（<em>因为HS200相对低速，在此模式下进行tuning不容易出错</em>）</li><li>4、再切换为<code>High-speed</code>模式，修改BUS_WIDTH[183]&#x3D;0x06，选择“<code>x8 DDR</code>”bus mode；（<em><strong>为什么？见1.4中规定了</strong></em>）</li><li>5、最后再修改<code>HS_TIMING[185]=0x3</code>，切换成<code>HS400</code>。</li></ul><h2 id="4-2-Enhanced-Strobe模式的HS400"><a href="#4-2-Enhanced-Strobe模式的HS400" class="headerlink" title="4.2  Enhanced Strobe模式的HS400"></a>4.2  Enhanced Strobe模式的HS400</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.10.png" width="75%" height="75%" alt="28.10"/></center><p>当使能了Enhanced Strobed就不需要tuning过程了。</p><ul><li>1、初始化设备后进入的是”Backward Compatible Timings“，这时发送<code>CMD7</code>选择设备，再读取<code>DEVICE_TYPE [196]</code>判断是否支持HS400；</li><li>2、读取STROBE_SUPPORT[184]判断是否支持Enhanced Strobe；</li><li>3、切换为<code>High-speed</code>模式（HS_TIMING&#x3D;0x1），频率低于52MHz；修改<code>BUS_WIDTH[183]=0x86</code>，选择“<code>x8 DDR</code>”bus mode；（***这里的0x86是整个BUS_WIDTH byte的值，4.1中第4点0x06是指bit[3:0]***）</li><li>4、最后再修改<code>HS_TIMING[185]=0x3</code>，切换成<code>HS400</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、Bus-Speed-mode介绍（eMMC-5-1）&quot;&gt;&lt;a href=&quot;#一、Bus-Speed-mode介绍（eMMC-5-1）&quot; class=&quot;headerlink&quot; title=&quot;一、Bus Speed mode介绍（eMMC</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>27--eMMC的EXT_CSD和CMD6（SWITCH）</title>
    <link href="https://mkdbook.com/blog027.html"/>
    <id>https://mkdbook.com/blog027.html</id>
    <published>2023-06-24T05:31:24.000Z</published>
    <updated>2023-06-24T05:41:15.919Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、EXT-CSD-整体概述"><a href="#一、EXT-CSD-整体概述" class="headerlink" title="一、EXT_CSD 整体概述"></a>一、EXT_CSD 整体概述</h1><ul><li>EXT_CSD寄存器中定义了<code>设备的属性</code>和<code>模式选择</code>，一共有512个byte。</li><li>320 byte的<code>property segment</code>，192 byte的<code>mode segment</code>。</li><li>属性段<strong>不可</strong>被host端<strong>修改</strong>，里面包括了device支持的mode、容量等信息。</li><li><strong>模式段可</strong>被host段修改，反映了device当前选定的模式，例如选择哪个command set版本。</li><li>host通过发送CMD8（SEND_EXT_CSD）读取EXT_CSD，device会将其EXT_CSD作为一个512byte大小的数据块发送。</li></ul><h1 id="二、CMD6-详细说明"><a href="#二、CMD6-详细说明" class="headerlink" title="二、CMD6 详细说明"></a>二、CMD6 详细说明</h1><p>CMD6（SWITCH）两种功能：1、<code>切换mode</code>；2、<code>修改EXT_CSD</code>； </p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/27.1.png" width="100%" height="75%" alt="27.1"/></center><h2 id="2-1-Cmd-Set-2-0"><a href="#2-1-Cmd-Set-2-0" class="headerlink" title="2.1  Cmd Set[2:0]"></a>2.1  Cmd Set[2:0]</h2><p>host可以发送CMD6改变现在的命令集，在EXT_CSD中有两个byte表征它：<code>S_CMD_SET[504]</code>和<code>CMD_SET[191]</code>。</p><p>前者在属性段中，表示该device支持的command set。后者在模式段中，host可以通过CMD6命令修改。</p><p><code>CMD_SET[191]</code>中<code>Cmd Set[2:0]</code>power_on后默认为0x00，表示standard MMC。</p><p>然而，如果是通过CMD6将command set版本修改为standard MMC，则<code>CMD_SET[191]</code>中<code>Cmd Set[2:0]</code>应设置为0x01。</p><h2 id="2-2-Index-23-16"><a href="#2-2-Index-23-16" class="headerlink" title="2.2  Index[23:16]"></a>2.2  Index[23:16]</h2><p>索引虽然可以包含0-255数值，但是<code>只有0-191有效</code>，因为EXT_CSD只有192个byte（mode段）可被修改。</p><h2 id="2-3-Access-25-24"><a href="#2-3-Access-25-24" class="headerlink" title="2.3  Access[25:24]"></a>2.3  Access[25:24]</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/27.2.png" width="100%" height="75%" alt="27.2"/></center><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4  总结"></a>2.4  总结</h2><ul><li>1、如果CMD6用于更改命令集，<code>[23:16]Index</code>和<code>[15:8]Value</code>会被忽略，EXT_CSD不会被写。<code>[25:24]Access</code>为00，根据<code>[2:0]Cmd Set</code>修改命令集。</li><li>2、如果CMD用于写EXT_CSD，<code>[2:0]Cmd Set</code>会被忽略，命令集保持不变。根据<code>[25:24]Access</code>中的访问模式，将<code>[15:8]Value</code>中的值，修改到<code>[23:16]Index</code>指向的EXT_CSD byte中。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、EXT-CSD-整体概述&quot;&gt;&lt;a href=&quot;#一、EXT-CSD-整体概述&quot; class=&quot;headerlink&quot; title=&quot;一、EXT_CSD 整体概述&quot;&gt;&lt;/a&gt;一、EXT_CSD 整体概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;EXT</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>26--eMMC的Data transfer mode</title>
    <link href="https://mkdbook.com/blog026.html"/>
    <id>https://mkdbook.com/blog026.html</id>
    <published>2023-06-24T05:17:24.000Z</published>
    <updated>2023-06-24T05:29:31.078Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>device identification之后，<code>CMD3</code>生效，device进入<code>Stand-by State</code>。Data transfer mode下，device总共有8种状态，每种状态下涉及的相关命令如下。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/26.1.png" width="100%" height="75%" alt="25.1"/></center><h1 id="一、Sleep-状态"><a href="#一、Sleep-状态" class="headerlink" title="一、Sleep 状态"></a>一、Sleep 状态</h1><ul><li>CMD5：<code>SLEEP_AWAKE</code>  切换sleep和awake模式</li></ul><h1 id="二、Stand-by-状态"><a href="#二、Stand-by-状态" class="headerlink" title="二、Stand-by 状态"></a>二、Stand-by 状态</h1><ul><li><p>1、CMD4：<code>SET_DSR</code>  编程DSR寄存器，使其与应用中的bus length和data transfer frequency相对应。</p></li><li><p>2、CMD9：<code>SEND_CSD</code>  被寻址的设备在CMD线上发送其CSD寄存器内容。如block长度，设备存储容量、最大时钟速率等。</p></li><li><p>3、CMD10：<code>SEND_CID</code>  被寻址的设备在CMD线上发送其CID寄存器内容。</p></li><li><p>4、CMD39：<code>FAST_IO</code></p></li><li><p>5、CMD5：<code>SLEEP_AWAKE</code>  切换sleep和awake模式</p></li><li><p>6、CMD40：<code>GO_IRQ_STATE</code>  进入interrupt模式</p></li><li><p>7、CMD7：<code>SELECT/DESELECT_CARD</code>  切换 <em><strong>Stand-By状态——&gt;Transfer状态</strong></em>；</p></li></ul><h1 id="三、Transfer-状态"><a href="#三、Transfer-状态" class="headerlink" title="三、Transfer 状态"></a>三、Transfer 状态</h1><h2 id="1-读取一些数据-Transfer-State——-gt-Sending-data-State"><a href="#1-读取一些数据-Transfer-State——-gt-Sending-data-State" class="headerlink" title="1  读取一些数据  Transfer State——&gt;Sending-data State"></a>1  读取一些数据  Transfer State——&gt;Sending-data State</h2><ul><li>1、CMD8：<code>SEND_EXT_CSD</code>  设备将其EXT_CSD作为一个数据块发送</li><li>2、<strong>CMD17</strong>：<code>READ_SINGLE_ BLOCK</code></li><li>3、<strong>CMD18</strong>：<code>READ_MULTIPLE_ BLOCK</code></li><li>4、<strong>CMD21</strong>：<code>SEND_TUNING_ BLOCK</code>  为优化 HS200 采样点发送 128 时钟的tuning pattern （4-bit 下 64 字节，8-bit 下128 字节）</li><li>5、<strong>CMD30</strong>：<code>SEND_WRITE_PROT</code>  send write protect</li><li>6、CMD31：<code>SEND_WRITE_PROT _TYPE</code>  写保护相关</li><li>7、CMD46：<code>EXECUTE_READ_TASK</code>  设备应该执行队列中的这些task，它们的ID在参数中已经被编码了</li><li>8、CMD53：<code>PROTOCOL_RD</code></li><li>9、CMD56：<code>GEN_CMD（r）</code></li><li><strong>CMD12</strong>：<code>STOP_TRANSMISSION</code>  ，所有的data read命令都能在任何时刻被CMD12打断，data transfer被终止，设备返回Transfer状态。data read命令包括：CMD17、18、21、30</li></ul><h2 id="2-设置读、写、擦除的一些参数-Transfer-State——-gt-Transfer-State"><a href="#2-设置读、写、擦除的一些参数-Transfer-State——-gt-Transfer-State" class="headerlink" title="2  设置读、写、擦除的一些参数  Transfer State——&gt;Transfer State"></a>2  设置读、写、擦除的一些参数  Transfer State——&gt;Transfer State</h2><ul><li>1、CMD16：SET_BLOCKLEN</li><li>2、CMD23：SET_BLOCK_COUNT</li><li>3、CMD35：ERASE_GROUP_START</li><li>4、CMD36：ERASE_GROUP_END</li><li>5、CMD44：QUEUED_TASK_PARAMS</li><li>6、CMD45：QUEUED_TASK_ADDRESS</li></ul><h2 id="3-写一些数据-Transfer-State——-gt-Receive-data-State"><a href="#3-写一些数据-Transfer-State——-gt-Receive-data-State" class="headerlink" title="3  写一些数据  Transfer State——&gt;Receive-data State"></a>3  写一些数据  Transfer State——&gt;Receive-data State</h2><ul><li>1、<strong>CMD24</strong>：WRITE_BLOCK</li><li>2、<strong>CMD25</strong>：WRITE_MULTIPLE_ BLOCK</li><li>3、<strong>CMD26</strong>：PROGRAM_CID</li><li>4、<strong>CMD27</strong>：PROGRAM_CSD</li><li>5、CMD42： LOCK_UNLOCK</li><li>6、CMD47：EXECUTE_WRITE _TASK</li><li>7、CMD49：SET_TIME</li><li>8、CMD54：PROTOCOL_WR</li><li>9、CMD56：<code>GEN_CMD（w）</code></li><li><strong>CMD12</strong>：<code>STOP_TRANSMISSION</code>  ，所有的data write命令都能在任何时刻被CMD12打断，但data write命令必须在CMD7（取消设备选定）之前停止。data write命令包括：CMD24、25、26、27</li></ul><h2 id="4-Transfer-State——-gt-Programming-State"><a href="#4-Transfer-State——-gt-Programming-State" class="headerlink" title="4  Transfer State——&gt;Programming State"></a>4  Transfer State——&gt;Programming State</h2><ul><li>1、CMD6：<code>SWITCH</code>  切换所选设备的工作模式或都带EXT_CSD。</li><li>2、CMD28：<code>SET_WRITE_PROT</code></li><li>3、CMD29：<code>CLR_WRITE_PROT</code>  clear write protect</li><li>4、CMD38：<code>ERASE</code></li><li>5、CMD48：<code>CMDQ_TASK_MGMT</code></li></ul><h2 id="5-Transfer-State——-gt-Bus-test-State"><a href="#5-Transfer-State——-gt-Bus-test-State" class="headerlink" title="5  Transfer State——&gt;Bus-test State"></a>5  Transfer State——&gt;Bus-test State</h2><ul><li>CMD19：<code>BUSTEST_W</code>  host向设备发送the bus test data pattern</li></ul><h2 id="6-Transfer-State——-gt-Stand-by-State"><a href="#6-Transfer-State——-gt-Stand-by-State" class="headerlink" title="6  Transfer State——&gt;Stand-by State"></a>6  Transfer State——&gt;Stand-by State</h2><ul><li>CMD7：<code>SELECT/DESELECT_CARD</code>  切换 <em><strong>Stand-By状态&lt;——Transfer状态</strong></em>；</li></ul><h1 id="四、Programming-状态"><a href="#四、Programming-状态" class="headerlink" title="四、Programming 状态"></a>四、Programming 状态</h1><ul><li>1、操作完成后返回Transfer State</li><li>2、CMD24、CMD25进入Receive-data State</li><li>3、一些命令可以中断program：CMD12、13，CMD44、45</li><li>4、CMD7：<code>SELECT/DESELECT_CARD</code>  切 换 <em><strong>Disconnect状态&lt;——Programming状态</strong></em>；</li></ul><h1 id="五、Sending-data-状态"><a href="#五、Sending-data-状态" class="headerlink" title="五、Sending-data 状态"></a>五、Sending-data 状态</h1><ul><li>1、CMD12，或操作完成后返回Transfer State</li><li>2、接收CMD44、45</li></ul><h1 id="六、Receive-data-状态"><a href="#六、Receive-data-状态" class="headerlink" title="六、Receive-data 状态"></a>六、Receive-data 状态</h1><ul><li>1、CMD12，或传输完成后返回Transfer State</li><li>2、接收CMD44、45</li></ul><h1 id="七、Bus-test-状态"><a href="#七、Bus-test-状态" class="headerlink" title="七、Bus-test 状态"></a>七、Bus-test 状态</h1><ul><li>CMD14：<code>BUSTEST_R</code>  host从设备中读取the reversed bus testing data pattern</li></ul><h1 id="八、Disconnect-状态"><a href="#八、Disconnect-状态" class="headerlink" title="八、Disconnect 状态"></a>八、Disconnect 状态</h1><ul><li>1、操作完成后返回Stand-by State</li><li>2、CMD7：<code>SELECT/DESELECT_CARD</code>  切换 <em><strong>Disconnect状态——&gt;Programming状态</strong></em>；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;device identification之后，&lt;code&gt;CMD3&lt;/code&gt;生效，device进入&lt;code&gt;Stand-by State&lt;/code&gt;。Data transfer mode下，device总共有8种状态，每种状态下涉及的相关</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>25--eMMC的Device identification mode</title>
    <link href="https://mkdbook.com/blog025.html"/>
    <id>https://mkdbook.com/blog025.html</id>
    <published>2023-06-24T04:56:04.000Z</published>
    <updated>2023-06-24T05:16:11.650Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、进入Device-identification-mode流程"><a href="#一、进入Device-identification-mode流程" class="headerlink" title="一、进入Device identification mode流程"></a>一、进入Device identification mode流程</h1><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/25.1.png" width="80%" height="75%" alt="25.1"/></center><ul><li>1、power-on后进入Idle State，或通过发送<strong>CMD0</strong>（0x00000000）；</li><li>2、请求处于Idle State中device的<code>OCR</code>内容：host通过发送<strong>CMD1</strong>，接收来自device的反馈；<br>若CMD1应答中<strong>没有“busy bit”（<em>OCR[31]为高时</em>）</strong>，该device则进入<code>Ready State</code>；</li><li>3、请求处于Ready State中device的<code>CID</code>内容：通过<strong>CMD2</strong>；</li><li>5、进入<code>Identification State</code>：当<strong>CMD2应答的device CID编号和host请求的device CID编号一致</strong>时；</li><li>6、给选中的device赋予一个<code>RCA</code>地址：通过<strong>CMD3</strong>；</li><li>7、最后完成identification进程，device进入Stand-by State，之后在数据传输模式中就会通过RCA地址寻址相应设备。</li></ul><h1 id="二、OCR寄存器的内容"><a href="#二、OCR寄存器的内容" class="headerlink" title="二、OCR寄存器的内容"></a>二、OCR寄存器的内容</h1><p>Operation condition register，表明了device的<code>Vdd电压</code>配置和<code>访问模式</code>。</p><p>还有一个<code>状态bit[31]</code>，当上电完成后此位为1。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/25.2.png" width="75%" height="75%" alt="25.2"/></center><p>此寄存器作为CMD1的应答发送给host，host如果支持sector access mode，CMD1的arg应该在<code>bit[30:29]</code>表明。</p><h1 id="三、CID寄存器"><a href="#三、CID寄存器" class="headerlink" title="三、CID寄存器"></a>三、CID寄存器</h1><p>Device IDentification register，保证了在<code>设备识别阶段</code>每一个设备都有独一无二的设备识别号。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/25.3.png" width="80%" height="75%" alt="25.3"/></center><h1 id="四、RCA寄存器"><a href="#四、RCA寄存器" class="headerlink" title="四、RCA寄存器"></a>四、RCA寄存器</h1><p>Relative device address register，携带着<code>设备识别阶段</code>host分配给识别到的device的相对地址，此地址用于device identification mode之后<code>host&lt;——&gt;device通讯</code>。</p><p>默认值为0x0001，值 0x0000 是为将所有设备以 CMD7 置于 Stand-by 状态而保留的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、进入Device-identification-mode流程&quot;&gt;&lt;a href=&quot;#一、进入Device-identification-mode流程&quot; class=&quot;headerlink&quot; title=&quot;一、进入Device iden</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>24--SVA语法速查</title>
    <link href="https://mkdbook.com/blog024.html"/>
    <id>https://mkdbook.com/blog024.html</id>
    <published>2023-04-28T03:01:34.000Z</published>
    <updated>2023-04-28T03:51:42.745Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、内嵌函数"><a href="#一、内嵌函数" class="headerlink" title="一、内嵌函数"></a>一、内嵌函数</h1><h2 id="1-1-rose"><a href="#1-1-rose" class="headerlink" title="1.1  $rose"></a>1.1  $rose</h2><p>信号&#x2F;表达式的<code>LSB</code><strong>跳变</strong>为<code>1</code>，返回真</p><h2 id="1-2-fell"><a href="#1-2-fell" class="headerlink" title="1.2  $fell"></a>1.2  $fell</h2><p>信号&#x2F;表达式的<code>LSB</code><strong>跳变</strong>为<code>0</code>，返回真</p><h2 id="1-3-stable"><a href="#1-3-stable" class="headerlink" title="1.3  $stable"></a>1.3  $stable</h2><p>信号&#x2F;表达式的值保持<code>不变</code>，返回真</p><h2 id="1-4-past"><a href="#1-4-past" class="headerlink" title="1.4  $past"></a>1.4  $past</h2><p>若<code>(c&amp;&amp;d)</code>为真，<code>2</code>个周期前<code>(a&amp;&amp;b)</code>必须为真。默认1个周期。</p><pre><code class="verilog">@(posedge clk)  (c&amp;&amp;d) |-&gt; ($past ( (a&amp;&amp;b) , 2 ) == 1);</code></pre><h3 id="例1：32bit的data-bus，需要检测它在dAck信号为1时，全部bit位跳变为0。"><a href="#例1：32bit的data-bus，需要检测它在dAck信号为1时，全部bit位跳变为0。" class="headerlink" title="例1：32bit的data bus，需要检测它在dAck信号为1时，全部bit位跳变为0。"></a>例1：32bit的data bus，需要检测它在dAck信号为1时，<code>全部bit位跳变为0</code>。</h3><pre><code class="verilog">//$fell只能检测LSB的跳变，不能得到所有信号都变为0的结论aAck |-&gt; $fell(dBus);//用$past：dBus在dAck信号前一个周期不为零，现在全为0了dAck |-&gt; ($past(dBus)!=32&#39;b0) &amp;&amp; (dBus==32&#39;0);</code></pre><h2 id="1-5-onehat"><a href="#1-5-onehat" class="headerlink" title="1.5   $onehat"></a>1.5   $onehat</h2><p>在任意给定的时钟沿，表达式<code>只有1个bit位为高</code>。</p><h2 id="1-6-onehat0"><a href="#1-6-onehat0" class="headerlink" title="1.6  $onehat0"></a>1.6  $onehat0</h2><p>在任意给定的时钟沿，表达式<code>只有1个bit位为高</code>，或者<code>没有任何bit位为高</code>。</p><h2 id="1-7-isunknow"><a href="#1-7-isunknow" class="headerlink" title="1.7  $isunknow"></a>1.7  $isunknow</h2><p>检验表达式的任何bit位，是否是<code>X或Z</code>。</p><h2 id="1-8-countones"><a href="#1-8-countones" class="headerlink" title="1.8  $countones"></a>1.8  $countones</h2><p><code>计算</code>向量中为<code>高</code>的<code>位</code>的<code>数量</code>。</p><pre><code class="verilog">a33a: assert             property(@(posedge clk) $onehot(state)); a33b: assert             property(@(posedge clk) $onehotO(state)); a33c: assert             property(@(posedge clk) $isunkiiovm(bus) ) ; a33d: assert             property(@(posedge clk)$countones(bus)&gt; 1);</code></pre><p>具体结果如下图所示：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/24.1.png" width="75%" height="75%" alt="24.1"/></center><h1 id="二、操作符"><a href="#二、操作符" class="headerlink" title="二、操作符"></a>二、操作符</h1><h2 id="2-1-m-时钟延迟"><a href="#2-1-m-时钟延迟" class="headerlink" title="2.1  ##m 时钟延迟"></a>2.1  ##m 时钟延迟</h2><p>@(posdege clk) <code>a ##2 b;</code>，a高电平两个周期后b为高电平</p><p>m可为0，表示a、b同时为高 ，可用于同一clk沿降时同时发生这两个事件</p><h2 id="2-2-m-n"><a href="#2-2-m-n" class="headerlink" title="2.2  ##[m:n]"></a>2.2  ##[m:n]</h2><p>范围内即可</p><h2 id="2-3-m-重复，连续"><a href="#2-3-m-重复，连续" class="headerlink" title="2.3  [*m]  重复，连续"></a>2.3  [*m]  重复，连续</h2><p><code>@(posdege clk) a ##1 b[*2];</code>，a高电平1个周期后，b高电平维持两个周期（连续两个clk采样到高）</p><h2 id="2-4-m-n"><a href="#2-4-m-n" class="headerlink" title="2.4  [*m:n]"></a>2.4  [*m:n]</h2><p>范围内即可</p><h2 id="2-5-x3D-m-重复，不连续"><a href="#2-5-x3D-m-重复，不连续" class="headerlink" title="2.5  [&#x3D;m]  重复，不连续"></a>2.5  [&#x3D;m]  重复，不连续</h2><p><code>@(posdege clk) a |=&gt; b [=2] ##1 c;</code>，a ture1个周期后，b只要匹配到两个周期ture就可以了，<code>下个周期后只要c为ture就行</code>（即：c前有两个b成功就可）</p><h2 id="2-6-x3D-m-n"><a href="#2-6-x3D-m-n" class="headerlink" title="2.6  [&#x3D;m:n]"></a>2.6  [&#x3D;m:n]</h2><p>范围内即可</p><h2 id="2-7-gt-m-GoTo重复，不连续"><a href="#2-7-gt-m-GoTo重复，不连续" class="headerlink" title="2.7  [-&gt;m]  GoTo重复，不连续"></a>2.7  [-&gt;m]  GoTo重复，不连续</h2><p><code>@(posdege clk)a |=&gt; b [=2] ##1 c;</code>a ture 1个周期后，b只要匹配到两个周期ture就可以了，<code>下个周期c必须为ture</code>（即：c前必须有一次b成功挨着）</p><h2 id="2-8-gt-m-n"><a href="#2-8-gt-m-n" class="headerlink" title="2.8  [-&gt;m:n]"></a>2.8  [-&gt;m:n]</h2><p>范围内即可</p><h2 id="2-9-sig1-“throughout”-seq1"><a href="#2-9-sig1-“throughout”-seq1" class="headerlink" title="2.9  sig1 “throughout” seq1"></a>2.9  sig1 “throughout” seq1</h2><p>信号1在序列1检测过程中，必须一直为真</p><h3 id="例2、在整个检验过程中，start信号保持为低电平"><a href="#例2、在整个检验过程中，start信号保持为低电平" class="headerlink" title="例2、在整个检验过程中，start信号保持为低电平"></a>例2、<strong>在整个检验过程中，start信号保持为低电平</strong></h3><pre><code class="verilog">property p31;     ©&#123;posedge clk) $fell(start) |-&gt;                                     (!start) throughout                                     (##1 (!a&amp;&amp;!b) ##1 (c[-&gt;3]) ##1 (a&amp;&amp;b)); endproperty a31: assert property(p31);//1、在clk上升沿检测到 start 下降沿后开始检测//2、……//3、……//4、在整个检验过程中，start信号保持为低电平</code></pre><h2 id="2-10-seq1-“within”-seq2"><a href="#2-10-seq1-“within”-seq2" class="headerlink" title="2.10  seq1 “within” seq2"></a>2.10  seq1 “within” seq2</h2><p>在一个序列中定义另一个序列，<code>seq1</code>必须在<code>seq2</code>的过程中发生，即<code>seq2</code>的<code>开始</code>匹配点必须在<code>seq1之前</code>，<code>seq1</code>的<code>结束</code>匹配点必须在<code>seq2之前</code>结束。</p><h2 id="2-11-seq1-”and“-seq2"><a href="#2-11-seq1-”and“-seq2" class="headerlink" title="2.11  seq1 ”and“ seq2"></a>2.11  seq1 ”and“ seq2</h2><p>当两个sequence都成功时，整个property才成功。</p><h2 id="2-12-seq1-“or”-seq2"><a href="#2-12-seq1-“or”-seq2" class="headerlink" title="2.12  seq1 “or” seq2"></a>2.12  seq1 “or” seq2</h2><p>只要其中一个sequence成功，整个property才成功</p><h2 id="2-13-seq1-“intersect”-seq2"><a href="#2-13-seq1-“intersect”-seq2" class="headerlink" title="2.13  seq1 “intersect” seq2"></a>2.13  seq1 “intersect” seq2</h2><p>和<code>and</code>类似，区别是：两个sequence必须<strong>在相同时刻开始</strong>，且<strong>结束于同一时刻</strong>。即<code>seq1</code>和<code>seq2</code>长度必须相等。</p><h2 id="2-14-first-match"><a href="#2-14-first-match" class="headerlink" title="2.14  first_match"></a>2.14  first_match</h2><pre><code class="verilog">module assertion_example;  bit clk, a, b, c;    always #1 clk = ~clk;    sequence s1;    first_match(a ##[1:2] b);  endsequence  sequence s2;       a ##[1:2] b;  endsequence  property p1;    @(posedge clk) s1 |-&gt; c;  endproperty  property p2;    @(posedge clk) s2 |-&gt; c;  endproperty   a1: assert property(p1) $display(&quot;%t, success a1\n&quot;, $time); else $error(&quot;Assertion a1 failed!\n&quot;);a2: assert property(p2) $display(&quot;%t, success a2\n&quot;, $time); else $error(&quot;Assertion a2 failed!\n&quot;);      initial begin    a = 0;    b = 0;    c = 1;fork    fork //a      #2 a=1;      #4 a=0;      #8 a=1;    join    fork //b      #2 b=1;      #4 b=0;      #8 b=1;    joinjoin    #20; $finish;  endendmodule</code></pre><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/24.2.png" width="75%" height="75%" alt="24.2"/></center><p> <code>a ##[1:2] b</code>，如果没有<code>|-&gt;</code>或者<code>|=&gt;</code>时，则匹配一次即可进入下一阶段或者断言成功，但是<strong>如果有|-&gt;或者|&#x3D;&gt;时，则必须保证所有情况都满足才能进入下一阶段</strong>，否则卡死。</p><p><code>first_match</code>的作用就是，使得只要出现一种满足情况即可进入下一阶段。</p><p>如图可看到，加了<code>first_match</code>的p1，匹配了1个周期就开始匹配c了；而p2这完成了匹配1、2周期这两项，才进行c的匹配。</p><h2 id="2-15-not"><a href="#2-15-not" class="headerlink" title="2.15  not "></a>2.15  not <property expr></h2><p>禁止属性，当property不成立时，断言为真。用于我们期望property永远为假的情况。</p><h2 id="2-16-ended-和-matched-结构"><a href="#2-16-ended-和-matched-结构" class="headerlink" title="2.16  .ended 和 .matched  结构"></a>2.16  .ended 和 .matched  结构</h2><p>区别：<code>.end</code>要求两个sequence拥有<strong>同一个</strong>clk， <code>.matched</code>允许两个sequence<strong>不同的</strong>clk。</p><p>作用：匹配一个sequence的结束，如果sequence成功匹配并结束，那么<code>.end/.matched</code>为<strong>真</strong>。</p><pre><code class="verilog">sequence s1;     @(posedge clk) a ##1 b; endsequence sequence s2;     @(posedge clk) c ##1 d; endsequence property p1;     s1 |=&gt; s2; endproperty property p2;     s1.ended |-&gt; ##2 s2.ended; endproperty  al: assert property(p1); a2: assert property(p2);</code></pre><p>上面的例子，用两种方法都是检查了一个 <code>a ##1 b ##1 c ##1 d</code> 序列，</p><p>如下图真值表，上面代码中的<code>a1</code>和<code>a2</code> 断言都匹配的是<strong>周期2-5</strong>。只是<code>a1</code>是匹配的开始，<code>a2</code>是匹配的<code>s1和s2</code>的结尾。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/24.3.png" width="75%" height="75%" alt="24.3"/></center><h2 id="2-17-expect-构造——（assert语句层面）"><a href="#2-17-expect-构造——（assert语句层面）" class="headerlink" title="2.17  expect  构造——（assert语句层面）"></a>2.17  expect  构造——（assert语句层面）</h2><p>expect相当于Verilog中的wait，只能用于procedural block中，有阻塞作用</p><pre><code class="verilog">initial begin     @(posedge clk);     #2ns cpu_ready = 1&#39;b1;     expect(@(posedge clk) ##[1:16] memory_ready == 1&#39;b1)                 $display(&quot;Hand shake successful\n&quot;);         else begin                 $display(&quot;Hand shake failed: exiting\n&quot;)                 $finish();         end //如果expect中memory_ready断言失败，后面这段被阻塞，不会执行    for(i=0; i&lt;64; i++)         begin         send_packet();         $display(&quot;PACKET %0d sent\n&quot;, i);         end end</code></pre><h2 id="2-18-disable-iff"><a href="#2-18-disable-iff" class="headerlink" title="2.18  disable iff"></a>2.18  disable iff</h2><p>1、只能用于property，不能用于sequence。</p><p>2、只能声明在先行算子（antecedent condition）之前。</p><pre><code class="verilog">property p34;     @(posedge clk)     disable iff (reset)//当reset信号为高时，后续断言不会执行     $rose&#123;start) |=&gt; a[=2] ##1 b[=2] ##1 !start endproperty a34: assert property(p34);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、内嵌函数&quot;&gt;&lt;a href=&quot;#一、内嵌函数&quot; class=&quot;headerlink&quot; title=&quot;一、内嵌函数&quot;&gt;&lt;/a&gt;一、内嵌函数&lt;/h1&gt;&lt;h2 id=&quot;1-1-rose&quot;&gt;&lt;a href=&quot;#1-1-rose&quot; class=</summary>
      
    
    
    
    <category term="语言" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="SystemVerilog" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/SystemVerilog/"/>
    
    
    <category term="SVA" scheme="https://mkdbook.com/tags/SVA/"/>
    
  </entry>
  
  <entry>
    <title>23--SVA简介</title>
    <link href="https://mkdbook.com/blog023.html"/>
    <id>https://mkdbook.com/blog023.html</id>
    <published>2023-04-28T03:00:31.000Z</published>
    <updated>2023-08-04T08:24:00.634Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、SVA基本结构"><a href="#一、SVA基本结构" class="headerlink" title="一、SVA基本结构"></a>一、SVA基本结构</h1><p>基本结构包含三个部分，</p><p><code>sequence块</code>：事件。</p><p><code>property块</code>：组合sequence事件形成一个复杂的逻辑行为。</p><p><code>assert/cover关键词</code>：调用property进行判断。</p><pre><code class="systemverilog">//序列中定义事件sequence s1;    a ##2 b;endsequence//属性中调用序列property p1;    @(posedge clk) s1;endsequence//关键词收集属性a1: assert property(p1);c1: cover property(p1);//--------可写在一起----------assert property (@(posedge clk) a ##2 b);</code></pre><p>为了复用性建议分开写，时钟写在property中。个人觉得如果写在代码中只对当前位置进行断言检查，写在一起更为简便。</p><h1 id="二、关键词，assert、cover"><a href="#二、关键词，assert、cover" class="headerlink" title="二、关键词，assert、cover"></a>二、关键词，assert、cover</h1><p><code>assert</code>：property必须一直都是ture。换句话说，忽略PASS，检测Failure。</p><p><code>cover</code>：可统计成功了多少次。换句话说，忽略Failure，有一次成功这个property就算成功。</p><p>区别：‘assert’ checks for failures in your design and ‘cover’ sees if the property did get exercised.</p><blockquote><p>功能覆盖率是按照设计规范衡量验证状态的一个标准，可以分为两类：<br>（1）<code>protocol coverage</code>——specification中所有功能是否都测试过，<br>（2）<code>Test plan coverage</code>——衡量Testbench的穷尽性，例如是否覆盖所有地址。</p></blockquote><p>故，<code>cover</code>语句可以用来获取<code>protocol coverage</code>，结果包含以下信息：</p><ol><li>property<strong>被尝试</strong>检验的次数</li><li>property<strong>成功</strong>的次数</li><li>property<strong>失败</strong>的次数</li><li>property<strong>空成功</strong>的次数</li></ol><h1 id="三、断言位置"><a href="#三、断言位置" class="headerlink" title="三、断言位置"></a>三、断言位置</h1><p>有两种方法将SVA checker连到model中；</p><p>1、内嵌或者直接写在model中；</p><p>2、<code>将SVA checker写成一个独立的model</code>，然后通过<code>bind</code>关键词，将其连接到model；</p><p>bind使用方法：<code>bind &lt;设计model或例化的model&gt; &lt;SVA checker model&gt; &lt;SVA checker例化名&gt; (信号接入);</code></p><pre><code class="systemverilog">module nand_checker;.....断言.....endmodule// bind绑定语句在SVA模块外部bind tb nand_checker U_A (.*);// 相当于SVA模块例化在了tb模块中，与uut平行，结构更清楚// .* 的前提是例化的所有端口类型，名字都相同</code></pre><h1 id="四、关于SVA断言和Verification"><a href="#四、关于SVA断言和Verification" class="headerlink" title="四、关于SVA断言和Verification"></a>四、关于SVA断言和Verification</h1><ol><li><p>SVA可以对硬件设计的<code>期望行为进行编码</code>，可以创建对总线协议的详细检查。</p></li><li><p>Testbech一般包括三项任务：（1）<code>产生激励</code>；（2）<code>自检机制</code>；（3）<code>衡量功能覆盖率</code>；</p> <center> <img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/23.1.png" width="75%" height="75%" alt="23.1"/> </center> </li><li><p><strong>自检</strong>通常着眼两个方面：<br>（1）<code>协议检验</code>——目标是控制信号，控制信号的正确性是验证设计的核心；<br>（2）<code>数据检验</code>——目的是检验正在处理的数据的完整性，如数据包在传输过程中是否损坏；</p></li><li><p>SVA主要解决两类问题：<br>（1）<code>Protocol checking</code>；<br>（2）<code>Protocol coverage</code>；</p> <center> <img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/23.2.png" width="75%" height="75%" alt="23.2"/> </center></li></ol><ul><li>SystemVerilog语言包含4个不同子集：<br>（1）SystemVerilog Object Oriented language for <code>functional verification</code> (using OVM&#x2F;UVM style libraries)<br>（2）SystemVerilog language for <code>Design</code><br>（3）SystemVerilog Assertions <code>(SVA)</code> language<br>（4）SystemVerilog <code>Functional Coverage (FC)</code> Language to see that <strong>the verification environment&#x2F;test-bench have fully verified your design.</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、SVA基本结构&quot;&gt;&lt;a href=&quot;#一、SVA基本结构&quot; class=&quot;headerlink&quot; title=&quot;一、SVA基本结构&quot;&gt;&lt;/a&gt;一、SVA基本结构&lt;/h1&gt;&lt;p&gt;基本结构包含三个部分，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sequ</summary>
      
    
    
    
    <category term="语言" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="SystemVerilog" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/SystemVerilog/"/>
    
    
    <category term="SVA" scheme="https://mkdbook.com/tags/SVA/"/>
    
  </entry>
  
</feed>
