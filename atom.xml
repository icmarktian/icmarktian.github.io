<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>马克得烂笔头</title>
  
  <subtitle>Mark&#39;s Book</subtitle>
  <link href="https://mkdbook.com/atom.xml" rel="self"/>
  
  <link href="https://mkdbook.com/"/>
  <updated>2023-06-24T15:20:57.622Z</updated>
  <id>https://mkdbook.com/</id>
  
  <author>
    <name>Mark</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>33--eMMC的RPMB分区（Replay Protected Memory Block）</title>
    <link href="https://mkdbook.com/blog033.html"/>
    <id>https://mkdbook.com/blog033.html</id>
    <published>2023-06-24T15:10:24.000Z</published>
    <updated>2023-06-24T15:20:57.622Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、RPMB认证（Authentication）"><a href="#一、RPMB认证（Authentication）" class="headerlink" title="一、RPMB认证（Authentication）"></a>一、RPMB认证（Authentication）</h1><p>RPMB使用共享密钥（Shared Secret）的方式进行认证，即host和device 使用相同的身份认证密钥（<code>AuthKey</code>&#x2F;<code>RPMB Key</code>），具体工作方式如下：</p><p>1.1、首先<code>RPMB Key</code>由host写到eMMC device中。（必须在安全的环境中写入，通常在生产线上）<br>1.2、然后，在RPMB区数据进行的读、写操作时，host和device需要使用身份验证密钥（<code>RPMB Key</code>）<code>对信息</code>进行签名（sign）和身份验证（authenticate）。<br>1.3、对信息进行签名时，需要<code>消息身份验证代码 （MAC）</code>，该代码是使用 HMAC SHA-256 算法计算而成的。（详细见2.1-2.4）</p><blockquote><p><code>HMAC</code>是指基于散列的消息认证码（Hash-based Message Authentication Code）。<br>哈希算法特点：即使只改变原数据中1bit的数据，两者的哈希值也是完全不同的。<br><code>AuthKey</code>&#x2F;<code>RPMB Key</code>是不能被泄露的，故host需要在<code>TEE环境</code>中对密钥进行操作。</p></blockquote><blockquote><p><code>TEE环境</code>（trusted execution environment）：可信任执行环境指CPU内部的一个安全区域，该区域可以保证数据的安全性和完整性，外部各方不可见或无法访问，无论请求访问的实体有多大权限。（如指纹识别、密码处理、数据加解密、安全认证、系统升级版本号认证等操作都是在此区域执行）<br><code>REE环境</code>（rich  execution environment）：是所有移动设备通用的环境，运行通用的 OS（Operating System），例如 Android，IOS 系统等。</p></blockquote><h1 id="二、RPMB如何防止Replay-Attack？"><a href="#二、RPMB如何防止Replay-Attack？" class="headerlink" title="二、RPMB如何防止Replay Attack？"></a>二、RPMB如何防止Replay Attack？</h1><p>Replay Protection和基本思想是确保每条信息都是独一无二的。<br>RPMB中，有一个<code>只读的Write Counter</code>，在每次写入信息后，该计数器就会增加，且新值会包含在下一次认证代码的计算中。<br>该计算会把下列内容作为计算的输入（图33.1<code>bit[283:0]</code>相应需要的部分按顺序连接）：</p><ul><li>2.1、The <code>shared/secret key</code>，共享密钥。</li><li>2.2、The <code>message</code>，包括了write command或read result。</li><li>2.3、The <code>write counter</code>，记录了Write RPMB的总次数，此计数器只增不减，32bit，当达到0xFFFF_FFF时，<strong>RPMB就变为只读了</strong>。（<em><strong>用于写操作</strong></em>）</li><li>2.4、A <code>nonce</code>，为每一个read command生成一个随机数。（<em><strong>用于读操作</strong></em>）</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/33.1.png" width="85%" height="85%" alt="33.1"/></center><p>最后，生成的<strong>MAC</strong>是一个256 bit（32 byte）的密码，嵌入在RPMB数据帧中，并与消息数据本身一起发送。</p><h1 id="三、从RPMB读数据"><a href="#三、从RPMB读数据" class="headerlink" title="三、从RPMB读数据"></a>三、从RPMB读数据</h1><p>1、host向eMMC发起读RPMB请求，同时生成一个16 byte的随机数（<code>Nonce</code>）。<br>2、eMMC将请求的数据从RPMB读出，并利用<code>shared/secret key</code>和<code>data</code>、<code>Nonce</code>一起计算得到MAC；<br>3、eMMC再将<code>data</code>、<code>Nonce</code>、和生成的<code>MAC</code>一起发送给host。<br>4、host接收到后，先比较<code>Nonce</code>是否和自己发送的一致，如果一致再利用<code>shared/secret key</code>和<code>data</code>、<code>Nonce</code>一起进行计算，也会得到一个<strong>MAC2</strong>。<br>5、最后，host将生成的<strong>MAC2</strong>和来自eMMC的MAC进行比较，如果一致，就可以确认data不是攻击者伪造的。</p><h1 id="四、向RPMB写数据"><a href="#四、向RPMB写数据" class="headerlink" title="四、向RPMB写数据"></a>四、向RPMB写数据</h1><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/33.2.png" width="75%" height="75%" alt="33.2"/></center><p>1、host先通过读数据流程，读RPMB中的<code>Writer Counter</code>。<br>2、host再将写入相关的<code>Message</code>和<code>Write Counter</code>，利用<code>shared/secret key</code>一起计算生成MAC；<br>3、host再将写入相关的<code>Message</code>、<code>Write Counter</code>、<code>MAC</code>一起发送给eMMC。<br>4、eMMC接收到数据后，先比较<code>Writer Counter</code>是否与当前值一致，如果一致再将接收到的写入相关的<code>Message</code>和<code>Write Counter，</code>利用<code>shared/secret key</code>和一起进行计算，也会得到一个<strong>MAC2</strong>。<br>5、最后，eMMC将生成的<strong>MAC2</strong>和来自host的MAC进行比较，如果相同才会将data写入eMMC的RPMB中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、RPMB认证（Authentication）&quot;&gt;&lt;a href=&quot;#一、RPMB认证（Authentication）&quot; class=&quot;headerlink&quot; title=&quot;一、RPMB认证（Authentication）&quot;&gt;&lt;/a&gt;一</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>32--eMMC password lockunlock</title>
    <link href="https://mkdbook.com/blog032.html"/>
    <id>https://mkdbook.com/blog032.html</id>
    <published>2023-06-24T15:03:24.000Z</published>
    <updated>2023-06-24T15:03:43.514Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1、password存在哪个位置？"><a href="#1、password存在哪个位置？" class="headerlink" title="1、password存在哪个位置？"></a>1、password存在哪个位置？</h2><blockquote><p>128bit的<code>PWD</code>和8bit的<code>PWD_LEN</code>，这两个寄存器是单独的且非易失的（power cycle不会导致被擦除）。</p></blockquote><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/32.1.png" width="75%" height="75%" alt="32.1"/></center><ul><li><code>ERASE</code>：若为“1”则定义forcing erase，所有其他的bit都为0，且只有cmd byte会被发送；</li><li><code>LOCK_UNLOCK</code>：“1”&#x3D; Lock device、“0” &#x3D; Unlock device；<br><strong>注：LOCK_UNLOCK和SET_PWD一起设置是有效的，但是和CLR_PWD一起设置是不允许的！</strong></li><li><code>CLR_PWD</code>：“1” &#x3D; Clear PWD；</li><li><code>SET_PWD</code>：“1” &#x3D; Set new password to PWD；</li><li><code>PWD_LEN</code>：定义后面PWD的长度，有效的password长度为1-16个byte；同时标志，是否设置了password；<br><strong>注：16 * 8 &#x3D; 128bit，说明PWD长度最长为128bit和第一点符合 ；若为0，则说明没有设置password。</strong></li></ul><h2 id="2、在哪里决定是否开启此功能？"><a href="#2、在哪里决定是否开启此功能？" class="headerlink" title="2、在哪里决定是否开启此功能？"></a>2、在哪里决定是否开启此功能？</h2><ul><li>EXT_CSD[171]——<code>USER_WP</code>的<code>bit7（PERM_PSWD_DIS）</code><br>0x0：允许password protect功能；<br>0x1：永久禁止password protect功能——ERASE（Forcing erase）、LOCK、UBLOCK、CLR_PWD、SET_PWD；</li></ul><h1 id="二、Setting-the-password"><a href="#二、Setting-the-password" class="headerlink" title="二、Setting the password"></a>二、Setting the password</h1><ul><li>1、CMD7（SELECT&#x2F;DESELECT_CARD）选定设备，进入Transfer State；</li><li>2、CMD16（SET_BLOCKLEN）定义block长度，长度由图1决定；</li><li>3、CMD42（LOCK_UNLOCK）发送图1中的内容，其中<code>SET_PWD</code>被置位，<code>PWD_LEN</code>应匹配新密码+旧密码的长度，<code>PWD</code>中会包含<code>新/旧密码</code>。</li></ul><blockquote><p><strong>LOCK_UNLOCK_FAILED error</strong>出现的几种情况：<br>1、<code>新/旧密码</code>长度超过16byte；<br>2、设置新密码时，PWD_LEN只设置为旧密码的长度；这时旧密码不会被更改；<br>3、旧密码不正确（seize和content不相等），这时旧密码不改变；<br>如果相符合，则给定的新密码和它的大小将分别保存在PWD和PWD_LEN字段给中。</p></blockquote><h1 id="三、Reset-the-password"><a href="#三、Reset-the-password" class="headerlink" title="三、Reset the password"></a>三、Reset the password</h1><ul><li>1、CMD7（SELECT&#x2F;DESELECT_CARD）选定设备，进入Transfer State；</li><li>2、CMD16（SET_BLOCKLEN）定义block长度，长度由图1决定；</li><li>3、CMD42（LOCK_UNLOCK）发送图1中的内容，其中<code>CLR_PWD</code>被置位，<code>PWD_LEN</code>和<code>PWD</code>应和当前密码长度和密码匹配。<br>3.1、若匹配<code>PWD_LEN ——&gt;0</code>，<code>PWD被清零</code>。<br>3.2、若不匹配，<strong>LOCK_UNLOCK_FAILED error</strong>被报告。</li></ul><h1 id="四、Locking-the-device"><a href="#四、Locking-the-device" class="headerlink" title="四、Locking the device"></a>四、Locking the device</h1><ul><li>1、CMD7（SELECT&#x2F;DESELECT_CARD）选定设备，进入Transfer State；</li><li>2、CMD16（SET_BLOCKLEN）定义block长度，长度由图1决定；</li><li>3、CMD42（LOCK_UNLOCK）发送图1中的内容，<code>LOCK_UNLOCK</code>设置为LOCK（&#x3D;1），PWD_LEN和PWD匹配。<br>3.1、若<code>匹配</code>，LOCK设备成功，<strong>Device-locked status bit</strong>会在状态寄存器中<strong>被标志</strong>；<br>3.2、若<code>不匹配</code>，LOCK_UNLOCK_FAILED error会在状态寄存器中被标志；</li></ul><blockquote><p>1、如果device设置了password，则上电复位后，device会被自动LOCK；<br>2、如果试图LOCK一个没有password的device，或device已经处于LOCK状态，则LOCK_UNLOCK_FAILED error会在状态寄存器中标志；</p></blockquote><h1 id="五、Unlocking-the-device"><a href="#五、Unlocking-the-device" class="headerlink" title="五、Unlocking the device"></a>五、Unlocking the device</h1><ul><li>1、CMD7（SELECT&#x2F;DESELECT_CARD）选定设备，进入Transfer State；</li><li>2、CMD16（SET_BLOCKLEN）定义block长度，长度由图1决定；</li><li>3、CMD42（LOCK_UNLOCK）发送图1中的内容，<code>LOCK_UNLOCK</code>设置为UNLOCK（&#x3D;0），PWD_LEN和PWD匹配。<br>若<code>匹配</code>，UNLOCK设备成功，<strong>Device-locked status bit</strong>会在状态寄存器中<strong>被清除</strong>；<br>若<code>不匹配</code>，LOCK_UNLOCK_FAILED error会在状态寄存器中标志；</li></ul><blockquote><p>1、Unlocking只在当前power下执行，因为上电后会自动LOCK（如果设置了LOCK）；<br>2、如果试图UNLOCK的device已经处于UNLOCK状态，则LOCK_UNLOCK_FAILED error会在状态寄存器中标志；</p></blockquote><h1 id="六、Forcing-ERASE"><a href="#六、Forcing-ERASE" class="headerlink" title="六、Forcing ERASE"></a>六、Forcing ERASE</h1><p>作用：当用户忘记password时，可将PWD和device data一起擦除，故称为<code>强制擦除</code>。</p><ul><li>1、CMD7（SELECT&#x2F;DESELECT_CARD）选定设备，进入Transfer State；</li><li>2、CMD16（SET_BLOCKLEN）定义block长度，<strong>长度为1byte（8bit）</strong>；</li><li>3、CMD42（LOCK_UNLOCK）发送图1中<strong>第一行</strong>的内容，设置ERASE操作；</li></ul><p>Forcing ERASE命令成功后，device所有内容（eMMC4.3之后，Boot、RPMB、GPP不会被擦除了）以及PWD、PWD_LEN都会被擦除，LOCK的device会被UNLOCK，<strong>即使CSD中设置了temporary-write-protect bit也会被擦除</strong>。</p><blockquote><p><strong>LOCK_UNLOCK_FAILED error</strong>出现的几种情况：<br>1、如果图1中，bit[3] ERASE不是唯一为1的bit；<br>2、如果发送Forcing ERASE命令时，decive 存在<code>power-on protected</code> or a <code>permanently-write-protected write protect groups</code>，则Forcing ERASE将会失败；<br>3、在一个Unlocked的device上发送Forcing ERASE命令；</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;h2 id=&quot;1、password存在哪个位置？&quot;&gt;&lt;a href=&quot;#1、password存在哪个位</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>31--eMMC中三种Information Security机制</title>
    <link href="https://mkdbook.com/blog031.html"/>
    <id>https://mkdbook.com/blog031.html</id>
    <published>2023-06-24T14:35:24.000Z</published>
    <updated>2023-06-24T14:59:54.226Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>“信息安全”有三个最基本的目标：</p><ul><li><code>Confidentiality</code>：<strong>机密性</strong>是指，信息只能被授权的用户阅读和理解。</li><li><code>Integrity</code>：<strong>完整性</strong>是指，能够确定信息受到保护，不被篡改、修改或删除的能力。<br>  Integrity of information covers its <code>origin</code>, <code>completeness</code>, and <code>correctness</code> using methods such as identification and authentication.</li><li><code>Availability</code>：<strong>可用性</strong>是指，信息总是可供已经授权的用户使用。</li></ul><p>例如：eMMC的write protect是为了确保data availability，replay protected memory block（RPMB）是为了确保data integrity和data confidentiality。</p><h1 id="二、eMMC-Information-Security的类型"><a href="#二、eMMC-Information-Security的类型" class="headerlink" title="二、eMMC Information Security的类型"></a>二、eMMC Information Security的类型</h1><h2 id="1、Password-Lock-x2F-Unlock"><a href="#1、Password-Lock-x2F-Unlock" class="headerlink" title="1、Password Lock&#x2F;Unlock"></a>1、Password Lock&#x2F;Unlock</h2><ul><li>Password lock&#x2F;Unlock是集成到eMMC协议中的第一个Security feature，该功能来源于传统的SD卡，<strong>可以保护user area的内容不被访问（read、write、erase）</strong>。</li><li>由CMD42（LOCK_UNLOCK）设置。</li><li>当启用password lock之后，host可以执行某些操作（如reset、initialize、select、query for status），但不能访问user area的任何数据。而且host依然可以访问boot分区、RPMB和GPP分区。</li><li>缺点：这种保护可用于防止数据被盗，但它也限制了任何人（包括数据所有者）可以对设备执行的操作，因为不允许访问（任何类型的）受保护的数据。</li></ul><h2 id="2、Write-Protect"><a href="#2、Write-Protect" class="headerlink" title="2、Write Protect"></a>2、Write Protect</h2><ul><li>作用：防止数据损坏或被擦除。</li><li>eMMC4.3之前，write protect只支持user area且整个设备要么是可写的要么是不可写的；<br>eMMC4.4之后，write protect可控制特定的分区被写入或只读；<br>eMMV5.1之后，write protect支持认证，即只有被授权的用户才能改变write protect设置；<br>（演变过程使得write更加灵活和安全。）</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/31.1.png" width="80%" height="80%" alt="31.1"/></center>    <ul><li>Write Protect与Password Lock&#x2F;Unlock区别：前者依然能够从device中读取数据。</li></ul><h2 id="2-1-eMMC-5-1中有4种类型的写保护："><a href="#2-1-eMMC-5-1中有4种类型的写保护：" class="headerlink" title="2.1  eMMC 5.1中有4种类型的写保护："></a>2.1  eMMC 5.1中有4种类型的写保护：</h2><ul><li><code>Permanent</code>：当启用了写保护，就不能改变了。</li><li><code>Power-on</code>：当启用了写保护，只能通过power cycle或通过device RESET pin来改变（会造成设备reboot）。</li><li><code>Temporary</code>：写保护可以启用，也可以取消。</li><li><code>Secured</code>：只有被授权使用RPMB的用户，才可以启用和禁用写保护。</li></ul><h2 id="2-2-eMMC-5-1整个设备都支持写保护"><a href="#2-2-eMMC-5-1整个设备都支持写保护" class="headerlink" title="2.2  eMMC 5.1整个设备都支持写保护"></a>2.2  eMMC 5.1整个设备都支持写保护</h2><ul><li><strong>The entire device</strong>：（包括了Boot Area Partitions, General Purpose Area Partition, RPMB， User&#x2F;Enhanced User Data Area Partition）可以通过CSD中相关bit设置<code>permanent</code>或<code>temporary</code>写保护。</li><li><strong>Boot partitions</strong>：可以设置<code>permanent</code>、<code>secured</code>、<code>power-on</code>写保护。</li><li><strong>UDA和GPP</strong>：可以设置<code>permanent</code>、<code>secured</code>、<code>power-on</code>、<code>temporary</code>写保护，为specific segment（即协议中说的“write protect group”）</li></ul><h2 id="2-3-Write-Protect两种分类"><a href="#2-3-Write-Protect两种分类" class="headerlink" title="2.3  Write Protect两种分类"></a>2.3  Write Protect两种分类</h2><h3 id="2-3-1-Entire-device写保护"><a href="#2-3-1-Entire-device写保护" class="headerlink" title="2.3.1  Entire device写保护"></a>2.3.1  Entire device写保护</h3><ul><li>包括Boot Area Partitions、General Purpose Area Partition、RPMB、User&#x2F;Enhanced User Data Area Partition；</li><li>相比其他保护机制，<code>优先级最高</code>；</li></ul><h3 id="2-3-2-Specific-segments写保护"><a href="#2-3-2-Specific-segments写保护" class="headerlink" title="2.3.2  Specific segments写保护"></a>2.3.2  Specific segments写保护</h3><ul><li>可以将特定的区段设置为<code>permanent</code>、<code>power-on</code>或<code>temporarily</code>写保护。</li><li>segment的长度由EXT_CSD[175]——<code>ERASE_GROUP_DEF</code>决定由哪一个参数决定：<br><code>0x0</code>：CSD[36:32]——<code>WP_GRP_SIZE</code>；（默认）<br><code>0x1</code>：EXT_CSD[221]——<code>HC_WP_GRP_SIZE</code>；使用High-capacity的写保护组大小。</li></ul><h3 id="2-3-3-WP-GRP-SIZE（旧的模式）"><a href="#2-3-3-WP-GRP-SIZE（旧的模式）" class="headerlink" title="2.3.3  WP_GRP_SIZE（旧的模式）"></a>2.3.3  WP_GRP_SIZE（旧的模式）</h3><ul><li>在CSD中，一共有<code>5bit</code>大小。</li><li>故一共可以表示<code>32</code>个erase group。</li></ul><h3 id="2-3-4-HC-WP-GRP-SIZE（高容量模式）"><a href="#2-3-4-HC-WP-GRP-SIZE（高容量模式）" class="headerlink" title="2.3.4  HC_WP_GRP_SIZE（高容量模式）"></a>2.3.4  HC_WP_GRP_SIZE（高容量模式）</h3><ul><li><strong>Write protect group size</strong> &#x3D; <code>512KB</code> * <code>HC_ERASE_GRP_SIZE</code> * <code>HC_WP_GRP_SIZE</code></li><li>注意<code>512KB</code> * <code>HC_ERASE_GRP_SIZE</code>代表的是<strong>Erase-unit size</strong>，最大为<code>512Kbyte * 255</code>。</li><li><code>HC_WP_GRP_SIZE</code>最多表示可以255个<strong>Erase-unit size</strong>，如果为0则表示不支持high-capacity write protect group seize。（详见协议p193）</li></ul><h2 id="3、RPMB（Replay-Protect-Memory-Block）"><a href="#3、RPMB（Replay-Protect-Memory-Block）" class="headerlink" title="3、RPMB（Replay Protect Memory Block）"></a>3、RPMB（Replay Protect Memory Block）</h2><ul><li>此功能首次出现在eMMC4.4，使设备能够在一个小的、特定的区域内存储数据，该区域经过验证并受到保护，以防止重放攻击（replay attack）。</li><li>一些使用RPMB的例子如下：<br>1、software version authentication；<br>2、fingerprint verification；<br>3、secure key storage；<br>4、network vendor information；<br>5、digital rights management（DRM）；<br>6、secure payments；</li></ul><h3 id="3-1-什么是Replay-Attack？"><a href="#3-1-什么是Replay-Attack？" class="headerlink" title="3.1  什么是Replay Attack？"></a>3.1  什么是Replay Attack？</h3><p>重放攻击是一种攻击类型，在这种攻击中，攻击者捕获在两方之间发送的数据，然后在稍后的时间重新发送该数据。</p><p> 这种攻击的目的是：获得对系统的未授权访问或修改先前发送的数据。<br>例如，攻击者可以捕获在用户和服务器之间发送的登录请求。 然后攻击者可以在稍后重播该请求，这将允许他们以用户身份登录到服务器。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/31.2.png" width="70%" height="70%" alt="31.2"/></center>如图31.2所示，关于重放攻击的例子，设想一个数字钱包服务提供商发送一个经过验证的信息，将用户账户余额设置为2000美元。当用户用数字钱包支付1600美元的账单时，可用余额下降到400美元。如果一个运行重放攻击的恶意软件拦截了最初的信息（将账户余额设置为2000美元的信息），在购买1600美元后重新发送相同的信息，就可以将账户余额重置为2000美元。<h3 id="3-2-Replay-Protect的常见机制？"><a href="#3-2-Replay-Protect的常见机制？" class="headerlink" title="3.2  Replay Protect的常见机制？"></a>3.2  Replay Protect的常见机制？</h3><ul><li><code>One-time passwords</code>（OTP）：一次性口令，唯一性。</li><li><code>Timestamps</code>：使得信息传输命令只在一个很短的时间内有效。</li><li><code>Nonce</code>（number used once）：使用一次的随机数字。</li><li><code>Sequence numbers</code>：每个数据传输或请求都被分配一个唯一的序列号。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;“信息安全”有三个最基本的目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Confidentiali</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>30--eMMC的Data Read</title>
    <link href="https://mkdbook.com/blog030.html"/>
    <id>https://mkdbook.com/blog030.html</id>
    <published>2023-06-24T14:25:24.000Z</published>
    <updated>2023-06-24T14:32:20.437Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>传输模式模式有两种：</p><ul><li><code>SDR</code>：每条数据线上有1个CRC，在时钟的上升沿采样</li><li><code>DDR</code>：双沿采样，数据以4-bit或8-bit位宽模式传输。block数据块<code>固定为512 byte</code>，每条数据线上有2个CRC，第一个CRC校验第奇数个byte（共256），第二个CRC校验第奇数个byte（共256）</li></ul><h2 id="1-1-SDR模式下，block大小定义"><a href="#1-1-SDR模式下，block大小定义" class="headerlink" title="1.1  SDR模式下，block大小定义"></a>1.1  SDR模式下，block大小定义</h2><p>在单块传输过程中，数据传输的基本单位是block，它的<strong>最大长度</strong>在<code>CSD[83:80]READ_BL_LEN</code>中定义，它表示数据块大小的方法为<code>2 的 READ_BL_LEN 次方</code> 。完成传输后返回<em><strong>Trasnfer</strong></em>状态。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/30.1.png" width="75%" height="75%" alt="30.1"/></center><p><strong>如果<code>CSD[79]READ_BL_PARTIAL</code>为1，也可以读取比定义的block更小的block（partial block read）。</strong></p><h3 id="1-1-1-READ-BL-PARTIAL-描述"><a href="#1-1-1-READ-BL-PARTIAL-描述" class="headerlink" title="1.1.1 READ_BL_PARTIAL 描述"></a>1.1.1 READ_BL_PARTIAL 描述</h3><p>READ_BL_PARTIAL 定义了partial block size是否可以用于块读命令</p><ol><li>最大2GB容量时（byte访问模式）<ul><li>0：只允许512B和READ_BL_LEN定义的block长度，用于block read</li><li>1：可以使用更小的块，最小为<code>最小可寻址的单位</code>（1byte）</li></ul></li><li>大于2GB容量时（sector 访问模式）<ul><li>0：只允许512B和READ_BL_LEN</li><li>1：可以更小，最小512B</li></ul></li></ol><h2 id="1-2-DDR，固定512B，不支持部分块读"><a href="#1-2-DDR，固定512B，不支持部分块读" class="headerlink" title="1.2 DDR，固定512B，不支持部分块读"></a>1.2 DDR，固定512B，不支持部分块读</h2><h1 id="二、Single-block-read"><a href="#二、Single-block-read" class="headerlink" title="二、Single block read"></a>二、Single block read</h1><p><code>CMD7（SELECT/DESELECT_CARD）</code>选定一个设备用于数据读操作，再用<code>CMD16（SET_BLOCKLEN）</code>设定有效快长度，发送<code>CMD17（READ_SINGLE_ BLOCK）</code>开始读数据。（CMD17的参数位为地址）</p><ul><li>单块读时序图</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/30.2.png" width="75%" height="75%" alt="30.2"/></center>    <h1 id="三、Multiple-block-read"><a href="#三、Multiple-block-read" class="headerlink" title="三、Multiple block read"></a>三、Multiple block read</h1><p>有两种多块读的类型。</p><h2 id="3-1-Open-ended-Multiple-block-read"><a href="#3-1-Open-ended-Multiple-block-read" class="headerlink" title="3.1  Open-ended Multiple block read"></a>3.1  Open-ended Multiple block read</h2><p>读取的块数不指定，直到收到停止传输命令<code>CMD12（STOP_TRANSMISION）</code>。</p><h2 id="3-2-Multiple-block-read-with-pre-defined-count"><a href="#3-2-Multiple-block-read-with-pre-defined-count" class="headerlink" title="3.2  Multiple block read with pre-defined count"></a>3.2  Multiple block read with pre-defined count</h2><p>定义块数，完成传输后返回<em><strong>Transfer</strong></em>状态。</p><p>启动方法为，host使用<code>CMD23（SET_BLOCK_COUNT）</code>后紧跟<code>CMD18（READ_MULTIPLE_BLOCK）</code>，否则设备默认开始Open-ended 多块读。</p><ul><li>Figure 43为多块读时序，Figure 44为收到CMD12的应答</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/30.3.png" width="75%" height="75%" alt="30.3"/></center>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;传输模式模式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SDR&lt;/code&gt;：每条数据线上有1</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>29--eMMC的Data Write</title>
    <link href="https://mkdbook.com/blog029.html"/>
    <id>https://mkdbook.com/blog029.html</id>
    <published>2023-06-24T06:31:24.000Z</published>
    <updated>2023-06-24T14:17:50.555Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、Data-Write"><a href="#一、Data-Write" class="headerlink" title="一、Data Write"></a>一、Data Write</h1><p>写操作的数据传输都带有CRC（SDR带一个，DDR带两个）。在写操作执行之前，设备会对每个接收到的data block进行CRC检查，防止错误数据的写入。</p><h2 id="1-1-数据可靠性设置，WR-REL-SET"><a href="#1-1-数据可靠性设置，WR-REL-SET" class="headerlink" title="1.1  数据可靠性设置，WR_REL_SET"></a>1.1  数据可靠性设置，WR_REL_SET</h2><p>写操作进行过程中被打断，通常不会影响其他地址上已有数据的丢失，所以会在<code>保护已有数据</code>和<code>写性能</code>之间做一个折中。如何折中，host 可以决定，在<code>EXT_CSD[167]的WR_REL_SET</code>定义。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/29.1.png" width="75%" height="75%" alt="29.1"/></center><blockquote><p>如上图所示，当相关的bit位<code>为1</code>：如果写数据的时候发生掉电，设备<strong>会保护先前写入的数据</strong>；<code>为0</code>：写操作执行<strong>性能优化</strong>，掉电后该分区<strong>已有的数据可能有风险</strong>。<br>注：<code>HS_CTRL_REL</code>是<code>EXT_CSD[166]的WR_REL_PARAM</code>中的bit[0]，此位置决定了上述参数是否可以修改（一般全为1）</p></blockquote><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/29.2.png" width="75%" height="75%" alt="29.2"/></center><p>上述<code>WR_REL_SET</code>的设置只影响两个分区<code>main user area</code>和<code>general purpose partion</code>。<strong>boot分区</strong>和<strong>RPMB分区</strong>是默认会保护先前数据的，不受该设置影响。</p><p>host可以通过改变该寄存器的bit（不能单独只改某一个，必须全部作为一个数据写入）选择改变上述分区的write reliability，这个过程必须发生在<code>PARTITION_SETTING_COMPLETED</code>之前。</p><p><code>WR_REL_SET</code>在分区设置之后才有效，且参数中的分区如果不存在不会影响设备。</p><h1 id="二、Block-Write"><a href="#二、Block-Write" class="headerlink" title="二、Block Write"></a>二、Block Write</h1><p><code>SDR模式</code>：数据块由<code>WRITE_BL_LEN</code> 定义。如果CRC失败，则device在DAT0上表示失败，所有的数据都被抛弃，多块写模式接下来的步骤也会被忽略。</p><p><code>DDR模式</code>：数据块为<code>512 Byte</code>。每一个数据块有2个CRC，一个对偶字节校验，一个对奇字节校验。</p><blockquote><p><code>WRITE_BL_LEN</code> 是CRC[25:22]，共4个bit，值为0-15；它表示数据块大小的方法为<code>2 的 WRITE_BL_LEN 次方</code></p></blockquote><h2 id="2-1-多块写介绍"><a href="#2-1-多块写介绍" class="headerlink" title="2.1  多块写介绍"></a>2.1  多块写介绍</h2><p><code>CMD25（WRITE_MULTIPLE_BLOCK）</code>开始几个连续的block传输。定义了3种类型的multiple-block write transactions：</p><h3 id="2-1-1-Open-ended-Multiple-block-write"><a href="#2-1-1-Open-ended-Multiple-block-write" class="headerlink" title="2.1.1  Open-ended Multiple-block write"></a>2.1.1  Open-ended Multiple-block write</h3><p><strong>没有定义</strong>多块写的write block<strong>数目</strong>，device将连续地接受和编写数据块，直到收到停止传输命令<code>CMD12（STOP_TRANSMISSION）</code>。</p><h3 id="2-1-2-Multiple-block-write-with-pre-defined-block-count"><a href="#2-1-2-Multiple-block-write-with-pre-defined-block-count" class="headerlink" title="2.1.2  Multiple-block write with pre-defined block count"></a>2.1.2  Multiple-block write with pre-defined block count</h3><p>device将接收预定义的数据块数，终止传输并返回<em><strong>tansfer</strong></em>状态。这种模式下不需要停止命令。<br>启动方法为<code>CMD23（SET_BLOCK_COUNT）</code>后立即发送<code>CMD25（WRITE_MULTIPLE_BLOCK）</code> 。</p><h3 id="2-1-3-Reliable-write"><a href="#2-1-3-Reliable-write" class="headerlink" title="2.1.3  Reliable write"></a>2.1.3  Reliable write</h3><p>有<code>可靠写参数</code>和<code>pre-defined block count</code>，类似于2.12的模式，附加了如下条件：<br><strong>当数据成功写入之前，逻辑地址指向的旧数据必须保持不变，这样即使在编程过程中突然断电，数据也不会出现undefined。</strong></p><ul><li>1、数据传输以<code>512B sectors大小的倍数</code>传输，或<strong>Large Sector</strong>模式被启用下以<code>8*512B Sectors大小的倍数</code>传输。<code>CMD16（SET_BLOCKLEN）</code>定义的<code>WRITE_BL_LEN</code>被忽略。</li><li>2、启用方法：<code>CMD23（SET_BLOCK_COUNT）</code>的<code>bit[31]</code>设置为<code>1</code>。</li><li>3、必须sector aligned，否则CMD23的Rb响应中bit[19]——ERROR位会置1（<em>详见5.1协议 p139. Table68</em>）</li><li>4、若发生断电，会有三种情况：所有扇区都是<strong>新数据</strong>，所有扇区都是<strong>旧数据</strong>，或有些扇区是<strong>新数据</strong>而其余扇区容纳着<strong>旧数据</strong>。</li><li>5、 Reliable write被高优先级命令（CMD12、CMD13）打断后，<code>寄存器</code>中标记为completed的扇区为新数据，其余扇区为旧数据。</li><li>6、<code>REL_WR_SEC_C[222]</code> 寄存器应设置为 1 且对Reliable write操作无影响</li></ul><h2 id="2-2-单块写时序"><a href="#2-2-单块写时序" class="headerlink" title="2.2  单块写时序"></a>2.2  单块写时序</h2><p>数据写操作前，通过<code>CMD7（SELECT/DESELECT_CARD）</code>选定一个设备，再用<code>CMD16（SET_BLOCKLEN）</code>设定有效块长度，发送<code>CMD24（WRITE_BLOCK）</code>开始写数据。（CMD24的参数位为地址）</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/29.3.png" width="80%" height="80%" alt="29.3"/></center><p>单块写时序如图所示，当host发送完CMD，device应答后，再Nwr时钟周期，host开始传输数据。<br>Ncrc是为HS200和HS400设置的参数。<br>之后device会在<code>DAT0</code>上返回CRC的校验结果，（<code>101：有错</code>；<code>010：正确，然后开始编程</code>）。<br>当设备正在program时，<strong>DAT0会拉低表示busy</strong>，完成后拉高。</p><h2 id="2-3-多块写时序"><a href="#2-3-多块写时序" class="headerlink" title="2.3  多块写时序"></a>2.3  多块写时序</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/29.4.png" width="85%" height="85%" alt="29.4"/></center><p>如果 Host 发送的是 Multiple Block Write Command，那么 eMMC Device 会持续地将接收到的数据写入到存储器中，直到 Host 主动发送 Stop Command（CMD12）。</p><p>eMMC Device 在接收到一个 Block 的数据后，会进行 CRC 校验，然后将校验结果通过 CRC Token 发送给 Host。</p><p>发送完 CRC Token 后，如果 CRC 校验成功，eMMC Device 会将数据写入到内部存储器时，此时 DAT0 信号会拉低，作为 Busy 信号。Host 会持续检测 DAT0 信号，直到为高电平时，才会接着发送下一个 Block 的数据。如果 CRC 校验失败，那么 eMMC Device 不会进行数据写入，此次传输后续的数据都会被忽略。</p><p>NOTE:向 eMMC Device 写数据都是按 Block 写入的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、Data-Write&quot;&gt;&lt;a href=&quot;#一、Data-Write&quot; class=&quot;headerlink&quot; title=&quot;一、Data Write&quot;&gt;&lt;/a&gt;一、Data Write&lt;/h1&gt;&lt;p&gt;写操作的数据传输都带有CRC（SD</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>28--eMMC的Bus Speed Modes</title>
    <link href="https://mkdbook.com/blog028.html"/>
    <id>https://mkdbook.com/blog028.html</id>
    <published>2023-06-24T05:49:24.000Z</published>
    <updated>2023-06-24T06:29:31.770Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、Bus-Speed-mode介绍（eMMC-5-1）"><a href="#一、Bus-Speed-mode介绍（eMMC-5-1）" class="headerlink" title="一、Bus Speed mode介绍（eMMC 5.1）"></a>一、Bus Speed mode介绍（eMMC 5.1）</h1><h2 id="1-1-eMMC-Bus，标准接口"><a href="#1-1-eMMC-Bus，标准接口" class="headerlink" title="1.1  eMMC Bus，标准接口"></a>1.1  eMMC Bus，标准接口</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.1.png" width="60%" height="60%" alt="28.1"/></center><p>如图28.1所示，eMMC总线共有<code>11根信号线</code>，用于Host端和eMMC device端通信。</p><ul><li><code>CLK</code>：<em><strong>单向，host——&gt;eMMC</strong></em>；时钟频率范围为0-200MHz。</li><li><code>Data Strobe</code>：<em><strong>单向，host&lt;——eMMC</strong></em>；频率和CLK相同，用于host端在HS400模式下进行数据同步，<strong>省去总线tuning过程</strong>。</li><li><code>CMD</code>：<em><strong>双向，host&lt;——&gt;eMMC</strong></em>；命令和响应走这条线。</li><li><code>DAT0-7</code>：<em><strong>双向</strong></em>，有三种bus width模式，1bit，4bit，8bit；power-on默认为1bit模式（DAT0）。</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.2.png" width="60%" height="60%" alt="28.2"/></center><p>还有一些重要的功能线：</p><ul><li><code>RST</code>：硬件复位。</li><li><code>Vcc</code>：为flash memory供电，和falsh memory与eMMC core的接口I&#x2F;O提供电压。</li><li><code>Vccq</code>：为host接口<strong>I&#x2F;O</strong>提供电压，为<strong>core</strong>提供电压。</li></ul><blockquote><p>注：Vccq一定小于或等于Vcc。</p></blockquote><ul><li><code>Vss，Vssq</code>：<strong>Ground</strong> for supply voltage core and I&#x2F;O</li></ul><h2 id="1-2-Bus-Speed模式"><a href="#1-2-Bus-Speed模式" class="headerlink" title="1.2  Bus Speed模式"></a>1.2  Bus Speed模式</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.3.png" width="70%" height="70%" alt="28.3"/></center><p>可以看到，<code>High speed</code>模式有两种（SDR和DDR）。<code>HS200</code>最大频率达到了200MHz，<code>HS400</code>是前者的两倍。</p><p>为了兼容旧版本的eMMC，在power-on或reset后，会默认进入兼容模式（Backward Compatible Mode）。</p><p>可以通过EXT_CSD[185]——<code>HS_TIMING</code>配置Bus speed模式，<br>                EXT_CSD[183]——<code>BUS_WIDTH</code>配置Bus width和Data Strobe。</p><h2 id="1-3-HS-TIMING-185"><a href="#1-3-HS-TIMING-185" class="headerlink" title="1.3  HS_TIMING[185]"></a>1.3  HS_TIMING[185]</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.4.png" width="90%" height="90%" alt="28.4"/></center><p><strong>bit[3:0]用于设置接口时序：</strong></p><ul><li>0x0：选择backwards compatibility interface timing</li><li>0x1：选择High Speed</li><li>0x2：选择HS200</li><li>0x3：选择HS400</li></ul><h2 id="1-4-BUS-WIDTH-183"><a href="#1-4-BUS-WIDTH-183" class="headerlink" title="1.4  BUS_WIDTH[183]"></a>1.4  BUS_WIDTH[183]</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.5.png" width="90%" height="90%" alt="28.5"/></center><p>HS400是否支持Enhanced Strobe模式，在EXT_CSD[184]——<code>STROBE_SUPPORT</code>中定义，0x1&#x3D;支持，0x0&#x3D;不支持。</p><p><strong>bit[3:0]用于设置总线的宽度：</strong></p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.6.png" width="85%" height="85%" alt="28.6"/></center><h1 id="二、选择high-speed-mode"><a href="#二、选择high-speed-mode" class="headerlink" title="二、选择high-speed mode"></a>二、选择high-speed mode</h1><p>见协议附录A.6.2，在eMMC设备BUS初始化完成后，通过如下步骤切换BUS mode为high-speed mode。参考Data transfer diagram。</p><ul><li>发送CMD7（带RCA）将设备切换到tran-state。</li><li>发送CMD8（SEND_EXT_CSD）。</li><li>发送<code>CMD6（SWITCH）</code>修改<code>HS_TIMING</code>。参数为<code>0x03B9_0100</code>即可。</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.7.png" width="75%" height="75%" alt="28.7"/></center>    <ul><li>修改clock frequency为high-speed mode支持的范围（0-52MHz）。</li></ul><h1 id="三、选择”HS200“-mode"><a href="#三、选择”HS200“-mode" class="headerlink" title="三、选择”HS200“ mode"></a>三、选择”HS200“ mode</h1><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.8.png" width="70%" height="70%" alt="28.8"/></center><h1 id="四、选择“HS400”-mode"><a href="#四、选择“HS400”-mode" class="headerlink" title="四、选择“HS400” mode"></a>四、选择“HS400” mode</h1><p>HS400有两种模式，tuning模式和Enhanced Strobe，它们的启动流程分别如下：</p><h2 id="4-1-需要Tuning-procedure的HS400"><a href="#4-1-需要Tuning-procedure的HS400" class="headerlink" title="4.1  需要Tuning procedure的HS400"></a>4.1  需要Tuning procedure的HS400</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.9.png" width="65%" height="65%" alt="28.9"/></center><ul><li>1、初始化设备后进入的是”Backward Compatible Timings“，这时发送<code>CMD7</code>选择设备，再读取<code>DEVICE_TYPE [196]</code>判断是否支持HS400；</li><li>2、读取<code>DRIVER_STRENGTH [197]</code>判断支持的device Driver Strengths，再通过修改<code>HS_TIMING[185]</code>设置HS400的<em><strong>device Driver Strength</strong></em>，并通过<code>0x2</code>将其切换为<em><strong>HS200</strong></em>；</li><li>3、要切换为<code>HS200</code>进行<code>tuning</code> procedure。（<em>因为HS200相对低速，在此模式下进行tuning不容易出错</em>）</li><li>4、再切换为<code>High-speed</code>模式，修改BUS_WIDTH[183]&#x3D;0x06，选择“<code>x8 DDR</code>”bus mode；（<em><strong>为什么？见1.4中规定了</strong></em>）</li><li>5、最后再修改<code>HS_TIMING[185]=0x3</code>，切换成<code>HS400</code>。</li></ul><h2 id="4-2-Enhanced-Strobe模式的HS400"><a href="#4-2-Enhanced-Strobe模式的HS400" class="headerlink" title="4.2  Enhanced Strobe模式的HS400"></a>4.2  Enhanced Strobe模式的HS400</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/28.10.png" width="75%" height="75%" alt="28.10"/></center><p>当使能了Enhanced Strobed就不需要tuning过程了。</p><ul><li>1、初始化设备后进入的是”Backward Compatible Timings“，这时发送<code>CMD7</code>选择设备，再读取<code>DEVICE_TYPE [196]</code>判断是否支持HS400；</li><li>2、读取STROBE_SUPPORT[184]判断是否支持Enhanced Strobe；</li><li>3、切换为<code>High-speed</code>模式（HS_TIMING&#x3D;0x1），频率低于52MHz；修改<code>BUS_WIDTH[183]=0x86</code>，选择“<code>x8 DDR</code>”bus mode；（***这里的0x86是整个BUS_WIDTH byte的值，4.1中第4点0x06是指bit[3:0]***）</li><li>4、最后再修改<code>HS_TIMING[185]=0x3</code>，切换成<code>HS400</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、Bus-Speed-mode介绍（eMMC-5-1）&quot;&gt;&lt;a href=&quot;#一、Bus-Speed-mode介绍（eMMC-5-1）&quot; class=&quot;headerlink&quot; title=&quot;一、Bus Speed mode介绍（eMMC</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>27--eMMC的EXT_CSD和CMD6（SWITCH）</title>
    <link href="https://mkdbook.com/blog027.html"/>
    <id>https://mkdbook.com/blog027.html</id>
    <published>2023-06-24T05:31:24.000Z</published>
    <updated>2023-06-24T05:41:15.919Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、EXT-CSD-整体概述"><a href="#一、EXT-CSD-整体概述" class="headerlink" title="一、EXT_CSD 整体概述"></a>一、EXT_CSD 整体概述</h1><ul><li>EXT_CSD寄存器中定义了<code>设备的属性</code>和<code>模式选择</code>，一共有512个byte。</li><li>320 byte的<code>property segment</code>，192 byte的<code>mode segment</code>。</li><li>属性段<strong>不可</strong>被host端<strong>修改</strong>，里面包括了device支持的mode、容量等信息。</li><li><strong>模式段可</strong>被host段修改，反映了device当前选定的模式，例如选择哪个command set版本。</li><li>host通过发送CMD8（SEND_EXT_CSD）读取EXT_CSD，device会将其EXT_CSD作为一个512byte大小的数据块发送。</li></ul><h1 id="二、CMD6-详细说明"><a href="#二、CMD6-详细说明" class="headerlink" title="二、CMD6 详细说明"></a>二、CMD6 详细说明</h1><p>CMD6（SWITCH）两种功能：1、<code>切换mode</code>；2、<code>修改EXT_CSD</code>； </p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/27.1.png" width="100%" height="75%" alt="27.1"/></center><h2 id="2-1-Cmd-Set-2-0"><a href="#2-1-Cmd-Set-2-0" class="headerlink" title="2.1  Cmd Set[2:0]"></a>2.1  Cmd Set[2:0]</h2><p>host可以发送CMD6改变现在的命令集，在EXT_CSD中有两个byte表征它：<code>S_CMD_SET[504]</code>和<code>CMD_SET[191]</code>。</p><p>前者在属性段中，表示该device支持的command set。后者在模式段中，host可以通过CMD6命令修改。</p><p><code>CMD_SET[191]</code>中<code>Cmd Set[2:0]</code>power_on后默认为0x00，表示standard MMC。</p><p>然而，如果是通过CMD6将command set版本修改为standard MMC，则<code>CMD_SET[191]</code>中<code>Cmd Set[2:0]</code>应设置为0x01。</p><h2 id="2-2-Index-23-16"><a href="#2-2-Index-23-16" class="headerlink" title="2.2  Index[23:16]"></a>2.2  Index[23:16]</h2><p>索引虽然可以包含0-255数值，但是<code>只有0-191有效</code>，因为EXT_CSD只有192个byte（mode段）可被修改。</p><h2 id="2-3-Access-25-24"><a href="#2-3-Access-25-24" class="headerlink" title="2.3  Access[25:24]"></a>2.3  Access[25:24]</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/27.2.png" width="100%" height="75%" alt="27.2"/></center><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4  总结"></a>2.4  总结</h2><ul><li>1、如果CMD6用于更改命令集，<code>[23:16]Index</code>和<code>[15:8]Value</code>会被忽略，EXT_CSD不会被写。<code>[25:24]Access</code>为00，根据<code>[2:0]Cmd Set</code>修改命令集。</li><li>2、如果CMD用于写EXT_CSD，<code>[2:0]Cmd Set</code>会被忽略，命令集保持不变。根据<code>[25:24]Access</code>中的访问模式，将<code>[15:8]Value</code>中的值，修改到<code>[23:16]Index</code>指向的EXT_CSD byte中。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、EXT-CSD-整体概述&quot;&gt;&lt;a href=&quot;#一、EXT-CSD-整体概述&quot; class=&quot;headerlink&quot; title=&quot;一、EXT_CSD 整体概述&quot;&gt;&lt;/a&gt;一、EXT_CSD 整体概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;EXT</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>26--eMMC的Data transfer mode</title>
    <link href="https://mkdbook.com/blog026.html"/>
    <id>https://mkdbook.com/blog026.html</id>
    <published>2023-06-24T05:17:24.000Z</published>
    <updated>2023-06-24T05:29:31.078Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>device identification之后，<code>CMD3</code>生效，device进入<code>Stand-by State</code>。Data transfer mode下，device总共有8种状态，每种状态下涉及的相关命令如下。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/26.1.png" width="100%" height="75%" alt="25.1"/></center><h1 id="一、Sleep-状态"><a href="#一、Sleep-状态" class="headerlink" title="一、Sleep 状态"></a>一、Sleep 状态</h1><ul><li>CMD5：<code>SLEEP_AWAKE</code>  切换sleep和awake模式</li></ul><h1 id="二、Stand-by-状态"><a href="#二、Stand-by-状态" class="headerlink" title="二、Stand-by 状态"></a>二、Stand-by 状态</h1><ul><li><p>1、CMD4：<code>SET_DSR</code>  编程DSR寄存器，使其与应用中的bus length和data transfer frequency相对应。</p></li><li><p>2、CMD9：<code>SEND_CSD</code>  被寻址的设备在CMD线上发送其CSD寄存器内容。如block长度，设备存储容量、最大时钟速率等。</p></li><li><p>3、CMD10：<code>SEND_CID</code>  被寻址的设备在CMD线上发送其CID寄存器内容。</p></li><li><p>4、CMD39：<code>FAST_IO</code></p></li><li><p>5、CMD5：<code>SLEEP_AWAKE</code>  切换sleep和awake模式</p></li><li><p>6、CMD40：<code>GO_IRQ_STATE</code>  进入interrupt模式</p></li><li><p>7、CMD7：<code>SELECT/DESELECT_CARD</code>  切换 <em><strong>Stand-By状态——&gt;Transfer状态</strong></em>；</p></li></ul><h1 id="三、Transfer-状态"><a href="#三、Transfer-状态" class="headerlink" title="三、Transfer 状态"></a>三、Transfer 状态</h1><h2 id="1-读取一些数据-Transfer-State——-gt-Sending-data-State"><a href="#1-读取一些数据-Transfer-State——-gt-Sending-data-State" class="headerlink" title="1  读取一些数据  Transfer State——&gt;Sending-data State"></a>1  读取一些数据  Transfer State——&gt;Sending-data State</h2><ul><li>1、CMD8：<code>SEND_EXT_CSD</code>  设备将其EXT_CSD作为一个数据块发送</li><li>2、<strong>CMD17</strong>：<code>READ_SINGLE_ BLOCK</code></li><li>3、<strong>CMD18</strong>：<code>READ_MULTIPLE_ BLOCK</code></li><li>4、<strong>CMD21</strong>：<code>SEND_TUNING_ BLOCK</code>  为优化 HS200 采样点发送 128 时钟的tuning pattern （4-bit 下 64 字节，8-bit 下128 字节）</li><li>5、<strong>CMD30</strong>：<code>SEND_WRITE_PROT</code>  send write protect</li><li>6、CMD31：<code>SEND_WRITE_PROT _TYPE</code>  写保护相关</li><li>7、CMD46：<code>EXECUTE_READ_TASK</code>  设备应该执行队列中的这些task，它们的ID在参数中已经被编码了</li><li>8、CMD53：<code>PROTOCOL_RD</code></li><li>9、CMD56：<code>GEN_CMD（r）</code></li><li><strong>CMD12</strong>：<code>STOP_TRANSMISSION</code>  ，所有的data read命令都能在任何时刻被CMD12打断，data transfer被终止，设备返回Transfer状态。data read命令包括：CMD17、18、21、30</li></ul><h2 id="2-设置读、写、擦除的一些参数-Transfer-State——-gt-Transfer-State"><a href="#2-设置读、写、擦除的一些参数-Transfer-State——-gt-Transfer-State" class="headerlink" title="2  设置读、写、擦除的一些参数  Transfer State——&gt;Transfer State"></a>2  设置读、写、擦除的一些参数  Transfer State——&gt;Transfer State</h2><ul><li>1、CMD16：SET_BLOCKLEN</li><li>2、CMD23：SET_BLOCK_COUNT</li><li>3、CMD35：ERASE_GROUP_START</li><li>4、CMD36：ERASE_GROUP_END</li><li>5、CMD44：QUEUED_TASK_PARAMS</li><li>6、CMD45：QUEUED_TASK_ADDRESS</li></ul><h2 id="3-写一些数据-Transfer-State——-gt-Receive-data-State"><a href="#3-写一些数据-Transfer-State——-gt-Receive-data-State" class="headerlink" title="3  写一些数据  Transfer State——&gt;Receive-data State"></a>3  写一些数据  Transfer State——&gt;Receive-data State</h2><ul><li>1、<strong>CMD24</strong>：WRITE_BLOCK</li><li>2、<strong>CMD25</strong>：WRITE_MULTIPLE_ BLOCK</li><li>3、<strong>CMD26</strong>：PROGRAM_CID</li><li>4、<strong>CMD27</strong>：PROGRAM_CSD</li><li>5、CMD42： LOCK_UNLOCK</li><li>6、CMD47：EXECUTE_WRITE _TASK</li><li>7、CMD49：SET_TIME</li><li>8、CMD54：PROTOCOL_WR</li><li>9、CMD56：<code>GEN_CMD（w）</code></li><li><strong>CMD12</strong>：<code>STOP_TRANSMISSION</code>  ，所有的data write命令都能在任何时刻被CMD12打断，但data write命令必须在CMD7（取消设备选定）之前停止。data write命令包括：CMD24、25、26、27</li></ul><h2 id="4-Transfer-State——-gt-Programming-State"><a href="#4-Transfer-State——-gt-Programming-State" class="headerlink" title="4  Transfer State——&gt;Programming State"></a>4  Transfer State——&gt;Programming State</h2><ul><li>1、CMD6：<code>SWITCH</code>  切换所选设备的工作模式或都带EXT_CSD。</li><li>2、CMD28：<code>SET_WRITE_PROT</code></li><li>3、CMD29：<code>CLR_WRITE_PROT</code>  clear write protect</li><li>4、CMD38：<code>ERASE</code></li><li>5、CMD48：<code>CMDQ_TASK_MGMT</code></li></ul><h2 id="5-Transfer-State——-gt-Bus-test-State"><a href="#5-Transfer-State——-gt-Bus-test-State" class="headerlink" title="5  Transfer State——&gt;Bus-test State"></a>5  Transfer State——&gt;Bus-test State</h2><ul><li>CMD19：<code>BUSTEST_W</code>  host向设备发送the bus test data pattern</li></ul><h2 id="6-Transfer-State——-gt-Stand-by-State"><a href="#6-Transfer-State——-gt-Stand-by-State" class="headerlink" title="6  Transfer State——&gt;Stand-by State"></a>6  Transfer State——&gt;Stand-by State</h2><ul><li>CMD7：<code>SELECT/DESELECT_CARD</code>  切换 <em><strong>Stand-By状态&lt;——Transfer状态</strong></em>；</li></ul><h1 id="四、Programming-状态"><a href="#四、Programming-状态" class="headerlink" title="四、Programming 状态"></a>四、Programming 状态</h1><ul><li>1、操作完成后返回Transfer State</li><li>2、CMD24、CMD25进入Receive-data State</li><li>3、一些命令可以中断program：CMD12、13，CMD44、45</li><li>4、CMD7：<code>SELECT/DESELECT_CARD</code>  切 换 <em><strong>Disconnect状态&lt;——Programming状态</strong></em>；</li></ul><h1 id="五、Sending-data-状态"><a href="#五、Sending-data-状态" class="headerlink" title="五、Sending-data 状态"></a>五、Sending-data 状态</h1><ul><li>1、CMD12，或操作完成后返回Transfer State</li><li>2、接收CMD44、45</li></ul><h1 id="六、Receive-data-状态"><a href="#六、Receive-data-状态" class="headerlink" title="六、Receive-data 状态"></a>六、Receive-data 状态</h1><ul><li>1、CMD12，或传输完成后返回Transfer State</li><li>2、接收CMD44、45</li></ul><h1 id="七、Bus-test-状态"><a href="#七、Bus-test-状态" class="headerlink" title="七、Bus-test 状态"></a>七、Bus-test 状态</h1><ul><li>CMD14：<code>BUSTEST_R</code>  host从设备中读取the reversed bus testing data pattern</li></ul><h1 id="八、Disconnect-状态"><a href="#八、Disconnect-状态" class="headerlink" title="八、Disconnect 状态"></a>八、Disconnect 状态</h1><ul><li>1、操作完成后返回Stand-by State</li><li>2、CMD7：<code>SELECT/DESELECT_CARD</code>  切换 <em><strong>Disconnect状态——&gt;Programming状态</strong></em>；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;device identification之后，&lt;code&gt;CMD3&lt;/code&gt;生效，device进入&lt;code&gt;Stand-by State&lt;/code&gt;。Data transfer mode下，device总共有8种状态，每种状态下涉及的相关</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>25--eMMC的Device identification mode</title>
    <link href="https://mkdbook.com/blog025.html"/>
    <id>https://mkdbook.com/blog025.html</id>
    <published>2023-06-24T04:56:04.000Z</published>
    <updated>2023-06-24T05:16:11.650Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、进入Device-identification-mode流程"><a href="#一、进入Device-identification-mode流程" class="headerlink" title="一、进入Device identification mode流程"></a>一、进入Device identification mode流程</h1><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/25.1.png" width="80%" height="75%" alt="25.1"/></center><ul><li>1、power-on后进入Idle State，或通过发送<strong>CMD0</strong>（0x00000000）；</li><li>2、请求处于Idle State中device的<code>OCR</code>内容：host通过发送<strong>CMD1</strong>，接收来自device的反馈；<br>若CMD1应答中<strong>没有“busy bit”（<em>OCR[31]为高时</em>）</strong>，该device则进入<code>Ready State</code>；</li><li>3、请求处于Ready State中device的<code>CID</code>内容：通过<strong>CMD2</strong>；</li><li>5、进入<code>Identification State</code>：当<strong>CMD2应答的device CID编号和host请求的device CID编号一致</strong>时；</li><li>6、给选中的device赋予一个<code>RCA</code>地址：通过<strong>CMD3</strong>；</li><li>7、最后完成identification进程，device进入Stand-by State，之后在数据传输模式中就会通过RCA地址寻址相应设备。</li></ul><h1 id="二、OCR寄存器的内容"><a href="#二、OCR寄存器的内容" class="headerlink" title="二、OCR寄存器的内容"></a>二、OCR寄存器的内容</h1><p>Operation condition register，表明了device的<code>Vdd电压</code>配置和<code>访问模式</code>。</p><p>还有一个<code>状态bit[31]</code>，当上电完成后此位为1。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/25.2.png" width="75%" height="75%" alt="25.2"/></center><p>此寄存器作为CMD1的应答发送给host，host如果支持sector access mode，CMD1的arg应该在<code>bit[30:29]</code>表明。</p><h1 id="三、CID寄存器"><a href="#三、CID寄存器" class="headerlink" title="三、CID寄存器"></a>三、CID寄存器</h1><p>Device IDentification register，保证了在<code>设备识别阶段</code>每一个设备都有独一无二的设备识别号。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/25.3.png" width="80%" height="75%" alt="25.3"/></center><h1 id="四、RCA寄存器"><a href="#四、RCA寄存器" class="headerlink" title="四、RCA寄存器"></a>四、RCA寄存器</h1><p>Relative device address register，携带着<code>设备识别阶段</code>host分配给识别到的device的相对地址，此地址用于device identification mode之后<code>host&lt;——&gt;device通讯</code>。</p><p>默认值为0x0001，值 0x0000 是为将所有设备以 CMD7 置于 Stand-by 状态而保留的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、进入Device-identification-mode流程&quot;&gt;&lt;a href=&quot;#一、进入Device-identification-mode流程&quot; class=&quot;headerlink&quot; title=&quot;一、进入Device iden</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>24--SVA语法速查</title>
    <link href="https://mkdbook.com/blog024.html"/>
    <id>https://mkdbook.com/blog024.html</id>
    <published>2023-04-28T03:01:34.000Z</published>
    <updated>2023-04-28T03:51:42.745Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、内嵌函数"><a href="#一、内嵌函数" class="headerlink" title="一、内嵌函数"></a>一、内嵌函数</h1><h2 id="1-1-rose"><a href="#1-1-rose" class="headerlink" title="1.1  $rose"></a>1.1  $rose</h2><p>信号&#x2F;表达式的<code>LSB</code><strong>跳变</strong>为<code>1</code>，返回真</p><h2 id="1-2-fell"><a href="#1-2-fell" class="headerlink" title="1.2  $fell"></a>1.2  $fell</h2><p>信号&#x2F;表达式的<code>LSB</code><strong>跳变</strong>为<code>0</code>，返回真</p><h2 id="1-3-stable"><a href="#1-3-stable" class="headerlink" title="1.3  $stable"></a>1.3  $stable</h2><p>信号&#x2F;表达式的值保持<code>不变</code>，返回真</p><h2 id="1-4-past"><a href="#1-4-past" class="headerlink" title="1.4  $past"></a>1.4  $past</h2><p>若<code>(c&amp;&amp;d)</code>为真，<code>2</code>个周期前<code>(a&amp;&amp;b)</code>必须为真。默认1个周期。</p><pre><code class="verilog">@(posedge clk)  (c&amp;&amp;d) |-&gt; ($past ( (a&amp;&amp;b) , 2 ) == 1);</code></pre><h3 id="例1：32bit的data-bus，需要检测它在dAck信号为1时，全部bit位跳变为0。"><a href="#例1：32bit的data-bus，需要检测它在dAck信号为1时，全部bit位跳变为0。" class="headerlink" title="例1：32bit的data bus，需要检测它在dAck信号为1时，全部bit位跳变为0。"></a>例1：32bit的data bus，需要检测它在dAck信号为1时，<code>全部bit位跳变为0</code>。</h3><pre><code class="verilog">//$fell只能检测LSB的跳变，不能得到所有信号都变为0的结论aAck |-&gt; $fell(dBus);//用$past：dBus在dAck信号前一个周期不为零，现在全为0了dAck |-&gt; ($past(dBus)!=32&#39;b0) &amp;&amp; (dBus==32&#39;0);</code></pre><h2 id="1-5-onehat"><a href="#1-5-onehat" class="headerlink" title="1.5   $onehat"></a>1.5   $onehat</h2><p>在任意给定的时钟沿，表达式<code>只有1个bit位为高</code>。</p><h2 id="1-6-onehat0"><a href="#1-6-onehat0" class="headerlink" title="1.6  $onehat0"></a>1.6  $onehat0</h2><p>在任意给定的时钟沿，表达式<code>只有1个bit位为高</code>，或者<code>没有任何bit位为高</code>。</p><h2 id="1-7-isunknow"><a href="#1-7-isunknow" class="headerlink" title="1.7  $isunknow"></a>1.7  $isunknow</h2><p>检验表达式的任何bit位，是否是<code>X或Z</code>。</p><h2 id="1-8-countones"><a href="#1-8-countones" class="headerlink" title="1.8  $countones"></a>1.8  $countones</h2><p><code>计算</code>向量中为<code>高</code>的<code>位</code>的<code>数量</code>。</p><pre><code class="verilog">a33a: assert             property(@(posedge clk) $onehot(state)); a33b: assert             property(@(posedge clk) $onehotO(state)); a33c: assert             property(@(posedge clk) $isunkiiovm(bus) ) ; a33d: assert             property(@(posedge clk)$countones(bus)&gt; 1);</code></pre><p>具体结果如下图所示：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/24.1.png" width="75%" height="75%" alt="24.1"/></center><h1 id="二、操作符"><a href="#二、操作符" class="headerlink" title="二、操作符"></a>二、操作符</h1><h2 id="2-1-m-时钟延迟"><a href="#2-1-m-时钟延迟" class="headerlink" title="2.1  ##m 时钟延迟"></a>2.1  ##m 时钟延迟</h2><p>@(posdege clk) <code>a ##2 b;</code>，a高电平两个周期后b为高电平</p><p>m可为0，表示a、b同时为高 ，可用于同一clk沿降时同时发生这两个事件</p><h2 id="2-2-m-n"><a href="#2-2-m-n" class="headerlink" title="2.2  ##[m:n]"></a>2.2  ##[m:n]</h2><p>范围内即可</p><h2 id="2-3-m-重复，连续"><a href="#2-3-m-重复，连续" class="headerlink" title="2.3  [*m]  重复，连续"></a>2.3  [*m]  重复，连续</h2><p><code>@(posdege clk) a ##1 b[*2];</code>，a高电平1个周期后，b高电平维持两个周期（连续两个clk采样到高）</p><h2 id="2-4-m-n"><a href="#2-4-m-n" class="headerlink" title="2.4  [*m:n]"></a>2.4  [*m:n]</h2><p>范围内即可</p><h2 id="2-5-x3D-m-重复，不连续"><a href="#2-5-x3D-m-重复，不连续" class="headerlink" title="2.5  [&#x3D;m]  重复，不连续"></a>2.5  [&#x3D;m]  重复，不连续</h2><p><code>@(posdege clk) a |=&gt; b [=2] ##1 c;</code>，a ture1个周期后，b只要匹配到两个周期ture就可以了，<code>下个周期后只要c为ture就行</code>（即：c前有两个b成功就可）</p><h2 id="2-6-x3D-m-n"><a href="#2-6-x3D-m-n" class="headerlink" title="2.6  [&#x3D;m:n]"></a>2.6  [&#x3D;m:n]</h2><p>范围内即可</p><h2 id="2-7-gt-m-GoTo重复，不连续"><a href="#2-7-gt-m-GoTo重复，不连续" class="headerlink" title="2.7  [-&gt;m]  GoTo重复，不连续"></a>2.7  [-&gt;m]  GoTo重复，不连续</h2><p><code>@(posdege clk)a |=&gt; b [=2] ##1 c;</code>a ture 1个周期后，b只要匹配到两个周期ture就可以了，<code>下个周期c必须为ture</code>（即：c前必须有一次b成功挨着）</p><h2 id="2-8-gt-m-n"><a href="#2-8-gt-m-n" class="headerlink" title="2.8  [-&gt;m:n]"></a>2.8  [-&gt;m:n]</h2><p>范围内即可</p><h2 id="2-9-sig1-“throughout”-seq1"><a href="#2-9-sig1-“throughout”-seq1" class="headerlink" title="2.9  sig1 “throughout” seq1"></a>2.9  sig1 “throughout” seq1</h2><p>信号1在序列1检测过程中，必须一直为真</p><h3 id="例2、在整个检验过程中，start信号保持为低电平"><a href="#例2、在整个检验过程中，start信号保持为低电平" class="headerlink" title="例2、在整个检验过程中，start信号保持为低电平"></a>例2、<strong>在整个检验过程中，start信号保持为低电平</strong></h3><pre><code class="verilog">property p31;     ©&#123;posedge clk) $fell(start) |-&gt;                                     (!start) throughout                                     (##1 (!a&amp;&amp;!b) ##1 (c[-&gt;3]) ##1 (a&amp;&amp;b)); endproperty a31: assert property(p31);//1、在clk上升沿检测到 start 下降沿后开始检测//2、……//3、……//4、在整个检验过程中，start信号保持为低电平</code></pre><h2 id="2-10-seq1-“within”-seq2"><a href="#2-10-seq1-“within”-seq2" class="headerlink" title="2.10  seq1 “within” seq2"></a>2.10  seq1 “within” seq2</h2><p>在一个序列中定义另一个序列，<code>seq1</code>必须在<code>seq2</code>的过程中发生，即<code>seq2</code>的<code>开始</code>匹配点必须在<code>seq1之前</code>，<code>seq1</code>的<code>结束</code>匹配点必须在<code>seq2之前</code>结束。</p><h2 id="2-11-seq1-”and“-seq2"><a href="#2-11-seq1-”and“-seq2" class="headerlink" title="2.11  seq1 ”and“ seq2"></a>2.11  seq1 ”and“ seq2</h2><p>当两个sequence都成功时，整个property才成功。</p><h2 id="2-12-seq1-“or”-seq2"><a href="#2-12-seq1-“or”-seq2" class="headerlink" title="2.12  seq1 “or” seq2"></a>2.12  seq1 “or” seq2</h2><p>只要其中一个sequence成功，整个property才成功</p><h2 id="2-13-seq1-“intersect”-seq2"><a href="#2-13-seq1-“intersect”-seq2" class="headerlink" title="2.13  seq1 “intersect” seq2"></a>2.13  seq1 “intersect” seq2</h2><p>和<code>and</code>类似，区别是：两个sequence必须<strong>在相同时刻开始</strong>，且<strong>结束于同一时刻</strong>。即<code>seq1</code>和<code>seq2</code>长度必须相等。</p><h2 id="2-14-first-match"><a href="#2-14-first-match" class="headerlink" title="2.14  first_match"></a>2.14  first_match</h2><pre><code class="verilog">module assertion_example;  bit clk, a, b, c;    always #1 clk = ~clk;    sequence s1;    first_match(a ##[1:2] b);  endsequence  sequence s2;       a ##[1:2] b;  endsequence  property p1;    @(posedge clk) s1 |-&gt; c;  endproperty  property p2;    @(posedge clk) s2 |-&gt; c;  endproperty   a1: assert property(p1) $display(&quot;%t, success a1\n&quot;, $time); else $error(&quot;Assertion a1 failed!\n&quot;);a2: assert property(p2) $display(&quot;%t, success a2\n&quot;, $time); else $error(&quot;Assertion a2 failed!\n&quot;);      initial begin    a = 0;    b = 0;    c = 1;fork    fork //a      #2 a=1;      #4 a=0;      #8 a=1;    join    fork //b      #2 b=1;      #4 b=0;      #8 b=1;    joinjoin    #20; $finish;  endendmodule</code></pre><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/24.2.png" width="75%" height="75%" alt="24.2"/></center><p> <code>a ##[1:2] b</code>，如果没有<code>|-&gt;</code>或者<code>|=&gt;</code>时，则匹配一次即可进入下一阶段或者断言成功，但是<strong>如果有|-&gt;或者|&#x3D;&gt;时，则必须保证所有情况都满足才能进入下一阶段</strong>，否则卡死。</p><p><code>first_match</code>的作用就是，使得只要出现一种满足情况即可进入下一阶段。</p><p>如图可看到，加了<code>first_match</code>的p1，匹配了1个周期就开始匹配c了；而p2这完成了匹配1、2周期这两项，才进行c的匹配。</p><h2 id="2-15-not"><a href="#2-15-not" class="headerlink" title="2.15  not "></a>2.15  not <property expr></h2><p>禁止属性，当property不成立时，断言为真。用于我们期望property永远为假的情况。</p><h2 id="2-16-ended-和-matched-结构"><a href="#2-16-ended-和-matched-结构" class="headerlink" title="2.16  .ended 和 .matched  结构"></a>2.16  .ended 和 .matched  结构</h2><p>区别：<code>.end</code>要求两个sequence拥有<strong>同一个</strong>clk， <code>.matched</code>允许两个sequence<strong>不同的</strong>clk。</p><p>作用：匹配一个sequence的结束，如果sequence成功匹配并结束，那么<code>.end/.matched</code>为<strong>真</strong>。</p><pre><code class="verilog">sequence s1;     @(posedge clk) a ##1 b; endsequence sequence s2;     @(posedge clk) c ##1 d; endsequence property p1;     s1 |=&gt; s2; endproperty property p2;     s1.ended |-&gt; ##2 s2.ended; endproperty  al: assert property(p1); a2: assert property(p2);</code></pre><p>上面的例子，用两种方法都是检查了一个 <code>a ##1 b ##1 c ##1 d</code> 序列，</p><p>如下图真值表，上面代码中的<code>a1</code>和<code>a2</code> 断言都匹配的是<strong>周期2-5</strong>。只是<code>a1</code>是匹配的开始，<code>a2</code>是匹配的<code>s1和s2</code>的结尾。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/24.3.png" width="75%" height="75%" alt="24.3"/></center><h2 id="2-17-expect-构造——（assert语句层面）"><a href="#2-17-expect-构造——（assert语句层面）" class="headerlink" title="2.17  expect  构造——（assert语句层面）"></a>2.17  expect  构造——（assert语句层面）</h2><p>expect相当于Verilog中的wait，只能用于procedural block中，有阻塞作用</p><pre><code class="verilog">initial begin     @(posedge clk);     #2ns cpu_ready = 1&#39;b1;     expect(@(posedge clk) ##[1:16] memory_ready == 1&#39;b1)                 $display(&quot;Hand shake successful\n&quot;);         else begin                 $display(&quot;Hand shake failed: exiting\n&quot;)                 $finish();         end //如果expect中memory_ready断言失败，后面这段被阻塞，不会执行    for(i=0; i&lt;64; i++)         begin         send_packet();         $display(&quot;PACKET %0d sent\n&quot;, i);         end end</code></pre><h2 id="2-18-disable-iff"><a href="#2-18-disable-iff" class="headerlink" title="2.18  disable iff"></a>2.18  disable iff</h2><p>1、只能用于property，不能用于sequence。</p><p>2、只能声明在先行算子（antecedent condition）之前。</p><pre><code class="verilog">property p34;     @(posedge clk)     disable iff (reset)//当reset信号为高时，后续断言不会执行     $rose&#123;start) |=&gt; a[=2] ##1 b[=2] ##1 !start endproperty a34: assert property(p34);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、内嵌函数&quot;&gt;&lt;a href=&quot;#一、内嵌函数&quot; class=&quot;headerlink&quot; title=&quot;一、内嵌函数&quot;&gt;&lt;/a&gt;一、内嵌函数&lt;/h1&gt;&lt;h2 id=&quot;1-1-rose&quot;&gt;&lt;a href=&quot;#1-1-rose&quot; class=</summary>
      
    
    
    
    <category term="语言" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="SystemVerilog" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/SystemVerilog/"/>
    
    
    <category term="SVA" scheme="https://mkdbook.com/tags/SVA/"/>
    
  </entry>
  
  <entry>
    <title>23--SVA简介</title>
    <link href="https://mkdbook.com/blog023.html"/>
    <id>https://mkdbook.com/blog023.html</id>
    <published>2023-04-28T03:00:31.000Z</published>
    <updated>2023-04-28T03:22:25.748Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、SVA基本结构"><a href="#一、SVA基本结构" class="headerlink" title="一、SVA基本结构"></a>一、SVA基本结构</h1><p>基本结构包含三个部分，</p><p><code>sequence块</code>：事件。</p><p><code>property块</code>：组合sequence事件形成一个复杂的逻辑行为。</p><p><code>assert/cover关键词</code>：调用property进行判断。</p><pre><code class="systemverilog">//序列中定义事件sequence s1;    a ##2 b;endsequence//属性中调用序列property p1;    @(posedge clk) s1;endsequence//关键词收集属性a1: assert property(p1);c1: cover property(p1);//--------可写在一起----------assert property (@(posedge clk) a ##2 b);</code></pre><p>为了复用性建议分开写，时钟写在property中。个人觉得如果写在代码中只对当前位置进行断言检查，写在一起更为简便。</p><h1 id="二、关键词，assert、cover"><a href="#二、关键词，assert、cover" class="headerlink" title="二、关键词，assert、cover"></a>二、关键词，assert、cover</h1><p><code>assert</code>：property必须一直都是ture。换句话说，忽略PASS，检测Failure。</p><p><code>cover</code>：可统计成功了多少次。换句话说，忽略Failure，有一次成功这个property就算成功。</p><p>区别：‘assert’ checks for failures in your design and ‘cover’ sees if the property did get exercised.</p><blockquote><p>功能覆盖率是按照设计规范衡量验证状态的一个标准，可以分为两类：<br>（1）<code>protocol coverage</code>——specification中所有功能是否都测试过，<br>（2）<code>Test plan coverage</code>——衡量Testbench的穷尽性，例如是否覆盖所有地址。</p></blockquote><p>故，<code>cover</code>语句可以用来获取<code>protocol coverage</code>，结果包含以下信息：</p><ol><li>property<strong>被尝试</strong>检验的次数</li><li>property<strong>成功</strong>的次数</li><li>property<strong>失败</strong>的次数</li><li>property<strong>空成功</strong>的次数</li></ol><h1 id="三、断言位置"><a href="#三、断言位置" class="headerlink" title="三、断言位置"></a>三、断言位置</h1><p>有两种方法将SVA checker连到model中；</p><p>1、内嵌或者直接写在model中；</p><p>2、<code>将SVA checker写成一个独立的model</code>，然后通过<code>bind</code>关键词，将其连接到model；</p><p>bind使用方法：<code>bind &lt;设计model或例化的model&gt; &lt;SVA checker model&gt; &lt;SVA checker例化名&gt; (信号接入);</code></p><pre><code class="systemverilog">module nand_checker;.....断言.....endmodule// bind绑定语句在SVA模块外部bind tb nand_checker U_A (.*);// 相当于SVA模块例化在了tb模块中，与uut平行，结构更清楚// .* 的前提是例化的所有端口类型，名字都相同</code></pre><h1 id="四、关于SVA断言和Verification"><a href="#四、关于SVA断言和Verification" class="headerlink" title="四、关于SVA断言和Verification"></a>四、关于SVA断言和Verification</h1><ol><li><p>SVA可以对硬件设计的<code>期望行为进行编码</code>，可以创建对总线协议的详细检查。</p></li><li><p>Testbech一般包括三项任务：（1）<code>产生激励</code>；（2）<code>自检机制</code>；（3）<code>衡量功能覆盖率</code>；</p> <center> <img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/23.1.png" width="75%" height="75%" alt="23.1"/> </center> </li><li><p><strong>自检</strong>通常着眼两个方面：<br>（1）<code>协议检验</code>——目标是控制信号，控制信号的正确性是验证设计的核心；<br>（2）<code>数据检验</code>——目的是检验正在处理的数据的完整性，如数据包在传输过程中是否损坏；</p></li><li><p>SVA主要解决两类问题：<br>（1）<code>Protocol checking</code>；<br>（2）<code>Protocol coverage</code>；</p> <center> <img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/23.2.png" width="75%" height="75%" alt="23.2"/> </center></li></ol><ul><li>SystemVerilog语言包含4个不同子集：<br>（1）SystemVerilog Object Oriented language for <code>functional verification</code> (using OVM&#x2F;UVM style libraries)<br>（2）SystemVerilog language for <code>Design</code><br>（3）SystemVerilog Assertions <code>(SVA)</code> language<br>（4）SystemVerilog <code>Functional Coverage (FC)</code> Language to see that <strong>the verification environment&#x2F;test-bench have fully verified your design.</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、SVA基本结构&quot;&gt;&lt;a href=&quot;#一、SVA基本结构&quot; class=&quot;headerlink&quot; title=&quot;一、SVA基本结构&quot;&gt;&lt;/a&gt;一、SVA基本结构&lt;/h1&gt;&lt;p&gt;基本结构包含三个部分，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sequ</summary>
      
    
    
    
    <category term="语言" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="SystemVerilog" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/SystemVerilog/"/>
    
    
    <category term="SVA" scheme="https://mkdbook.com/tags/SVA/"/>
    
  </entry>
  
  <entry>
    <title>22--eMMC的boot分区</title>
    <link href="https://mkdbook.com/blog022.html"/>
    <id>https://mkdbook.com/blog022.html</id>
    <published>2023-04-28T01:20:32.000Z</published>
    <updated>2023-04-28T02:41:02.656Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、boot分区容量设置"><a href="#一、boot分区容量设置" class="headerlink" title="一、boot分区容量设置"></a>一、boot分区容量设置</h1><p>一共有两个boot分区，每个的大小最小为<code>128KB</code>，计算方法见EXT_CSD[226]，如图22.1所示，最大支持31.875M，一般为4M（即乘以32）：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/22.1.png" width="75%" height="75%" alt="22.1"/></center><h1 id="二、进入boot模式的方法"><a href="#二、进入boot模式的方法" class="headerlink" title="二、进入boot模式的方法"></a>二、进入boot模式的方法</h1><p>上电后，收到<code>CMD0（0xF0F0F0F0）</code>命令或<code>硬件复位</code>信号。</p><h1 id="三、如何从boot分区启动（host从boot分区读取数据）"><a href="#三、如何从boot分区启动（host从boot分区读取数据）" class="headerlink" title="三、如何从boot分区启动（host从boot分区读取数据）"></a>三、如何从boot分区启动（host从boot分区读取数据）</h1><h2 id="3-1-访问boot分区"><a href="#3-1-访问boot分区" class="headerlink" title="3.1  访问boot分区"></a>3.1  访问boot分区</h2><p>在boot模式下，host有两种方法读取eMMC中boot区的数据：</p><p>1、保持<code>CMD line low</code>；</p><p>2、在发<code>CMD1</code>之前，发送<code>CMD0（0xFFFFFFFA）</code>；</p><h2 id="3-2-Original-Boot-Operation"><a href="#3-2-Original-Boot-Operation" class="headerlink" title="3.2  Original Boot Operation"></a>3.2  Original Boot Operation</h2><p>1、<code>power-on</code>或<code>reset</code>（硬件复位或CMD0带0xF0F0F0F0）后，在第一个CMD之前 <em><strong>CMD line被拉低超过74个clock</strong></em>，则设备会识别到original boot 模式，并在内部开始准备引导数据。</p><p>2、引导数据哪里来？（<a href="http://mkdbook.com/blog022.html#:~:text=%E5%9C%A8boot%20mode%E3%80%82-,bit%5B5%3A3%5D,-%E2%80%94%E2%80%94%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8boot">EXT_CSD[179]的bit[5:3]</a>）</p><p>3、引导数据有多大？（<a href="http://mkdbook.com/blog022.html#:~:text=EXT_CSD%5B226%5D%EF%BC%8C%E5%A6%82-,%E5%9B%BE22.1,-%E6%89%80%E7%A4%BA%EF%BC%8C%E6%9C%80%E5%A4%A7">EXT_CSD[226]</a>）</p><p>4、以何种速率和方式传输引导数据？（<a href="http://mkdbook.com/blog022.html#:~:text=22.5%20BOOT_BUS_CONDITIONS-,bit%5B4%3A3%5D,-%E2%80%94%E2%80%94%E8%AF%BB%E5%8F%96boot">EXT_CSD[177]</a>）</p><p>5、设备是否需要给host一个“010”的boot模式确认反馈？（<a href="http://mkdbook.com/blog022.html#:~:text=22.4%20PARTITION_CONFIG-,bit%5B6%5D,-%E2%80%94%E2%80%94CPU%E5%8A%A0%E8%BD%BD">EXT_CSD[179]的bit[6]</a>）</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/22.2Original%20Boot%20Operation.png" width="100%" height="100%" alt="22.2 Original Boot Operation"/></center><p>时序介绍：</p><ul><li>1、<code>CMD line拉低后</code>的1s内，device必须将第一个boot data从DAT line发送给host。在整个数据接收过程中，CMD line都一直保持为低。</li><li>2、如果设置了boot模式的确认反馈，device必须在<code>CMD line拉低</code>的50ms内发送“010”。</li><li>3、host通过<code>拉高CMD line结束</code>boot模式，之后需要在至少56个clock周期后，才能再发送CMD1启动正常的eMMC初始化。</li></ul><h2 id="3-3-Alternative-Boot-Operation"><a href="#3-3-Alternative-Boot-Operation" class="headerlink" title="3.3  Alternative Boot Operation"></a>3.3  Alternative Boot Operation</h2><p>v4.4版本之后的eMMC必须支持Alternative boot operation这种模式。</p><p>1、<code>power-on</code>或<code>reset</code>（硬件复位或CMD0带0xF0F0F0F0）后，再间隔<code>74个clock</code>后（<strong>在CMD line拉低或CMD1发出之前</strong>），<em><strong>host发送CMD0（参数为0xFFFFFFFA）</strong></em>，则设备会识别到Alternative boot 模式，并在内部开始准备引导数据。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/22.3Alternative%20Boot%20Operation.png" width="100%" height="100%" alt="22.3 Alternative Boot Operation"/></center><p>时序介绍：</p><ul><li>1、<code>CMD 0（0xFFFFFFFA）发出后</code>的1s内，device必须将第一个boot data从DAT line发送给host。</li><li>2、如果设置了boot模式的确认反馈，device必须<code>在CMD 0（0xFFFFFFFA）发出后</code>的50ms内发送“010”。</li><li>3、host通过发送<code>CMD 0（RESET：0x00000000）结束</code>boot模式，之后再发送CMD1启动正常的eMMC初始化。（没有56 clock的限制）</li></ul><h1 id="四、boot分区配置"><a href="#四、boot分区配置" class="headerlink" title="四、boot分区配置"></a>四、boot分区配置</h1><p>通过<code>CMD6（SWITCH）</code>改变EXT_CSD[179]中<code>PARTITION_CONFIG</code>的值。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/22.4PARTITION_CONFIG.png" width="80%" height="80%" alt="22.4 PARTITION_CONFIG"/></center><ul><li><strong>bit[6]——CPU加载boot程序时，是否使用ACK</strong><br>0x0：No boot acknowledge send（default）<br>0x1：boot操作期间发送boot应答，eMMC会在host触发boot mode的50ms内，在DAT0上发送一个<code>“010”的Boot ACK</code>给host。host可通过此位，判断是否在boot mode。</li><li><strong>bit[5:3]——是否使用boot功能，使用哪个分区存放的boot程序？</strong><br>0x0：Device not boot enabled（default）<br>0x1：选择boot分区<code>1</code><br>0x2：选择boot分区<code>2</code><br>0x3-0x6：Reserved<br>0x7：选择<code>User area</code>（boot数据也可以存到用户分区中，但不如存到专用boot分区中可靠）</li><li><strong>bit[2:0]——当前访问的是哪个分区，例如选择0x1，将boot程序烧录boot分区1，然后烧录完成后恢复成0x0（正常模式）</strong><br>0x0：No access to boot partition（default）<br>0x1：读写boot分区<code>1</code><br>0x2：读写boot分区<code>2</code><br>0x3：读写<code>RPMB</code>分区<br>0x4：访问GPP1<br>0x5：访问GPP2<br>0x6：访问GPP3<br>0x7：访问GPP4</li></ul><h1 id="五、boot的bus-width和data-access配置"><a href="#五、boot的bus-width和data-access配置" class="headerlink" title="五、boot的bus-width和data-access配置"></a>五、boot的bus-width和data-access配置</h1><p>在boot操作过程中，通过配置EXT_CSD[177]中<code>BOOT_BUS_CONDITIONS</code>。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/22.5BOOT_BUS_CONDITIONS.png" width="80%" height="80%" alt="22.5 BOOT_BUS_CONDITIONS"/></center><ul><li><strong>bit[4:3]——读取boot区数据，选择什么工作模式</strong><br>0x0：SDR+backward compatible timing（default）<br>0x1：SDR+High Speed timing<br>0x2：DDR<br>0x3：Reserved<br>注：<code>HS200和HS400</code>在boot操作中<code>不允许</code></li><li><strong>bit[2]——RESET_BOOT_BUS_CONDITIONS</strong><br>0x0：boot操作结束后，复位到<code>x1，SDR+backward compatible</code>模式（default）<br>0x1：保持<code>BOOT_MODE</code>和<code>BOOT_BUS_WIDTH</code>设置的参数不变</li><li><strong>bit[1:0]——读取boot区数据，选择多宽的bus width</strong><br>0x0：<code>x1（SDR）</code>或 <code>x4（DDR）</code>（default）<br>0x1：<code>x4（SDR/DDR）</code><br>0x2：<code>x8（SDR/DDR）</code><br>0x3：Reserved</li></ul><h2 id="5-1-RESET-BOOT-BUS-CONDITIONS的作用"><a href="#5-1-RESET-BOOT-BUS-CONDITIONS的作用" class="headerlink" title="5.1  RESET_BOOT_BUS_CONDITIONS的作用"></a>5.1  <strong>RESET_BOOT_BUS_CONDITIONS的作用</strong></h2><p>1、上述EXT_CSD[177]中<code>BOOT_BUS_CONDITIONS</code>主要配置了boot 模式下的数据传输模式，但是其他模式下的timing和width模式是通过两个寄存器配置的：EXT_CSD[185]——<code>HS_TIMING</code>和EXT_CSD[183]——<code>BUS_WIDTH</code>。</p><p>2、<code>BOOT_BUS_CONDITIONS</code>是nonvolatile的，<code>HS_TIMING</code>和<code>BUS_WIDTH</code>会在<strong>硬件复位</strong>或<strong>CMD0</strong>后被reset。</p><p>3、<strong>RESET_BOOT_BUS_CONDITIONS的作用：</strong>当设置为0x1时，boot操作完成后，会自动将<code>BOOT_BUS_CONDITIONS</code>设置的模式值，设置到<code>HS_TIMING</code>和<code>BUS_WIDTH</code>中。</p><p>4、这样，通过CMD0退出boot操作后，不会复位<code>HS_TIMING</code>和<code>BUS_WIDTH</code>，但是在其他模式下发送CMD0还是会导致被reset。</p><h1 id="六、Boot分区的写保护配置"><a href="#六、Boot分区的写保护配置" class="headerlink" title="六、Boot分区的写保护配置"></a>六、Boot分区的写保护配置</h1><p>设置分区保护的目的：防止boot区的数据被erase或write。</p><ul><li>两种write protection：<br>1、<code>Permanent</code> write protection：<strong>永久生效</strong>，除非主动关闭才会失效。<br>2、<code>power-on</code> write protection：<strong>掉电</strong>后，写保护功能<strong>失效</strong>，需要每次power-on重新设置。</li></ul><p>通过配置EXT_CSD[173]——<code>BOOT_WP</code>来进行设置，该寄存器介绍如下：</p><blockquote><p><code>bit[0] = B_PWR_WP_EN</code><br>bit[1] &#x3D; B_PWR_WP_SEC_SEL<br><code>bit[2] = B_PERM_WP_EN</code><br>bit[3] &#x3D; B_PERM_WP_SEC_SEL<br>bit[4] &#x3D; <code>B_PERM_WP_DIS</code><br>bit[5] &#x3D; Reserved<br>bit[6] &#x3D; <code>B_PWR_WP_DIS</code><br><strong>bit[7] &#x3D; B_SEC_WP_SEL</strong></p></blockquote><ul><li><p>bit【7】：boot sector write protection select，<br>0x0：bit 【0、2】对两个boot分区都适用，bit【1、3】无作用；<br>0x1：bit 【0、2】仅适用于bit【1、3】分别选择的分区；</p></li><li><p>bit【1】：boot <code>power-on</code> write protection sector select，<br>0x0：若bit【7】为1，bit【0】设置给boot分区1；<br>0x1：若bit【7】为1，bit【0】设置给boot分区2；</p></li><li><p>bit【3】：boot <code>permanent</code> write protection sector select，<br>0x0：若bit【7】为1，bit【2】设置给boot分区1；<br>0x1：若bit【7】为1，bit【2】设置给boot分区2；</p></li><li><p>bit【0】：boot <code>power-on</code> write protection enable，<br>0x0：boot分区没有power-on写保护<br>0x1：有power-on写保护</p></li><li><p>bit【2】：boot <code>permanent</code> write protection enable，<br>0x0：boot分区没有permanent写保护<br>0x1：有permanen写保护</p></li><li><p>bit【4】：boot permanent write protection disabled，<br>0x0：允许bit【2】<br>0x1：禁用</p></li><li><p>bit【6】：boot powe-on write protection disabled，<br>0x0：允许bit【0】<br>0x1：禁用</p></li></ul><p>例子如下图所示：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/22.6boot%E5%8C%BA%E5%86%99%E4%BF%9D%E6%8A%A4%E4%BE%8B%E5%AD%90.png" width="75%" height="75%" alt="22.6 boot区写保护例子"/></center><p>bit【7】为1，bit【1、3】启用；</p><p>bit【1】为0说明将bit【0】赋给boot区1；</p><p>bit【3】为1说明将bit【2】赋给boot区2；</p><p>bit【0、2】都为1，说明boot区1设置了power-on写保护，boot区2设置了permanent写保护。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、boot分区容量设置&quot;&gt;&lt;a href=&quot;#一、boot分区容量设置&quot; class=&quot;headerlink&quot; title=&quot;一、boot分区容量设置&quot;&gt;&lt;/a&gt;一、boot分区容量设置&lt;/h1&gt;&lt;p&gt;一共有两个boot分区，每个的大小</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>21--eMMC的分区设置和分区访问</title>
    <link href="https://mkdbook.com/blog%E7%AC%AC%E5%87%A0%E7%AF%87.html"/>
    <id>https://mkdbook.com/blog%E7%AC%AC%E5%87%A0%E7%AF%87.html</id>
    <published>2023-04-10T07:20:57.000Z</published>
    <updated>2023-04-24T10:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、eMMC分区介绍"><a href="#一、eMMC分区介绍" class="headerlink" title="一、eMMC分区介绍"></a>一、eMMC分区介绍</h1><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/21.1%E5%88%86%E5%8C%BA%E7%A4%BA%E4%BE%8B.png" width="75%" height="75%" alt="21.1 分区示例"/></center><p>eMMC主要有三块大的分区，两个<strong>Boot Area Patition</strong>，一个<strong>RPMB</strong>分区（Replay Protected Memory Block），一块<strong>User Data Area（UDA）。</strong>UDA中可以最多划分出<code>四个General Purpose Patitions</code>，又可以为UDA某一段设置Enhanced属性，成为<code>Enhanced UDA</code>。<br>故最多有8个硬件分区（2 boot分区、1 RPMB分区、1 user分区、4 GPP分区）。</p><h2 id="各个分区的作用："><a href="#各个分区的作用：" class="headerlink" title="各个分区的作用："></a>各个分区的作用：</h2><ul><li><code>Boot分区</code>，主要用于存储Bootloader，为了支持从eMMC启动系统。</li><li><code>RPMB分区</code>，需要身份验证，存储一些防止被篡改或克隆的敏感数据，如设备标识符（MEID）、支付系统的加密密钥等。</li><li><code>GPP分区</code>，用于存储系统和应用数据。功能和UDA相似，因此有些厂商没有此分区。</li><li><code>UDA分区</code>，容量是减去分出的GPP之后的大小，通常是eMMC最大的数据。</li></ul><h1 id="二、分区配置流程"><a href="#二、分区配置流程" class="headerlink" title="二、分区配置流程"></a>二、分区配置流程</h1><ul><li>1、先判断设备是否支持分区。</li><li>2、如果支持，判断host是否要对该分区设置<strong>Enhanced attribute</strong>。</li><li>2.1、如果<strong>需要</strong>设置<strong>ENH attribute</strong>：</li></ul><blockquote><p><code>1、General Purpose Partition的数量</code><br><code>2、General Purpose Partition sizes</code>和enhanced attribute<br> 3、Enhanced User Data Area sizes，start address和enhanced attribute</p></blockquote><ul><li>2.2、如果<strong>不需要</strong>设置<strong>ENH attribute</strong>：</li></ul><blockquote><p><code>1、General Purpose Partition的数量</code><br><code>2、General Purpose Partition sizes</code></p></blockquote><p>3、PARTITIONING_SETTING_COMPLETED置位</p><h2 id="2-1-如何判断是否支持分区"><a href="#2-1-如何判断是否支持分区" class="headerlink" title="2.1  如何判断是否支持分区"></a>2.1  如何判断是否支持分区</h2><p><code>EXT_CSD[160]</code>中<code>PARTITIONING_SUPPORT</code>的bit0，如下图21.2所示：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/21.2.png" width="75%" height="75%" alt="21.2"/></center><p><code>bit[0]</code>表示设备是否支持分区，<code>bit[1]</code>表示分区（partitions and user data area）是否支持Enhance 属性，<code>bit[2]</code>表示设备是否支持extended 分区属性。本协议中规定这三种特性都支持，bit[0-2]&#x3D;1。</p><h2 id="2-2-General-Purpose-Partition的数量-x2F-Size设置"><a href="#2-2-General-Purpose-Partition的数量-x2F-Size设置" class="headerlink" title="2.2  General Purpose Partition的数量&#x2F;Size设置"></a>2.2  General Purpose Partition的数量&#x2F;Size设置</h2><p>EXT_CSD[154:143]的<code>GP_SIZE_MULT_GP0 - GP_SIZE_MULT_GP3</code>，共12个byte。</p><p><code>X</code>表示General Purpose Partition的<code>编号（1-4）</code>，<code>0-2</code>表示设置一个size这个公式的<code>3个因子</code>。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/21.3.png" width="75%" height="75%" alt="21.3"/></center><p>分区Size的计算公式，以及每一个byte代表的意义，如下21.4所示，</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/21.4.png" width="75%" height="75%" alt="21.4"/></center><p>这里有一个疑问：设置此分区的<code>数量</code>（最大4），是否是把分区的Size设置为0，就表示该分区不存在，从而分区数量减一？</p><h2 id="2-3-General-Purpose-Partition的Enh-x2F-EXT属性设置"><a href="#2-3-General-Purpose-Partition的Enh-x2F-EXT属性设置" class="headerlink" title="2.3  General Purpose Partition的Enh&#x2F;EXT属性设置"></a>2.3  General Purpose Partition的Enh&#x2F;EXT属性设置</h2><p>EXT_CSD[156]的<code>PARTITIONS_ATTRIBUTE</code>设置Enh属性（如图21.5），EXT_CSD[53:52]的<code>EXT_PARTITIONS_ATTRIBUTE</code>设置EXT属性（协议p225）。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/21.5.png" width="75%" height="75%" alt="21.5"/></center><h2 id="2-4-Enhanced-User-Data-Area的start-address-x2F-Size设置"><a href="#2-4-Enhanced-User-Data-Area的start-address-x2F-Size设置" class="headerlink" title="2.4  Enhanced User Data Area的start address&#x2F;Size设置"></a>2.4  Enhanced User Data Area的start address&#x2F;Size设置</h2><p>EXT_CSD[139:136]的<code>ENH_START_ADD</code>设置地址，EXT_CSD[142:140]的<code>ENH_SIZE_MULT</code>设置Size。（p220）</p><p>EXT_CSD[156]的<code>PARTITIONS_ATTRIBUTE</code>设置Enh属性（如图21.5）。</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><ul><li><code>General Purpose Partition</code>和<code>User Data Area</code>是两种不同的分区，它们各自设置大小、Enhanced和Extended属性。虽然前者来源于后者。</li><li><code>GPP</code>出厂默认不带，用户可以通过前文所述方法配置（1-4个）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、eMMC分区介绍&quot;&gt;&lt;a href=&quot;#一、eMMC分区介绍&quot; class=&quot;headerlink&quot; title=&quot;一、eMMC分区介绍&quot;&gt;&lt;/a&gt;一、eMMC分区介绍&lt;/h1&gt;&lt;center&gt;
&lt;img src=&quot;https://b</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>20--IMC初级使用教程</title>
    <link href="https://mkdbook.com/blog020.html"/>
    <id>https://mkdbook.com/blog020.html</id>
    <published>2023-04-10T06:18:11.000Z</published>
    <updated>2023-05-08T10:38:00.947Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="IMC收集覆盖率"><a href="#IMC收集覆盖率" class="headerlink" title="IMC收集覆盖率"></a>IMC收集覆盖率</h1><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>类似于Simvision，IMC（Incisive Metrics Center）是Cadence集成在Incisive中的一个用于覆盖率收集、分析、报告的工具。</p><p>踩坑：新版的Cadence工具已经从Incisive升级到了Xcelium，但是Xcelium不再集成IMC工具，因为IMC工具被集成在了新版的vManager工具中。</p><p>另外，由于仿真工具升级的原因，通过Xcelium仿真生成的Coverage Database无法通过Incisive中集成的IMC工具打开。故后续教程基于Incisive 151版本。</p><h1 id="二、IMC的三种启动模式"><a href="#二、IMC的三种启动模式" class="headerlink" title="二、IMC的三种启动模式"></a>二、IMC的三种启动模式</h1><h2 id="1、GUI-modo"><a href="#1、GUI-modo" class="headerlink" title="1、GUI modo"></a>1、GUI modo</h2><p>启动命令：<code>imc -gui</code></p><p><strong>IMC图形化界面。</strong></p><h2 id="2、Interactive-Command-line-modo"><a href="#2、Interactive-Command-line-modo" class="headerlink" title="2、Interactive Command-line modo"></a>2、Interactive Command-line modo</h2><p>启动命令：<code>imc -batch</code></p><p><strong>交互式命令行模式。</strong></p><h2 id="3、Batch-modo"><a href="#3、Batch-modo" class="headerlink" title="3、Batch modo"></a>3、Batch modo</h2><p>启动命令：<code>imc -exec &lt;command_file&gt;</code></p><p><strong>允许执行批量处理脚本或命令并退出，如TCL脚本。</strong></p><h1 id="三、IMC的option"><a href="#三、IMC的option" class="headerlink" title="三、IMC的option"></a>三、IMC的option</h1><p>可通过<code>imc -help</code>命令查询所有option的作用。</p><pre><code class="yaml">-batch                               run in non-gui mode-32bit                               invokes 32 bit executable-64bit                               invokes 64 bit executable-appendkey                           append keystrokes to an existing keyfile-appendlog                           append the log to an existing logfile-context                             specify application context-df                                  use default font-display &lt;arg&gt;                       display (and screen) on which to display window-enc                                 set input encoding-exec &lt;script name&gt;                  execute a script and exit-execcmd &lt;command&gt;                   execute the given tcl commands and exit-filter                              apply changes on the main table in the Regression Center-gui                                 run in gui mode-help                                print this message-init &lt;file&gt;                         run tcl commands in the given file at startup-initcmd &lt;command&gt;                   execute the given tcl commands at startup-jp                                  japanese input support-keyfile &lt;file&gt;                      specifies the file to capture keyboard input-licqueue                            use license queue mechanism-load &lt;run&gt;                          load given run at the start-load_refinement &lt;refinement file&gt;   load given refinement file at the start-logfile &lt;file&gt;                      use given file for log-memlimit &lt;limit&gt;                    determines final Java Memory limit-nocopyright                         do not print copyright information at start-nostdout                            no output on stdout-quiet                               be extra quiet-sessions_view &lt;filter&gt;              sets the specified session view at startup-sourcemap &lt;file&gt;                    use contents of given file as list of source location mappings in the form of source and                                     destination directories-status                              prints runtime statistics at the session end-verbose                             be extra verbose-version                             print the version information and exit</code></pre><h1 id="四、IMC-merge-coverage"><a href="#四、IMC-merge-coverage" class="headerlink" title="四、IMC merge coverage"></a>四、IMC merge coverage</h1><p>第一步，<code>imc -batch</code>打开batch模式。</p><p>第二步，<code>merge &lt;文件&gt; -out &lt;输出文件名&gt;</code> ，例如 merge cov_work&#x2F;scope&#x2F;* -out ALL。</p><p>第三步，<code>exit</code>，退出batch模式。然后打开 imc gui界面，把merge生成的文件load进去。</p><p>注意：如果想覆盖掉之前merge生成的文件，可以添加<code>-overwrite</code>选项。</p><h1 id="五、IMC-GUI的基本使用"><a href="#五、IMC-GUI的基本使用" class="headerlink" title="五、IMC GUI的基本使用"></a>五、IMC GUI的基本使用</h1><p>第一步，<code>imc -gui &amp;</code>启动GUI界面，并将coverage database加载进来。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/20.1IMC.png" width="75%" height="75%" alt="20.1"/></center><p>第二步，点击界面相关按钮进行分析。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/20.2IMC.png" width="75%" height="75%" alt="20.2"/></center>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;IMC收集覆盖率&quot;&gt;&lt;a href=&quot;#IMC收集覆盖率&quot; class=&quot;headerlink&quot; title=&quot;IMC收集覆盖率&quot;&gt;&lt;/a&gt;IMC收集覆盖率&lt;/h1&gt;&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=</summary>
      
    
    
    
    <category term="IC" scheme="https://mkdbook.com/categories/IC/"/>
    
    <category term="EDA" scheme="https://mkdbook.com/categories/IC/EDA/"/>
    
    
    <category term="IMC" scheme="https://mkdbook.com/tags/IMC/"/>
    
  </entry>
  
  <entry>
    <title>19--eMMC时序介绍</title>
    <link href="https://mkdbook.com/blog019.html"/>
    <id>https://mkdbook.com/blog019.html</id>
    <published>2023-04-05T11:52:09.000Z</published>
    <updated>2023-04-24T08:54:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、时序缩写速查"><a href="#一、时序缩写速查" class="headerlink" title="一、时序缩写速查"></a>一、时序缩写速查</h1><p>看懂eMMC时序的描述图，首先要理解其每个缩写代表的意思：</p><ul><li><code>S</code>：CMD起始位，&#x3D;<code>0</code></li><li><code>T</code>：表示后面的命令是谁发出的，<code>Host=1</code>；<code>Device=0</code>；</li><li><code>P</code>：一个周期时间的上拉，&#x3D;<code>1</code></li><li><code>E</code>：CMD结束位，&#x3D;<code>1</code></li><li><code>L</code>：一周期时间的下拉，&#x3D;<code>0</code></li><li><code>Z</code>：高阻态</li><li><code>X</code>：<code>1或0</code></li><li><code>D</code>：表示数据</li><li><code>*</code>：重复</li><li><code>CRC</code>：<code>7bit</code></li></ul><h1 id="二、命令时序和应答时序"><a href="#二、命令时序和应答时序" class="headerlink" title="二、命令时序和应答时序"></a>二、命令时序和应答时序</h1><p>有两种不同的颜色，蓝色表示Host的命令，红色表示Device的应答。根据不同的命令类型，有的命令需要应答，有的命令不需要应答。</p><h2 id="2-1-设备识别和设备工作条件时序"><a href="#2-1-设备识别和设备工作条件时序" class="headerlink" title="2.1  设备识别和设备工作条件时序"></a>2.1  设备识别和设备工作条件时序</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/19.1.png" width="75%" height="75%" alt="19.1"/></center><p>上图所示为host发送<code>CMD1或CMD2</code>分别请求device的<code>OCR或CID</code>的过程，host发送完命令后经过<code>NID</code>的<code>CLK</code>周期后，device开始<strong>在响应中</strong>返回<code>OCR或CID</code>寄存器中的内容。</p><blockquote><p>注：如果host发送<code>CMD2（ALL_SEND_CID）</code>后没有收到device的应答，host就认为总线上没有device的存在。</p></blockquote><h2 id="2-2-为设备分配相对地址"><a href="#2-2-为设备分配相对地址" class="headerlink" title="2.2  为设备分配相对地址"></a>2.2  为设备分配相对地址</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/19.2.png" width="75%" height="75%" alt="19.2"/></center><p><code>CMD3（SET_RCA）</code>，device接收到其RCA后就切换到Data transfer模式。</p><h2 id="2-3-Data-transfer模式"><a href="#2-3-Data-transfer模式" class="headerlink" title="2.3  Data transfer模式"></a>2.3  Data transfer模式</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/19.3.png" width="75%" height="75%" alt="19.3"/></center><p>可以看着这里和前两个时序的区别是：不是间隔<code>Z</code>，而是间隔<code>P（host/device主动拉高）</code>。</p><blockquote><p>注：只有<code>CMD1、2、3</code>中间全是Z（针对有应答的CMD而言）。</p></blockquote><h2 id="2-4-R1b应答"><a href="#2-4-R1b应答" class="headerlink" title="2.4  R1b应答"></a>2.4  R1b应答</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/19.4.png" width="75%" height="75%" alt="19.4"/></center><p>带Busy信号的的应答，在host命令后隔两个周期<code>DAT0线拉低</code>，<code>表示Busy</code>。其他几根DAT线的值无所谓。</p><h2 id="2-5-上一Device应答——-gt-下一host命令"><a href="#2-5-上一Device应答——-gt-下一host命令" class="headerlink" title="2.5  上一Device应答——&gt;下一host命令"></a>2.5  上一Device应答——&gt;下一host命令</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/19.5.png" width="75%" height="75%" alt="19.5"/></center><h2 id="2-6-上一host命令——-gt-下一host命令"><a href="#2-6-上一host命令——-gt-下一host命令" class="headerlink" title="2.6   上一host命令——&gt;下一host命令"></a>2.6   上一host命令——&gt;下一host命令</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/19.6.png" width="75%" height="75%" alt="19.6"/></center><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>1、两段之间的CLK间隔<code>N**</code>，在协议中<code>Timing Patameters</code>表格中有具体规定。（协议P154）</p><p>2、时序中的<code>CMD</code>格式是和<a href="https://mkdbook.com/blog016.html#:~:text=%E7%9A%84CRC%E4%BF%9D%E6%8A%A4-,16.2%20CMD%20token,-eMMC%E7%9A%84%E5%91%BD%E4%BB%A4">Command Format</a>对的上的。</p><p>3、时序中的<code>Response</code>格式取决于每种命令对应的应答类型，每种类型的bit位描述在协议中都有具体表格说明。（P136）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、时序缩写速查&quot;&gt;&lt;a href=&quot;#一、时序缩写速查&quot; class=&quot;headerlink&quot; title=&quot;一、时序缩写速查&quot;&gt;&lt;/a&gt;一、时序缩写速查&lt;/h1&gt;&lt;p&gt;看懂eMMC时序的描述图，首先要理解其每个缩写代表的意思：&lt;/p&gt;</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>18--eMMC的Secure Erase和Secure Trim操作</title>
    <link href="https://mkdbook.com/blog018.html"/>
    <id>https://mkdbook.com/blog018.html</id>
    <published>2023-04-05T05:11:21.000Z</published>
    <updated>2023-04-05T11:50:45.089Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、Secure-Erase"><a href="#一、Secure-Erase" class="headerlink" title="一、Secure Erase"></a>一、Secure Erase</h1><p><code>Secure Erase</code>命令和基本的<code>Erase</code>命令不同，它要求设备在发出此命令后，device和host在进入下一个操作之前必须<strong>等待Erase物理地完成</strong>。<br><code>Secure Erase</code>命令的执行方式与Erase命令相同，只是CMD38中<code>bit[31]=1</code>，其他参数为0；<br>CMD38 四个重要的bit位说明如图所示：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/18.1CMD38%E9%87%8D%E8%A6%81bit%E4%BD%8D.png" width="75%" height="75%" alt="18.1 CMD38重要bit位"/></center><h1 id="二、Secure-Trim"><a href="#二、Secure-Trim" class="headerlink" title="二、Secure Trim"></a>二、Secure Trim</h1><p><code>Secure Trim</code>是对<code>write block</code>执行安全擦除操作，确保数据完全地从memory中物理擦除。</p><p><strong>启动方法有两步：</strong></p><ol><li><code>步骤1</code>：host定义它标记为Secure TRIM的write block的范围（通过CMD35、CMD36），一旦确定了范围，CMD38（<code>bit[31],bit[0]设置为1</code>，其他位为0）就会被应用。</li></ol><blockquote><p>步骤1可以重复多次，中间允许有其他命令，直到所有需要清除的write block都被明确定义。建议尽可能在多的block上进行Secure TRIM的步骤1，以提高Secure TRIM的效率。</p></blockquote><ol start="2"><li><code>步骤2</code>：发送夹带地址的CMD35和CMD36（注意与这些命令一起使用的参数将被忽略），然后发送CMD38（<code>bit[31],bit[15]为1</code>，其他为0）。这一步实际上是根据<code>Secure_Removal_type(EXT_CSD [16])</code>（<a href="https://mkdbook.com/blog017.html#:~:text=17.4%20Secure_Removal_type">图17.4</a>），对<strong>所有的write block以及它的所有副本</strong>执行Secure Trim，这些write block在步骤1中已被标记。</li></ol><blockquote><p>在步骤1和步骤2之间，可以向设备发出其他命令。</p></blockquote><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><h2 id="1、隐式（implicit）擦除和显式（explicit）擦除"><a href="#1、隐式（implicit）擦除和显式（explicit）擦除" class="headerlink" title="1、隐式（implicit）擦除和显式（explicit）擦除"></a>1、隐式（implicit）擦除和显式（explicit）擦除</h2><p><code>隐式擦除</code>是指device中的某些数据被简单地标记成已删除，host可以向device该位置写数据。但是在技术上，memory里面的数据在overwrite之前还存在device中，甚至通过某些手段能够恢复数据。<br><code>显式擦除</code>则是一个更彻底的过程，用新数据（0&#x2F;1）覆盖掉原来的数据，保证删除的数据是无法被恢复的。<br>所以，隐式擦除速度更快、更简单，但是数据有被恢复的潜在风险。显式擦除反之。</p><h2 id="2、Secure-Erase和Erase的区别；Secure-Trim和TRIM的区别；"><a href="#2、Secure-Erase和Erase的区别；Secure-Trim和TRIM的区别；" class="headerlink" title="2、Secure Erase和Erase的区别；Secure Trim和TRIM的区别；"></a>2、Secure Erase和Erase的区别；Secure Trim和TRIM的区别；</h2><p>着重理解这里的<code>Secure</code>，是指要保证数据完全、永久地从device删除，不能被恢复，采取的是显示擦除的overwrite的方法。<br>而不带Secure的操作仅仅<code>被标记为删除</code>，device可能还没有实际进行overwrite，数据可能被恢复。</p><h2 id="3、新的eMMC版本中，Secure操作被取代"><a href="#3、新的eMMC版本中，Secure操作被取代" class="headerlink" title="3、新的eMMC版本中，Secure操作被取代"></a>3、新的eMMC版本中，Secure操作被取代</h2><p>为了向后兼容，保留了Secure Erase和Secure TRIM，但在v4.51之后这两种方式分别以<code>Erase+Sanitize</code>和<code>TRIM+Sanitize</code>的方式实现。<br>Sanitize操作就是能实际地通过overwrite的方式，将数据擦除。故结合使用，<code>标记+删除</code>结合就可以实现<code>Secure</code>的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、Secure-Erase&quot;&gt;&lt;a href=&quot;#一、Secure-Erase&quot; class=&quot;headerlink&quot; title=&quot;一、Secure Erase&quot;&gt;&lt;/a&gt;一、Secure Erase&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Sec</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>17--eMMC的Erase、TRIM、Sanitize、Discard操作</title>
    <link href="https://mkdbook.com/blog017.html"/>
    <id>https://mkdbook.com/blog017.html</id>
    <published>2023-04-05T03:38:53.000Z</published>
    <updated>2023-04-05T04:51:23.970Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、eMMC地址空间（mapped-or-unmapped）"><a href="#一、eMMC地址空间（mapped-or-unmapped）" class="headerlink" title="一、eMMC地址空间（mapped or unmapped）"></a>一、eMMC地址空间（mapped or unmapped）</h1><p>可以粗略地将Flash分为两种类型：<code>raw</code>和<code>managed</code>。原始的Flash（raw类型）单个cell的P&#x2F;E寿命是有限的，如果长期只对某些固定的block或cell进行使用，很容易造成局部损坏，故需要进行“<code>wear leveling</code>”减少这种损坏概率。显然eMMC属于managed的Flash设备。</p><p>在eMMC中有三种类型的地址空间：</p><ul><li><code>Mapped Host Address Space</code>：e•MMC设备中，<strong>可通过</strong>host的读取命令访问的区域。</li><li><code>Unmapped Host Address Space</code>：<strong>不能</strong>被host通过读取命令访问。它可能包含old host data或者copies of host data。</li><li><code>Private Vendor Specific Address Space</code>：<strong>不能</strong>被host通过读取命令访问。包含如mapping tables、Firmware等数据。</li></ul><h2 id="映射举例详解"><a href="#映射举例详解" class="headerlink" title="映射举例详解"></a>映射举例详解</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/17.1%E4%BE%8B1.png" width="58%" height="58%" alt="17.1 例1"/></center><p>例1比较简单，物理地址空间有12个，实际映射了8个block，即3-bit的address space。当从编号3的block开始写入3-block-data时，实际映射到了物理空间的3-5；</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/17.2%E4%BE%8B2.png" width="37%" height="37%" alt="17.2 例2"/></center><p>例2，实际中3、4、5已经被写入数据了，若修改编号5的数据。<br>理论上应该擦除物理地址空间的5，然后再写入，<code>但擦除时间远长于写入时间</code>，因此不采用此方法。</p><p>实际上操作如下：（前提是这里假设的Erase最小对齐长度为2个block）</p><ul><li>1、<code>重新map 4、5</code>到物理地址空间的<code>8、9</code>，</li><li>2、将之前<code>4</code>的数据写到<code>8</code>，因为没有改变4的值，</li><li>3、最后将改变的新数据写入第<code>9</code>。</li></ul><h2 id="unmapped-block中残留数据的由来"><a href="#unmapped-block中残留数据的由来" class="headerlink" title="unmapped block中残留数据的由来"></a>unmapped block中残留数据的由来</h2><p>如例2，通过更新映射表，将数据写入到之前未映射的空block，比直接擦除第4、5块再写入同一位置的速度快的多（因为擦除速度很慢）。<br>但是，由于通过修改映射表写入了空block，导致了之前映射的block就变成了<code>未映射但有数据</code>。</p><h1 id="二、Erase"><a href="#二、Erase" class="headerlink" title="二、Erase"></a>二、Erase</h1><p>基本Erase的单元是“<code>Erase Group</code>”，如果EXT_CSD中<code>ERASE_GROUP_DEF [175]</code> 处于<code>enabled</code>时，则Erase Group在<strong>EXT_CSD</strong>中定义。<code>disabled</code>时，在<strong>CSD</strong>中定义。<br>当Erase成功后，设备中被擦除的<code>mapped device address range</code>为全0&#x2F;1（取决于memory技术，在EXT_CSD[181]中<code>ERASE_MEM_CONT</code>定义）。</p><p>启动Erase分为三步：</p><ul><li>1、Host 通过 ERASE_GROUP_START（CMD35）命令，定义范围的起始地址；</li><li>2、接下来用 ERASE_GROUP_END（CMD36）命令，定义范围的最后地址；</li><li>3、最后终通过发送参数设置为 0 的 ERASE（CMD38）命令，启动Erase进程。（CMD38 参数见下表）</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/17.3CMD38%E5%8F%82%E6%95%B0%E5%AE%9A%E4%B9%89.png" width="60%" height="60%" alt="17.3 CMD38参数定义"/></center><h1 id="三、TRIM"><a href="#三、TRIM" class="headerlink" title="三、TRIM"></a>三、TRIM</h1><p>TRIM适用于对“<code>write blocks</code>”进行擦除。可以允许host识别不需要的data，然后device在后台擦除事件中擦除数据。当TRIM成功后，设备中被擦除的<code>mapped device address range</code>为全0&#x2F;1。<br>TRIM的结果是简单地将<code>mapped host address range</code>变为<code>unmapped host address range</code> 。</p><p>启动TRIM分为三步：</p><ul><li>1、Host 通过 ERASE_GROUP_START（CMD35）命令，定义范围的起始地址；（指定write block，非erase group）</li><li>2、接下来用 ERASE_GROUP_END（CMD36）命令，定义范围的最后地址；指定write block，非erase group）</li><li>3、最后发送参数 bit[0] 为1，其他bit位为 0 的 ERASE（CMD38）命令启动TRIM过程；</li></ul><h1 id="四、Sanitize"><a href="#四、Sanitize" class="headerlink" title="四、Sanitize"></a>四、Sanitize</h1><p>Sanitize从设备<code>unmapped user address space</code>中physically移除数据，根据<code>Secure_Removal_type(EXT_CSD [16])</code>。当完成Sanitize操作后，<code>unmapped host address space</code>就不存在数据了。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/17.4Secure_Removal_type.png" width="75%" height="75%" alt="17.4 Secure_Removal_type"/></center><blockquote><p>bit[5:4]：配置安全移除类型（可读可写）<br>  <em><code>0x0</code>：通过擦除物理内存来删除信息；</em><br>  <em><code>0x1</code>：用一个字符覆盖寻址位置，然后进行擦除，从而删除信息；</em><br>  <em><code>0x2</code>：通过用一个字符、其补码和一个随机字符覆盖寻址位置来删除信息；</em><br>  <em><code>0x3</code>：用供应商定义的方法删除信息；</em><br>bit[3:0]：支持的安全移除类型（可读）<br>bit[0]、bit[1]、bit[2]、bit[3]的描述分别对应上述的0x0、0x1、0x2、0x3</p></blockquote><p><strong>启动Sanitize的方法：向EXT_CSD[165]——<code>SANITIZE_START</code>写入任何值</strong>。当设备执行Sanitize操作时，busy信号建立，直到如下事件发生时结束：</p><ul><li>Sanitize操作完成；</li><li>利用HPI中止此操作；</li><li>power failure；</li><li>硬件复位；</li></ul><h1 id="五、Discard"><a href="#五、Discard" class="headerlink" title="五、Discard"></a>五、Discard</h1><p>类似于TRIM，区别如下：</p><ul><li>对被 Discard 区域进行读取，可能返回一些或全部原来的数据。<br>但是，在 TRIM 的情况下，整个区域将成为未映射或被移除，并将取决于存储器工艺返回 0 或 1。</li><li>当执行 Sanitize 时，只有被Discard命令丢弃的<strong>未映射区域的数据</strong>，这部分才能被 Sanitize 移除。<br>Device 不能保证在实施 Sanitize 时，被Discard 的数据完全从 Device 中移除。</li></ul><p>启动Discard分为三步：</p><ul><li>1、Host 通过 ERASE_GROUP_START（CMD35）命令，定义范围的起始地址；（指定write block，非erase group）</li><li>2、接下来用 ERASE_GROUP_END（CMD36）命令，定义范围的最后地址；指定write block，非erase group）</li><li>3、最后发送参数 bit[0]，bit[1] 为 1 ，其他bit位为 0 的 ERASE（CMD38）命令启动Discard过程；</li></ul><h1 id="六、总结四种方式区别"><a href="#六、总结四种方式区别" class="headerlink" title="六、总结四种方式区别"></a>六、总结四种方式区别</h1><p>1、Sanitize用于unmapped的地址空间进行<code>物理擦除</code>，而其它三种都是针对mapped的地址空间（仅修改映射，并标记为擦除）。</p><p>2、Erase针对<code>erase group</code>，TRIM和Discard针对独立的<code>write block</code>，后者更加灵活。</p><p>3、<code>Erase/TRIM</code>和<code>Discard</code>（<em><strong>partial or full the actual erase</strong></em>）的区别在一个partial，即Discard的清除是不完整的，部分的、结果是不确定的。</p><p>4、故通过<code>Erase或TRIM</code>擦除<code>mapped address space</code>中的所有数据；<br>再触发<code>Sanitize</code>操作，清除<code>遗留在unmapped address space</code>中的任何数据；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、eMMC地址空间（mapped-or-unmapped）&quot;&gt;&lt;a href=&quot;#一、eMMC地址空间（mapped-or-unmapped）&quot; class=&quot;headerlink&quot; title=&quot;一、eMMC地址空间（mapped o</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>16--eMMC命令整体概述</title>
    <link href="https://mkdbook.com/blog016.html"/>
    <id>https://mkdbook.com/blog016.html</id>
    <published>2023-03-26T10:01:13.000Z</published>
    <updated>2023-04-05T11:39:33.664Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="eMMC-5-1协议CMD中文翻译"><a href="#eMMC-5-1协议CMD中文翻译" class="headerlink" title="eMMC 5.1协议CMD中文翻译"></a>eMMC 5.1协议CMD中文翻译</h1><p><a href="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/pdf-share/eMMC5.1CMD%E4%B8%AD%E6%96%87%E8%A7%A3%E9%87%8A.pdf">下载地址</a></p><h1 id="一、CMD-line模式"><a href="#一、CMD-line模式" class="headerlink" title="一、CMD line模式"></a>一、CMD line模式</h1><ul><li>CMD line modes overview</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/16.1CMD%20line%20modes.png" width="80%" height="80%" alt="16.1 CMD line modes"/></center>    <p>如图16.1所示，eMMC设备共有16种状态，分别分类到5种操作模式中，CMD line mode又有两种类型。</p><h1 id="二、寄存器"><a href="#二、寄存器" class="headerlink" title="二、寄存器"></a>二、寄存器</h1><p>eMMC共有7种不同类型的寄存器。</p><ul><li><code>OCR</code>：Operation Conditons Register，<code>32-bit</code>；<strong>CMD1</strong>操作；</li><li><code>CID</code>：Device IDentification Register，<code>128bit</code>；<strong>CMD2</strong>操作；</li><li><code>CSD</code>：Device-Specific Data register，<code>128bit</code>；<strong>CMD9、27</strong>操作；</li><li><code>EXT_CSD</code>：Extend CSD，<code>512byte</code>，320（属性、不可被host更改）+192；<strong>CMD6</strong>操作；</li><li><code>RCA</code>：Relative Decive Address register，<code>16-bit</code>；<strong>CMD3</strong>操作；</li><li><code>DSR</code>：Driver Stage Register，<code>16bit</code>；<strong>CMD4</strong>操作；</li><li><code>QSR</code>：Queue Status Register，<code>32bit</code>；<strong>CMD13</strong>；</li></ul><h1 id="三、CMD"><a href="#三、CMD" class="headerlink" title="三、CMD"></a>三、CMD</h1><ul><li>Command Format，一条命令的格式如图所示：<blockquote><p>固定为48个bit；<br>起始位分别为0和1；<br>bit[46]，为1则命令由host发出，为0则为Device发出；<br>bit[39:8]，有些CMD需要带参数（例如带address）；<br>每条命令被7bit的CRC保护</p></blockquote></li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/16.2CMD%20Format.png" width="90%" height="90" alt="16.2 CMD token"/></center><p>eMMC的命令一共有64个，从<code>CMD0</code>-<code>CMD63</code> ，在Command token的bit[45:40]表征。它们按照不同的功能集划分，又隶属于13个Class。</p><h2 id="3-1-命令的13个Class："><a href="#3-1-命令的13个Class：" class="headerlink" title="3.1 命令的13个Class："></a>3.1 <strong>命令的13个Class：</strong></h2><ul><li>Class 0：<code>basic</code></li><li>Class 1：<code>Obsolete</code></li><li>Class 2：<code>block read</code></li><li>Class 3 ：<code>Obsolete</code></li><li>Class 4：<code>block write</code></li><li>Class 5：<code>erase</code></li><li>Class 6：<code>write protection</code></li><li>Class 7：<code>lock Device</code></li><li>Class 8：<code>Application-specific</code></li><li>Class 9：<code>I/O mode</code></li><li>Class10：<code>Security Protocols</code></li><li>Class11：<code>Command Queuing</code></li><li>Class12：<code>Reserved</code></li></ul><h2 id="3-2-命令一共有一共有4种类型："><a href="#3-2-命令一共有一共有4种类型：" class="headerlink" title="3.2 命令一共有一共有4种类型："></a>3.2 <strong>命令一共有一共有4种类型：</strong></h2><ul><li><code>bc</code>：Broadcast CMD，no Respose。</li><li><code>bcr</code>：广播、有应答。</li><li><code>ac</code>：Addressed（point-to-point）CMD，DAT线上无数据。</li><li><code>adtc</code>：Addressed（point-to-point）data transfer CMD，DAT线上有数据。</li></ul><h2 id="3-3-命令的应答一共有5种类型："><a href="#3-3-命令的应答一共有5种类型：" class="headerlink" title="3.3 命令的应答一共有5种类型："></a>3.3 <strong>命令的应答一共有5种类型：</strong></h2><ul><li><code>R1</code>：normal response command。响应常用命令。<br><code>R1b</code>：和R1区别是，有一个可选的busy信号（和R1属于同一类型）。</li><li><code>R2</code>：CID，CSD register。响应CMD2、10、9，并将CID和CSD的值作为响应的返回数据。</li><li><code>R3</code>：OCR register。OCR的值作为对CMD1的响应发送给host。</li><li><code>R4</code>：Fast I&#x2F;O。</li><li><code>R5</code>：Interrupt request。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;eMMC-5-1协议CMD中文翻译&quot;&gt;&lt;a href=&quot;#eMMC-5-1协议CMD中文翻译&quot; class=&quot;headerlink&quot; title=&quot;eMMC 5.1协议CMD中文翻译&quot;&gt;&lt;/a&gt;eMMC 5.1协议CMD中文翻译&lt;/h1&gt;</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>15--Program、Read、Erase实现逻辑-项目1-2</title>
    <link href="https://mkdbook.com/blog015.html"/>
    <id>https://mkdbook.com/blog015.html</id>
    <published>2023-03-21T14:20:46.000Z</published>
    <updated>2023-03-24T08:08:08.016Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><ol><li>图1</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.1.png" width="100%" height="100%" alt="图1"/></center><ol start="2"><li>图2</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.2.png" width="100%" height="100%" alt="图2"/></center><ol start="3"><li>图3</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.3.png" width="100%" height="100%" alt="图3"/></center> <ol start="4"><li>图4</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.4.png" width="100%" height="100%" alt="图4"/></center> <ol start="5"><li>图5</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.5.png" width="100%" height="100%" alt="图5"/></center> <ol start="6"><li>图6</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.6.png" width="100%" height="100%" alt="图6"/></center> <ol start="7"><li>图7</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.7.png" width="100%" height="100%" alt="图7"/></center>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;图1&lt;/li&gt;
&lt;/ol&gt;
&lt;center&gt;
&lt;img src=&quot;https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.1.png&quot; width=&quot;10</summary>
      
    
    
    
    <category term="项目" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="项目1-Nand_behavior_model" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1-Nand-behavior-model/"/>
    
    
    <category term="NAND" scheme="https://mkdbook.com/tags/NAND/"/>
    
  </entry>
  
  <entry>
    <title>14--NAND behavior model说明-项目1-1</title>
    <link href="https://mkdbook.com/blog014.html"/>
    <id>https://mkdbook.com/blog014.html</id>
    <published>2023-03-21T14:19:56.000Z</published>
    <updated>2023-03-24T08:08:02.722Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]<br>前言，本项目是我刚接触NAND，为了熟悉NAND其功能的一个练手项目。项目功能比较单一，Array的Size也比较小。</p><h1 id="一、项目功能描述"><a href="#一、项目功能描述" class="headerlink" title="一、项目功能描述"></a>一、项目功能描述</h1><ul><li><strong>Program</strong> （80h-10h）</li><li><strong>Read</strong>       （00h-30h）</li><li><strong>Erase</strong>      （60h-D0h）</li></ul><h1 id="二、Array-Size定义"><a href="#二、Array-Size定义" class="headerlink" title="二、Array Size定义:"></a>二、Array Size定义:</h1><ul><li>Plane： 1个   （total）</li><li>Block： 4个   （4 in a plane）</li><li>Page ：256个 （total 256，64 in a block）</li><li>Byte  ：128个 （128 in a page）</li></ul><h1 id="三、model文件说明"><a href="#三、model文件说明" class="headerlink" title="三、model文件说明"></a>三、model文件说明</h1><ul><li><code>nand_falsh_model.v</code>： 实现Program、Read、Erase功能的设计文件</li><li><code>parameters.vh</code> ： 设计和tb中的参数定义，包括容量、地址、时序等参数</li><li><code>subtest.v</code> ： 用于调用tb中相关task，实现定向测试</li><li><code>tb.v</code> ： 包含测试激励的产生和相关测试的task</li></ul><h1 id="四、NAND-Flash内部空间层次"><a href="#四、NAND-Flash内部空间层次" class="headerlink" title="四、NAND Flash内部空间层次"></a>四、NAND Flash内部空间层次</h1><p>如图14.1，对于单个LUN的NAND Flash的内部空间，从大到小排列如下：<br><code>LUN ——&gt; Plane ——&gt; block ——&gt; page ——&gt; byte</code></p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/14.1NAND%E5%86%85%E9%83%A8%E7%A9%BA%E9%97%B4%E5%B1%82%E6%AC%A1%E5%9B%BE.png" width="40%" height=40%" alt="14.1 NAND 内部空间层次"/></center><p>可以看到，这个LUN包含了4个Plane，<br>每一个Plane包含一个PAGE REGISTER；<br>每个Plane中Block的个数应该是1980&#x2F;4个；<br>每一个Block中包含了2304个page。</p><blockquote><p>注意：Block的编号问题，block 0，1，2，3分别属于四个不同的plane，所以每隔4个Block处于一个Plane。</p></blockquote><h1 id="五、本项目容量定义"><a href="#五、本项目容量定义" class="headerlink" title="五、本项目容量定义"></a>五、本项目容量定义</h1><ol><li>容量计算方式为：<code>plane数量 * block数量 * page数量 * 每个page里面byte的个数</code> <ul><li>1 byte &#x3D; 8 bits ；1 word &#x3D; 16 bits</li></ul></li><li>代码中对应参数设置如图14.2所示：</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/14.2%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E5%AE%9A%E4%B9%89.png" width="40%" height="40%" alt="14.2 容量相关参数定义"/></center><p><code>NUM_PLANES</code> ：总共的 plane 数</p><p><code>NUM_BLCK</code>    ：最大的 block 数（不代表一定有这么多，但是不能超过这个数）</p><p><code>NUM_PAGE</code>    ：1个 block 中包含的 page数</p><p><code>NUM_ROW</code>     ：总共的 page 数</p><p><code>NUM_COL</code>     ：每个 page 中的 byte 数</p><p><code>PAGE_SIZE</code>  ：每个 page 中的 bit 数</p><ol start="3"><li>如图14.3所示，我这里一共定义了256个page，分别平分给4个Block，每个Block有64个Page，它们的编号各自都从<code>Page 0</code>-<code>Page 63</code> 。</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/14.3Block%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" width="40%" height="40%" alt="14.3 Block层次结构"/></center><ol start="4"><li>如图14.4所示，1个Page定义了128个Byte，而每个Byte有8个BIt，故1个Page一共有1024个Bit，编号为<code>Bit 0</code>-<code>Bit 1023</code>。<br>注意：这里如果要在一个Memory Array中找到相应的Byte，应该<code>Byte 0：Bit 0-Bit 7</code>；<code>Byte 1：Bit 8-Bit 15</code>；以此类推。</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/14.4Page%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" width="40%" height="40%" alt="14.4 Page层次结构"/></center><h1 id="五、本项目地址处理"><a href="#五、本项目地址处理" class="headerlink" title="五、本项目地址处理"></a>五、本项目地址处理</h1><p>如图所示，</p><ul><li>Row address（行地址）：寻址 LUN、Block、Page</li><li>Column address（列地址）：寻址 Page 中的 Byte</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/14.5NAND%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" width="70%" height="70%" alt="14.5 NAND地址分类"/></center><p>TB中关于地址的处理如下：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/14.6TB%E5%A4%84%E7%90%86%E5%9C%B0%E5%9D%80.png" width="70%" height="70%" alt="14.6 TB处理地址"/></center><ul><li><p>function功能说明： block地址有10位，page地址有6位； 一次只能传8bit  第一个row地址由block_addr 低两位  + page_addr 组成。</p></li><li><p>CA 定义了12个 bit，RA定义了16个bit，而总线只有8个 IO 口，只能分两次传。</p></li><li><p>COL_BITS &#x3D;12；PAGE_BITS&#x3D;6。</p></li><li><p>col_addr_1 <code>传低八位</code>。</p></li><li><p>col_addr_2 的<code>低四位</code>传CA的<code>高四位</code>，col_addr_2的<code>高四位</code>用<code>0</code>填充。</p></li><li><p>row_addr_1 传 <code>[2bit block_addr + 6bit page_addr]</code>。</p></li><li><p>row_addr_2 传 <code>[8bit block地址]</code>。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;br&gt;前言，本项目是我刚接触NAND，为了熟悉NAND其功能的一个练手项目。项目功能比较单一，Array的Size也比较小。&lt;/p&gt;
&lt;h1 id=&quot;一、项目功能描述&quot;&gt;&lt;a href=&quot;#一、项目功能描述&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="项目" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="项目1-Nand_behavior_model" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1-Nand-behavior-model/"/>
    
    
    <category term="NAND" scheme="https://mkdbook.com/tags/NAND/"/>
    
  </entry>
  
</feed>
