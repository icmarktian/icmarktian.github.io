<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>马克得烂笔头</title>
  
  <subtitle>Mark&#39;s Book</subtitle>
  <link href="https://mkdbook.com/atom.xml" rel="self"/>
  
  <link href="https://mkdbook.com/"/>
  <updated>2023-04-28T02:36:02.999Z</updated>
  <id>https://mkdbook.com/</id>
  
  <author>
    <name>Mark</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>22--eMMC的boot分区</title>
    <link href="https://mkdbook.com/blog022.html"/>
    <id>https://mkdbook.com/blog022.html</id>
    <published>2023-04-28T01:20:32.000Z</published>
    <updated>2023-04-28T02:36:02.999Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、boot分区容量设置"><a href="#一、boot分区容量设置" class="headerlink" title="一、boot分区容量设置"></a>一、boot分区容量设置</h1><p>一共有两个boot分区，每个的大小最小为<code>128KB</code>，计算方法见EXT_CSD[226]，如图22.1所示，最大支持31.875M，一般为4M（即乘以32）：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/22.1.png" width="75%" height="75%" alt="22.1"/></center><h1 id="二、进入boot模式的方法"><a href="#二、进入boot模式的方法" class="headerlink" title="二、进入boot模式的方法"></a>二、进入boot模式的方法</h1><p>上电后，收到<code>CMD0（0xF0F0F0F0）</code>命令或<code>硬件复位</code>信号。</p><h1 id="三、如何从boot分区启动（host从boot分区读取数据）"><a href="#三、如何从boot分区启动（host从boot分区读取数据）" class="headerlink" title="三、如何从boot分区启动（host从boot分区读取数据）"></a>三、如何从boot分区启动（host从boot分区读取数据）</h1><h2 id="3-1-访问boot分区"><a href="#3-1-访问boot分区" class="headerlink" title="3.1  访问boot分区"></a>3.1  访问boot分区</h2><p>在boot模式下，host有两种方法读取eMMC中boot区的数据：</p><p>1、保持<code>CMD line low</code>；</p><p>2、在发<code>CMD1</code>之前，发送<code>CMD0（0xFFFFFFFA）</code>；</p><h2 id="3-2-Original-Boot-Operation"><a href="#3-2-Original-Boot-Operation" class="headerlink" title="3.2  Original Boot Operation"></a>3.2  Original Boot Operation</h2><p>1、<code>power-on</code>或<code>reset</code>（硬件复位或CMD0带0xF0F0F0F0）后，在第一个CMD之前 <em><strong>CMD line被拉低超过74个clock</strong></em>，则设备会识别到original boot 模式，并在内部开始准备引导数据。</p><p>2、引导数据哪里来？（<a href="http://localhost:4000/blog022.html#:~:text=%E5%9C%A8boot%20mode%E3%80%82-,bit%5B5%3A3%5D,-%E2%80%94%E2%80%94%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8boot">EXT_CSD[179]的bit[5:3]</a>）</p><p>3、引导数据有多大？（<a href="http://localhost:4000/blog022.html#:~:text=EXT_CSD%5B226%5D%EF%BC%8C%E5%A6%82-,%E5%9B%BE22.1,-%E6%89%80%E7%A4%BA%EF%BC%8C%E6%9C%80%E5%A4%A7">EXT_CSD[226]</a>）</p><p>4、以何种速率和方式传输引导数据？（<a href="http://localhost:4000/blog022.html#:~:text=22.5%20BOOT_BUS_CONDITIONS-,bit%5B4%3A3%5D,-%E2%80%94%E2%80%94%E8%AF%BB%E5%8F%96boot">EXT_CSD[177]</a>）</p><p>5、设备是否需要给host一个“010”的boot模式确认反馈？（<a href="http://localhost:4000/blog022.html#:~:text=22.4%20PARTITION_CONFIG-,bit%5B6%5D,-%E2%80%94%E2%80%94CPU%E5%8A%A0%E8%BD%BD">EXT_CSD[179]的bit[6]</a>）</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/22.2Original%20Boot%20Operation.png" width="100%" height="100%" alt="22.2 Original Boot Operation"/></center><p>时序介绍：</p><ul><li>1、<code>CMD line拉低后</code>的1s内，device必须将第一个boot data从DAT line发送给host。在整个数据接收过程中，CMD line都一直保持为低。</li><li>2、如果设置了boot模式的确认反馈，device必须在<code>CMD line拉低</code>的50ms内发送“010”。</li><li>3、host通过<code>拉高CMD line结束</code>boot模式，之后需要在至少56个clock周期后，才能再发送CMD1启动正常的eMMC初始化。</li></ul><h2 id="3-3-Alternative-Boot-Operation"><a href="#3-3-Alternative-Boot-Operation" class="headerlink" title="3.3  Alternative Boot Operation"></a>3.3  Alternative Boot Operation</h2><p>v4.4版本之后的eMMC必须支持Alternative boot operation这种模式。</p><p>1、<code>power-on</code>或<code>reset</code>（硬件复位或CMD0带0xF0F0F0F0）后，再间隔<code>74个clock</code>后（<strong>在CMD line拉低或CMD1发出之前</strong>），<em><strong>host发送CMD0（参数为0xFFFFFFFA）</strong></em>，则设备会识别到Alternative boot 模式，并在内部开始准备引导数据。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/22.3Alternative%20Boot%20Operation.png" width="100%" height="100%" alt="22.3 Alternative Boot Operation"/></center><p>时序介绍：</p><ul><li>1、<code>CMD 0（0xFFFFFFFA）发出后</code>的1s内，device必须将第一个boot data从DAT line发送给host。</li><li>2、如果设置了boot模式的确认反馈，device必须<code>在CMD 0（0xFFFFFFFA）发出后</code>的50ms内发送“010”。</li><li>3、host通过发送<code>CMD 0（RESET：0x00000000）结束</code>boot模式，之后再发送CMD1启动正常的eMMC初始化。（没有56 clock的限制）</li></ul><h1 id="四、boot分区配置"><a href="#四、boot分区配置" class="headerlink" title="四、boot分区配置"></a>四、boot分区配置</h1><p>通过<code>CMD6（SWITCH）</code>改变EXT_CSD[179]中<code>PARTITION_CONFIG</code>的值。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/22.4PARTITION_CONFIG.png" width="80%" height="80%" alt="22.4 PARTITION_CONFIG"/></center><ul><li><strong>bit[6]——CPU加载boot程序时，是否使用ACK</strong><br>0x0：No boot acknowledge send（default）<br>0x1：boot操作期间发送boot应答，eMMC会在host触发boot mode的50ms内，在DAT0上发送一个<code>“010”的Boot ACK</code>给host。host可通过此位，判断是否在boot mode。</li><li><strong>bit[5:3]——是否使用boot功能，使用哪个分区存放的boot程序？</strong><br>0x0：Device not boot enabled（default）<br>0x1：选择boot分区<code>1</code><br>0x2：选择boot分区<code>2</code><br>0x3-0x6：Reserved<br>0x7：选择<code>User area</code>（boot数据也可以存到用户分区中，但不如存到专用boot分区中可靠）</li><li><strong>bit[2:0]——当前访问的是哪个分区，例如选择0x1，将boot程序烧录boot分区1，然后烧录完成后恢复成0x0（正常模式）</strong><br>0x0：No access to boot partition（default）<br>0x1：读写boot分区<code>1</code><br>0x2：读写boot分区<code>2</code><br>0x3：读写<code>RPMB</code>分区<br>0x4：访问GPP1<br>0x5：访问GPP2<br>0x6：访问GPP3<br>0x7：访问GPP4</li></ul><h1 id="五、boot的bus-width和data-access配置"><a href="#五、boot的bus-width和data-access配置" class="headerlink" title="五、boot的bus-width和data-access配置"></a>五、boot的bus-width和data-access配置</h1><p>在boot操作过程中，通过配置EXT_CSD[177]中<code>BOOT_BUS_CONDITIONS</code>。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/22.5BOOT_BUS_CONDITIONS.png" width="80%" height="80%" alt="22.5 BOOT_BUS_CONDITIONS"/></center><ul><li><strong>bit[4:3]——读取boot区数据，选择什么工作模式</strong><br>0x0：SDR+backward compatible timing（default）<br>0x1：SDR+High Speed timing<br>0x2：DDR<br>0x3：Reserved<br>注：<code>HS200和HS400</code>在boot操作中<code>不允许</code></li><li><strong>bit[2]——RESET_BOOT_BUS_CONDITIONS</strong><br>0x0：boot操作结束后，复位到<code>x1，SDR+backward compatible</code>模式（default）<br>0x1：保持<code>BOOT_MODE</code>和<code>BOOT_BUS_WIDTH</code>设置的参数不变</li><li><strong>bit[1:0]——读取boot区数据，选择多宽的bus width</strong><br>0x0：<code>x1（SDR）</code>或 <code>x4（DDR）</code>（default）<br>0x1：<code>x4（SDR/DDR）</code><br>0x2：<code>x8（SDR/DDR）</code><br>0x3：Reserved</li></ul><h2 id="5-1-RESET-BOOT-BUS-CONDITIONS的作用"><a href="#5-1-RESET-BOOT-BUS-CONDITIONS的作用" class="headerlink" title="5.1  RESET_BOOT_BUS_CONDITIONS的作用"></a>5.1  <strong>RESET_BOOT_BUS_CONDITIONS的作用</strong></h2><p>1、上述EXT_CSD[177]中<code>BOOT_BUS_CONDITIONS</code>主要配置了boot 模式下的数据传输模式，但是其他模式下的timing和width模式是通过两个寄存器配置的：EXT_CSD[185]——<code>HS_TIMING</code>和EXT_CSD[183]——<code>BUS_WIDTH</code>。</p><p>2、<code>BOOT_BUS_CONDITIONS</code>是nonvolatile的，<code>HS_TIMING</code>和<code>BUS_WIDTH</code>会在<strong>硬件复位</strong>或<strong>CMD0</strong>后被reset。</p><p>3、<strong>RESET_BOOT_BUS_CONDITIONS的作用：</strong>当设置为0x1时，boot操作完成后，会自动将<code>BOOT_BUS_CONDITIONS</code>设置的模式值，设置到<code>HS_TIMING</code>和<code>BUS_WIDTH</code>中。</p><p>4、这样，通过CMD0退出boot操作后，不会复位<code>HS_TIMING</code>和<code>BUS_WIDTH</code>，但是在其他模式下发送CMD0还是会导致被reset。</p><h1 id="六、Boot分区的写保护配置"><a href="#六、Boot分区的写保护配置" class="headerlink" title="六、Boot分区的写保护配置"></a>六、Boot分区的写保护配置</h1><p>设置分区保护的目的：防止boot区的数据被erase或write。</p><ul><li>两种write protection：<br>1、<code>Permanent</code> write protection：<strong>永久生效</strong>，除非主动关闭才会失效。<br>2、<code>power-on</code> write protection：<strong>掉电</strong>后，写保护功能<strong>失效</strong>，需要每次power-on重新设置。</li></ul><p>通过配置EXT_CSD[173]——<code>BOOT_WP</code>来进行设置，该寄存器介绍如下：</p><blockquote><p><code>bit[0] = B_PWR_WP_EN</code><br>bit[1] &#x3D; B_PWR_WP_SEC_SEL<br><code>bit[2] = B_PERM_WP_EN</code><br>bit[3] &#x3D; B_PERM_WP_SEC_SEL<br>bit[4] &#x3D; <code>B_PERM_WP_DIS</code><br>bit[5] &#x3D; Reserved<br>bit[6] &#x3D; <code>B_PWR_WP_DIS</code><br><strong>bit[7] &#x3D; B_SEC_WP_SEL</strong></p></blockquote><ul><li><p>bit【7】：boot sector write protection select，<br>0x0：bit 【0、2】对两个boot分区都适用，bit【1、3】无作用；<br>0x1：bit 【0、2】仅适用于bit【1、3】分别选择的分区；</p></li><li><p>bit【1】：boot <code>power-on</code> write protection sector select，<br>0x0：若bit【7】为1，bit【0】设置给boot分区1；<br>0x1：若bit【7】为1，bit【0】设置给boot分区2；</p></li><li><p>bit【3】：boot <code>permanent</code> write protection sector select，<br>0x0：若bit【7】为1，bit【2】设置给boot分区1；<br>0x1：若bit【7】为1，bit【2】设置给boot分区2；</p></li><li><p>bit【0】：boot <code>power-on</code> write protection enable，<br>0x0：boot分区没有power-on写保护<br>0x1：有power-on写保护</p></li><li><p>bit【2】：boot <code>permanent</code> write protection enable，<br>0x0：boot分区没有permanent写保护<br>0x1：有permanen写保护</p></li><li><p>bit【4】：boot permanent write protection disabled，<br>0x0：允许bit【2】<br>0x1：禁用</p></li><li><p>bit【6】：boot powe-on write protection disabled，<br>0x0：允许bit【0】<br>0x1：禁用</p></li></ul><p>例子如下图所示：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/22.6boot%E5%8C%BA%E5%86%99%E4%BF%9D%E6%8A%A4%E4%BE%8B%E5%AD%90.png" width="75%" height="75%" alt="22.6 boot区写保护例子"/></center><p>bit【7】为1，bit【1、3】启用；</p><p>bit【1】为0说明将bit【0】赋给boot区1；</p><p>bit【3】为1说明将bit【2】赋给boot区2；</p><p>bit【0、2】都为1，说明boot区1设置了power-on写保护，boot区2设置了permanent写保护。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、boot分区容量设置&quot;&gt;&lt;a href=&quot;#一、boot分区容量设置&quot; class=&quot;headerlink&quot; title=&quot;一、boot分区容量设置&quot;&gt;&lt;/a&gt;一、boot分区容量设置&lt;/h1&gt;&lt;p&gt;一共有两个boot分区，每个的大小</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>21--eMMC的分区设置和分区访问</title>
    <link href="https://mkdbook.com/blog%E7%AC%AC%E5%87%A0%E7%AF%87.html"/>
    <id>https://mkdbook.com/blog%E7%AC%AC%E5%87%A0%E7%AF%87.html</id>
    <published>2023-04-10T07:20:57.000Z</published>
    <updated>2023-04-24T10:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、eMMC分区介绍"><a href="#一、eMMC分区介绍" class="headerlink" title="一、eMMC分区介绍"></a>一、eMMC分区介绍</h1><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/21.1%E5%88%86%E5%8C%BA%E7%A4%BA%E4%BE%8B.png" width="75%" height="75%" alt="21.1 分区示例"/></center><p>eMMC主要有三块大的分区，两个<strong>Boot Area Patition</strong>，一个<strong>RPMB</strong>分区（Replay Protected Memory Block），一块<strong>User Data Area（UDA）。</strong>UDA中可以最多划分出<code>四个General Purpose Patitions</code>，又可以为UDA某一段设置Enhanced属性，成为<code>Enhanced UDA</code>。<br>故最多有8个硬件分区（2 boot分区、1 RPMB分区、1 user分区、4 GPP分区）。</p><h2 id="各个分区的作用："><a href="#各个分区的作用：" class="headerlink" title="各个分区的作用："></a>各个分区的作用：</h2><ul><li><code>Boot分区</code>，主要用于存储Bootloader，为了支持从eMMC启动系统。</li><li><code>RPMB分区</code>，需要身份验证，存储一些防止被篡改或克隆的敏感数据，如设备标识符（MEID）、支付系统的加密密钥等。</li><li><code>GPP分区</code>，用于存储系统和应用数据。功能和UDA相似，因此有些厂商没有此分区。</li><li><code>UDA分区</code>，容量是减去分出的GPP之后的大小，通常是eMMC最大的数据。</li></ul><h1 id="二、分区配置流程"><a href="#二、分区配置流程" class="headerlink" title="二、分区配置流程"></a>二、分区配置流程</h1><ul><li>1、先判断设备是否支持分区。</li><li>2、如果支持，判断host是否要对该分区设置<strong>Enhanced attribute</strong>。</li><li>2.1、如果<strong>需要</strong>设置<strong>ENH attribute</strong>：</li></ul><blockquote><p><code>1、General Purpose Partition的数量</code><br><code>2、General Purpose Partition sizes</code>和enhanced attribute<br> 3、Enhanced User Data Area sizes，start address和enhanced attribute</p></blockquote><ul><li>2.2、如果<strong>不需要</strong>设置<strong>ENH attribute</strong>：</li></ul><blockquote><p><code>1、General Purpose Partition的数量</code><br><code>2、General Purpose Partition sizes</code></p></blockquote><p>3、PARTITIONING_SETTING_COMPLETED置位</p><h2 id="2-1-如何判断是否支持分区"><a href="#2-1-如何判断是否支持分区" class="headerlink" title="2.1  如何判断是否支持分区"></a>2.1  如何判断是否支持分区</h2><p><code>EXT_CSD[160]</code>中<code>PARTITIONING_SUPPORT</code>的bit0，如下图21.2所示：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/21.2.png" width="75%" height="75%" alt="21.2"/></center><p><code>bit[0]</code>表示设备是否支持分区，<code>bit[1]</code>表示分区（partitions and user data area）是否支持Enhance 属性，<code>bit[2]</code>表示设备是否支持extended 分区属性。本协议中规定这三种特性都支持，bit[0-2]&#x3D;1。</p><h2 id="2-2-General-Purpose-Partition的数量-x2F-Size设置"><a href="#2-2-General-Purpose-Partition的数量-x2F-Size设置" class="headerlink" title="2.2  General Purpose Partition的数量&#x2F;Size设置"></a>2.2  General Purpose Partition的数量&#x2F;Size设置</h2><p>EXT_CSD[154:143]的<code>GP_SIZE_MULT_GP0 - GP_SIZE_MULT_GP3</code>，共12个byte。</p><p><code>X</code>表示General Purpose Partition的<code>编号（1-4）</code>，<code>0-2</code>表示设置一个size这个公式的<code>3个因子</code>。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/21.3.png" width="75%" height="75%" alt="21.3"/></center><p>分区Size的计算公式，以及每一个byte代表的意义，如下21.4所示，</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/21.4.png" width="75%" height="75%" alt="21.4"/></center><p>这里有一个疑问：设置此分区的<code>数量</code>（最大4），是否是把分区的Size设置为0，就表示该分区不存在，从而分区数量减一？</p><h2 id="2-3-General-Purpose-Partition的Enh-x2F-EXT属性设置"><a href="#2-3-General-Purpose-Partition的Enh-x2F-EXT属性设置" class="headerlink" title="2.3  General Purpose Partition的Enh&#x2F;EXT属性设置"></a>2.3  General Purpose Partition的Enh&#x2F;EXT属性设置</h2><p>EXT_CSD[156]的<code>PARTITIONS_ATTRIBUTE</code>设置Enh属性（如图21.5），EXT_CSD[53:52]的<code>EXT_PARTITIONS_ATTRIBUTE</code>设置EXT属性（协议p225）。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/21.5.png" width="75%" height="75%" alt="21.5"/></center><h2 id="2-4-Enhanced-User-Data-Area的start-address-x2F-Size设置"><a href="#2-4-Enhanced-User-Data-Area的start-address-x2F-Size设置" class="headerlink" title="2.4  Enhanced User Data Area的start address&#x2F;Size设置"></a>2.4  Enhanced User Data Area的start address&#x2F;Size设置</h2><p>EXT_CSD[139:136]的<code>ENH_START_ADD</code>设置地址，EXT_CSD[142:140]的<code>ENH_SIZE_MULT</code>设置Size。（p220）</p><p>EXT_CSD[156]的<code>PARTITIONS_ATTRIBUTE</code>设置Enh属性（如图21.5）。</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><ul><li><code>General Purpose Partition</code>和<code>User Data Area</code>是两种不同的分区，它们各自设置大小、Enhanced和Extended属性。虽然前者来源于后者。</li><li><code>GPP</code>出厂默认不带，用户可以通过前文所述方法配置（1-4个）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、eMMC分区介绍&quot;&gt;&lt;a href=&quot;#一、eMMC分区介绍&quot; class=&quot;headerlink&quot; title=&quot;一、eMMC分区介绍&quot;&gt;&lt;/a&gt;一、eMMC分区介绍&lt;/h1&gt;&lt;center&gt;
&lt;img src=&quot;https://b</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>20--IMC初级使用教程</title>
    <link href="https://mkdbook.com/blog020.html"/>
    <id>https://mkdbook.com/blog020.html</id>
    <published>2023-04-10T06:18:11.000Z</published>
    <updated>2023-04-10T07:32:07.946Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="IMC收集覆盖率"><a href="#IMC收集覆盖率" class="headerlink" title="IMC收集覆盖率"></a>IMC收集覆盖率</h1><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>类似于Simvision，IMC（Incisive Metrics Center）是Cadence集成在Incisive中的一个用于覆盖率收集、分析、报告的工具。</p><p>踩坑：新版的Cadence工具已经从Incisive升级到了Xcelium，但是Xcelium不再集成IMC工具，因为IMC工具被集成在了新版的vManager工具中。</p><p>另外，由于仿真工具升级的原因，通过Xcelium仿真生成的Coverage Database无法通过Incisive中集成的IMC工具打开。故后续教程基于Incisive 151版本。</p><h1 id="二、IMC的三种启动模式"><a href="#二、IMC的三种启动模式" class="headerlink" title="二、IMC的三种启动模式"></a>二、IMC的三种启动模式</h1><h2 id="1、GUI-modo"><a href="#1、GUI-modo" class="headerlink" title="1、GUI modo"></a>1、GUI modo</h2><p>启动命令：<code>imc -gui</code></p><p><strong>IMC图形化界面。</strong></p><h2 id="2、Interactive-Command-line-modo"><a href="#2、Interactive-Command-line-modo" class="headerlink" title="2、Interactive Command-line modo"></a>2、Interactive Command-line modo</h2><p>启动命令：<code>imc -batch</code></p><p><strong>交互式命令行模式。</strong></p><h2 id="3、Batch-modo"><a href="#3、Batch-modo" class="headerlink" title="3、Batch modo"></a>3、Batch modo</h2><p>启动命令：<code>imc -exec &lt;command_file&gt;</code></p><p><strong>允许执行批量处理脚本或命令并退出，如TCL脚本。</strong></p><h1 id="三、IMC的option"><a href="#三、IMC的option" class="headerlink" title="三、IMC的option"></a>三、IMC的option</h1><p>可通过<code>imc -help</code>命令查询所有option的作用。</p><pre><code class="yaml">-batch                               run in non-gui mode-32bit                               invokes 32 bit executable-64bit                               invokes 64 bit executable-appendkey                           append keystrokes to an existing keyfile-appendlog                           append the log to an existing logfile-context                             specify application context-df                                  use default font-display &lt;arg&gt;                       display (and screen) on which to display window-enc                                 set input encoding-exec &lt;script name&gt;                  execute a script and exit-execcmd &lt;command&gt;                   execute the given tcl commands and exit-filter                              apply changes on the main table in the Regression Center-gui                                 run in gui mode-help                                print this message-init &lt;file&gt;                         run tcl commands in the given file at startup-initcmd &lt;command&gt;                   execute the given tcl commands at startup-jp                                  japanese input support-keyfile &lt;file&gt;                      specifies the file to capture keyboard input-licqueue                            use license queue mechanism-load &lt;run&gt;                          load given run at the start-load_refinement &lt;refinement file&gt;   load given refinement file at the start-logfile &lt;file&gt;                      use given file for log-memlimit &lt;limit&gt;                    determines final Java Memory limit-nocopyright                         do not print copyright information at start-nostdout                            no output on stdout-quiet                               be extra quiet-sessions_view &lt;filter&gt;              sets the specified session view at startup-sourcemap &lt;file&gt;                    use contents of given file as list of source location mappings in the form of source and                                     destination directories-status                              prints runtime statistics at the session end-verbose                             be extra verbose-version                             print the version information and exit</code></pre><h1 id="四、IMC-merge-coverage"><a href="#四、IMC-merge-coverage" class="headerlink" title="四、IMC merge coverage"></a>四、IMC merge coverage</h1><p>第一步，<code>imc -batch</code>打开batch模式。</p><p>第二步，<code>merge &lt;文件&gt; -out &lt;输出文件名&gt;</code> ，例如 merge cov_work&#x2F;scope&#x2F;* -out ALL。</p><p>第三步，<code>exit</code>，退出batch模式。然后打开 imc gui界面，把merge生成的文件load进去。</p><p>注意：如果想覆盖掉之前merge生成的文件，可以添加<code>-overwrite</code>选项。</p><h1 id="五、IMC-GUI的基本使用"><a href="#五、IMC-GUI的基本使用" class="headerlink" title="五、IMC GUI的基本使用"></a>五、IMC GUI的基本使用</h1><p>第一步，<code>imc -gui &amp;</code>启动GUI界面，并将coverage database加载进来。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/20.1IMC.png" width="75%" height="75%" alt="20.1"/></center><p>第二步，点击界面相关按钮进行分析。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/20.2IMC.png" width="75%" height="75%" alt="20.2"/></center>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;IMC收集覆盖率&quot;&gt;&lt;a href=&quot;#IMC收集覆盖率&quot; class=&quot;headerlink&quot; title=&quot;IMC收集覆盖率&quot;&gt;&lt;/a&gt;IMC收集覆盖率&lt;/h1&gt;&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=</summary>
      
    
    
    
    <category term="工具" scheme="https://mkdbook.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="IMC" scheme="https://mkdbook.com/tags/IMC/"/>
    
  </entry>
  
  <entry>
    <title>19--eMMC时序介绍</title>
    <link href="https://mkdbook.com/blog019.html"/>
    <id>https://mkdbook.com/blog019.html</id>
    <published>2023-04-05T11:52:09.000Z</published>
    <updated>2023-04-24T08:54:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、时序缩写速查"><a href="#一、时序缩写速查" class="headerlink" title="一、时序缩写速查"></a>一、时序缩写速查</h1><p>看懂eMMC时序的描述图，首先要理解其每个缩写代表的意思：</p><ul><li><code>S</code>：CMD起始位，&#x3D;<code>0</code></li><li><code>T</code>：表示后面的命令是谁发出的，<code>Host=1</code>；<code>Device=0</code>；</li><li><code>P</code>：一个周期时间的上拉，&#x3D;<code>1</code></li><li><code>E</code>：CMD结束位，&#x3D;<code>1</code></li><li><code>L</code>：一周期时间的下拉，&#x3D;<code>0</code></li><li><code>Z</code>：高阻态</li><li><code>X</code>：<code>1或0</code></li><li><code>D</code>：表示数据</li><li><code>*</code>：重复</li><li><code>CRC</code>：<code>7bit</code></li></ul><h1 id="二、命令时序和应答时序"><a href="#二、命令时序和应答时序" class="headerlink" title="二、命令时序和应答时序"></a>二、命令时序和应答时序</h1><p>有两种不同的颜色，蓝色表示Host的命令，红色表示Device的应答。根据不同的命令类型，有的命令需要应答，有的命令不需要应答。</p><h2 id="2-1-设备识别和设备工作条件时序"><a href="#2-1-设备识别和设备工作条件时序" class="headerlink" title="2.1  设备识别和设备工作条件时序"></a>2.1  设备识别和设备工作条件时序</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/19.1.png" width="75%" height="75%" alt="19.1"/></center><p>上图所示为host发送<code>CMD1或CMD2</code>分别请求device的<code>OCR或CID</code>的过程，host发送完命令后经过<code>NID</code>的<code>CLK</code>周期后，device开始<strong>在响应中</strong>返回<code>OCR或CID</code>寄存器中的内容。</p><blockquote><p>注：如果host发送<code>CMD2（ALL_SEND_CID）</code>后没有收到device的应答，host就认为总线上没有device的存在。</p></blockquote><h2 id="2-2-为设备分配相对地址"><a href="#2-2-为设备分配相对地址" class="headerlink" title="2.2  为设备分配相对地址"></a>2.2  为设备分配相对地址</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/19.2.png" width="75%" height="75%" alt="19.2"/></center><p><code>CMD3（SET_RCA）</code>，device接收到其RCA后就切换到Data transfer模式。</p><h2 id="2-3-Data-transfer模式"><a href="#2-3-Data-transfer模式" class="headerlink" title="2.3  Data transfer模式"></a>2.3  Data transfer模式</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/19.3.png" width="75%" height="75%" alt="19.3"/></center><p>可以看着这里和前两个时序的区别是：不是间隔<code>Z</code>，而是间隔<code>P（host/device主动拉高）</code>。</p><blockquote><p>注：只有<code>CMD1、2、3</code>中间全是Z（针对有应答的CMD而言）。</p></blockquote><h2 id="2-4-R1b应答"><a href="#2-4-R1b应答" class="headerlink" title="2.4  R1b应答"></a>2.4  R1b应答</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/19.4.png" width="75%" height="75%" alt="19.4"/></center><p>带Busy信号的的应答，在host命令后隔两个周期<code>DAT0线拉低</code>，<code>表示Busy</code>。其他几根DAT线的值无所谓。</p><h2 id="2-5-上一Device应答——-gt-下一host命令"><a href="#2-5-上一Device应答——-gt-下一host命令" class="headerlink" title="2.5  上一Device应答——&gt;下一host命令"></a>2.5  上一Device应答——&gt;下一host命令</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/19.5.png" width="75%" height="75%" alt="19.5"/></center><h2 id="2-6-上一host命令——-gt-下一host命令"><a href="#2-6-上一host命令——-gt-下一host命令" class="headerlink" title="2.6   上一host命令——&gt;下一host命令"></a>2.6   上一host命令——&gt;下一host命令</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/19.6.png" width="75%" height="75%" alt="19.6"/></center><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>1、两段之间的CLK间隔<code>N**</code>，在协议中<code>Timing Patameters</code>表格中有具体规定。（协议P154）</p><p>2、时序中的<code>CMD</code>格式是和<a href="https://mkdbook.com/blog016.html#:~:text=%E7%9A%84CRC%E4%BF%9D%E6%8A%A4-,16.2%20CMD%20token,-eMMC%E7%9A%84%E5%91%BD%E4%BB%A4">Command Format</a>对的上的。</p><p>3、时序中的<code>Response</code>格式取决于每种命令对应的应答类型，每种类型的bit位描述在协议中都有具体表格说明。（P136）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、时序缩写速查&quot;&gt;&lt;a href=&quot;#一、时序缩写速查&quot; class=&quot;headerlink&quot; title=&quot;一、时序缩写速查&quot;&gt;&lt;/a&gt;一、时序缩写速查&lt;/h1&gt;&lt;p&gt;看懂eMMC时序的描述图，首先要理解其每个缩写代表的意思：&lt;/p&gt;</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>18--eMMC的Secure Erase和Secure Trim操作</title>
    <link href="https://mkdbook.com/blog018.html"/>
    <id>https://mkdbook.com/blog018.html</id>
    <published>2023-04-05T05:11:21.000Z</published>
    <updated>2023-04-05T11:50:45.089Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、Secure-Erase"><a href="#一、Secure-Erase" class="headerlink" title="一、Secure Erase"></a>一、Secure Erase</h1><p><code>Secure Erase</code>命令和基本的<code>Erase</code>命令不同，它要求设备在发出此命令后，device和host在进入下一个操作之前必须<strong>等待Erase物理地完成</strong>。<br><code>Secure Erase</code>命令的执行方式与Erase命令相同，只是CMD38中<code>bit[31]=1</code>，其他参数为0；<br>CMD38 四个重要的bit位说明如图所示：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/18.1CMD38%E9%87%8D%E8%A6%81bit%E4%BD%8D.png" width="75%" height="75%" alt="18.1 CMD38重要bit位"/></center><h1 id="二、Secure-Trim"><a href="#二、Secure-Trim" class="headerlink" title="二、Secure Trim"></a>二、Secure Trim</h1><p><code>Secure Trim</code>是对<code>write block</code>执行安全擦除操作，确保数据完全地从memory中物理擦除。</p><p><strong>启动方法有两步：</strong></p><ol><li><code>步骤1</code>：host定义它标记为Secure TRIM的write block的范围（通过CMD35、CMD36），一旦确定了范围，CMD38（<code>bit[31],bit[0]设置为1</code>，其他位为0）就会被应用。</li></ol><blockquote><p>步骤1可以重复多次，中间允许有其他命令，直到所有需要清除的write block都被明确定义。建议尽可能在多的block上进行Secure TRIM的步骤1，以提高Secure TRIM的效率。</p></blockquote><ol start="2"><li><code>步骤2</code>：发送夹带地址的CMD35和CMD36（注意与这些命令一起使用的参数将被忽略），然后发送CMD38（<code>bit[31],bit[15]为1</code>，其他为0）。这一步实际上是根据<code>Secure_Removal_type(EXT_CSD [16])</code>（<a href="https://mkdbook.com/blog017.html#:~:text=17.4%20Secure_Removal_type">图17.4</a>），对<strong>所有的write block以及它的所有副本</strong>执行Secure Trim，这些write block在步骤1中已被标记。</li></ol><blockquote><p>在步骤1和步骤2之间，可以向设备发出其他命令。</p></blockquote><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><h2 id="1、隐式（implicit）擦除和显式（explicit）擦除"><a href="#1、隐式（implicit）擦除和显式（explicit）擦除" class="headerlink" title="1、隐式（implicit）擦除和显式（explicit）擦除"></a>1、隐式（implicit）擦除和显式（explicit）擦除</h2><p><code>隐式擦除</code>是指device中的某些数据被简单地标记成已删除，host可以向device该位置写数据。但是在技术上，memory里面的数据在overwrite之前还存在device中，甚至通过某些手段能够恢复数据。<br><code>显式擦除</code>则是一个更彻底的过程，用新数据（0&#x2F;1）覆盖掉原来的数据，保证删除的数据是无法被恢复的。<br>所以，隐式擦除速度更快、更简单，但是数据有被恢复的潜在风险。显式擦除反之。</p><h2 id="2、Secure-Erase和Erase的区别；Secure-Trim和TRIM的区别；"><a href="#2、Secure-Erase和Erase的区别；Secure-Trim和TRIM的区别；" class="headerlink" title="2、Secure Erase和Erase的区别；Secure Trim和TRIM的区别；"></a>2、Secure Erase和Erase的区别；Secure Trim和TRIM的区别；</h2><p>着重理解这里的<code>Secure</code>，是指要保证数据完全、永久地从device删除，不能被恢复，采取的是显示擦除的overwrite的方法。<br>而不带Secure的操作仅仅<code>被标记为删除</code>，device可能还没有实际进行overwrite，数据可能被恢复。</p><h2 id="3、新的eMMC版本中，Secure操作被取代"><a href="#3、新的eMMC版本中，Secure操作被取代" class="headerlink" title="3、新的eMMC版本中，Secure操作被取代"></a>3、新的eMMC版本中，Secure操作被取代</h2><p>为了向后兼容，保留了Secure Erase和Secure TRIM，但在v4.51之后这两种方式分别以<code>Erase+Sanitize</code>和<code>TRIM+Sanitize</code>的方式实现。<br>Sanitize操作就是能实际地通过overwrite的方式，将数据擦除。故结合使用，<code>标记+删除</code>结合就可以实现<code>Secure</code>的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、Secure-Erase&quot;&gt;&lt;a href=&quot;#一、Secure-Erase&quot; class=&quot;headerlink&quot; title=&quot;一、Secure Erase&quot;&gt;&lt;/a&gt;一、Secure Erase&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Sec</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>17--eMMC的Erase、TRIM、Sanitize、Discard操作</title>
    <link href="https://mkdbook.com/blog017.html"/>
    <id>https://mkdbook.com/blog017.html</id>
    <published>2023-04-05T03:38:53.000Z</published>
    <updated>2023-04-05T04:51:23.970Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、eMMC地址空间（mapped-or-unmapped）"><a href="#一、eMMC地址空间（mapped-or-unmapped）" class="headerlink" title="一、eMMC地址空间（mapped or unmapped）"></a>一、eMMC地址空间（mapped or unmapped）</h1><p>可以粗略地将Flash分为两种类型：<code>raw</code>和<code>managed</code>。原始的Flash（raw类型）单个cell的P&#x2F;E寿命是有限的，如果长期只对某些固定的block或cell进行使用，很容易造成局部损坏，故需要进行“<code>wear leveling</code>”减少这种损坏概率。显然eMMC属于managed的Flash设备。</p><p>在eMMC中有三种类型的地址空间：</p><ul><li><code>Mapped Host Address Space</code>：e•MMC设备中，<strong>可通过</strong>host的读取命令访问的区域。</li><li><code>Unmapped Host Address Space</code>：<strong>不能</strong>被host通过读取命令访问。它可能包含old host data或者copies of host data。</li><li><code>Private Vendor Specific Address Space</code>：<strong>不能</strong>被host通过读取命令访问。包含如mapping tables、Firmware等数据。</li></ul><h2 id="映射举例详解"><a href="#映射举例详解" class="headerlink" title="映射举例详解"></a>映射举例详解</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/17.1%E4%BE%8B1.png" width="58%" height="58%" alt="17.1 例1"/></center><p>例1比较简单，物理地址空间有12个，实际映射了8个block，即3-bit的address space。当从编号3的block开始写入3-block-data时，实际映射到了物理空间的3-5；</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/17.2%E4%BE%8B2.png" width="37%" height="37%" alt="17.2 例2"/></center><p>例2，实际中3、4、5已经被写入数据了，若修改编号5的数据。<br>理论上应该擦除物理地址空间的5，然后再写入，<code>但擦除时间远长于写入时间</code>，因此不采用此方法。</p><p>实际上操作如下：（前提是这里假设的Erase最小对齐长度为2个block）</p><ul><li>1、<code>重新map 4、5</code>到物理地址空间的<code>8、9</code>，</li><li>2、将之前<code>4</code>的数据写到<code>8</code>，因为没有改变4的值，</li><li>3、最后将改变的新数据写入第<code>9</code>。</li></ul><h2 id="unmapped-block中残留数据的由来"><a href="#unmapped-block中残留数据的由来" class="headerlink" title="unmapped block中残留数据的由来"></a>unmapped block中残留数据的由来</h2><p>如例2，通过更新映射表，将数据写入到之前未映射的空block，比直接擦除第4、5块再写入同一位置的速度快的多（因为擦除速度很慢）。<br>但是，由于通过修改映射表写入了空block，导致了之前映射的block就变成了<code>未映射但有数据</code>。</p><h1 id="二、Erase"><a href="#二、Erase" class="headerlink" title="二、Erase"></a>二、Erase</h1><p>基本Erase的单元是“<code>Erase Group</code>”，如果EXT_CSD中<code>ERASE_GROUP_DEF [175]</code> 处于<code>enabled</code>时，则Erase Group在<strong>EXT_CSD</strong>中定义。<code>disabled</code>时，在<strong>CSD</strong>中定义。<br>当Erase成功后，设备中被擦除的<code>mapped device address range</code>为全0&#x2F;1（取决于memory技术，在EXT_CSD[181]中<code>ERASE_MEM_CONT</code>定义）。</p><p>启动Erase分为三步：</p><ul><li>1、Host 通过 ERASE_GROUP_START（CMD35）命令，定义范围的起始地址；</li><li>2、接下来用 ERASE_GROUP_END（CMD36）命令，定义范围的最后地址；</li><li>3、最后终通过发送参数设置为 0 的 ERASE（CMD38）命令，启动Erase进程。（CMD38 参数见下表）</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/17.3CMD38%E5%8F%82%E6%95%B0%E5%AE%9A%E4%B9%89.png" width="60%" height="60%" alt="17.3 CMD38参数定义"/></center><h1 id="三、TRIM"><a href="#三、TRIM" class="headerlink" title="三、TRIM"></a>三、TRIM</h1><p>TRIM适用于对“<code>write blocks</code>”进行擦除。可以允许host识别不需要的data，然后device在后台擦除事件中擦除数据。当TRIM成功后，设备中被擦除的<code>mapped device address range</code>为全0&#x2F;1。<br>TRIM的结果是简单地将<code>mapped host address range</code>变为<code>unmapped host address range</code> 。</p><p>启动TRIM分为三步：</p><ul><li>1、Host 通过 ERASE_GROUP_START（CMD35）命令，定义范围的起始地址；（指定write block，非erase group）</li><li>2、接下来用 ERASE_GROUP_END（CMD36）命令，定义范围的最后地址；指定write block，非erase group）</li><li>3、最后发送参数 bit[0] 为1，其他bit位为 0 的 ERASE（CMD38）命令启动TRIM过程；</li></ul><h1 id="四、Sanitize"><a href="#四、Sanitize" class="headerlink" title="四、Sanitize"></a>四、Sanitize</h1><p>Sanitize从设备<code>unmapped user address space</code>中physically移除数据，根据<code>Secure_Removal_type(EXT_CSD [16])</code>。当完成Sanitize操作后，<code>unmapped host address space</code>就不存在数据了。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/17.4Secure_Removal_type.png" width="75%" height="75%" alt="17.4 Secure_Removal_type"/></center><blockquote><p>bit[5:4]：配置安全移除类型（可读可写）<br>  <em><code>0x0</code>：通过擦除物理内存来删除信息；</em><br>  <em><code>0x1</code>：用一个字符覆盖寻址位置，然后进行擦除，从而删除信息；</em><br>  <em><code>0x2</code>：通过用一个字符、其补码和一个随机字符覆盖寻址位置来删除信息；</em><br>  <em><code>0x3</code>：用供应商定义的方法删除信息；</em><br>bit[3:0]：支持的安全移除类型（可读）<br>bit[0]、bit[1]、bit[2]、bit[3]的描述分别对应上述的0x0、0x1、0x2、0x3</p></blockquote><p><strong>启动Sanitize的方法：向EXT_CSD[165]——<code>SANITIZE_START</code>写入任何值</strong>。当设备执行Sanitize操作时，busy信号建立，直到如下事件发生时结束：</p><ul><li>Sanitize操作完成；</li><li>利用HPI中止此操作；</li><li>power failure；</li><li>硬件复位；</li></ul><h1 id="五、Discard"><a href="#五、Discard" class="headerlink" title="五、Discard"></a>五、Discard</h1><p>类似于TRIM，区别如下：</p><ul><li>对被 Discard 区域进行读取，可能返回一些或全部原来的数据。<br>但是，在 TRIM 的情况下，整个区域将成为未映射或被移除，并将取决于存储器工艺返回 0 或 1。</li><li>当执行 Sanitize 时，只有被Discard命令丢弃的<strong>未映射区域的数据</strong>，这部分才能被 Sanitize 移除。<br>Device 不能保证在实施 Sanitize 时，被Discard 的数据完全从 Device 中移除。</li></ul><p>启动Discard分为三步：</p><ul><li>1、Host 通过 ERASE_GROUP_START（CMD35）命令，定义范围的起始地址；（指定write block，非erase group）</li><li>2、接下来用 ERASE_GROUP_END（CMD36）命令，定义范围的最后地址；指定write block，非erase group）</li><li>3、最后发送参数 bit[0]，bit[1] 为 1 ，其他bit位为 0 的 ERASE（CMD38）命令启动Discard过程；</li></ul><h1 id="六、总结四种方式区别"><a href="#六、总结四种方式区别" class="headerlink" title="六、总结四种方式区别"></a>六、总结四种方式区别</h1><p>1、Sanitize用于unmapped的地址空间进行<code>物理擦除</code>，而其它三种都是针对mapped的地址空间（仅修改映射，并标记为擦除）。</p><p>2、Erase针对<code>erase group</code>，TRIM和Discard针对独立的<code>write block</code>，后者更加灵活。</p><p>3、<code>Erase/TRIM</code>和<code>Discard</code>（<em><strong>partial or full the actual erase</strong></em>）的区别在一个partial，即Discard的清除是不完整的，部分的、结果是不确定的。</p><p>4、故通过<code>Erase或TRIM</code>擦除<code>mapped address space</code>中的所有数据；<br>再触发<code>Sanitize</code>操作，清除<code>遗留在unmapped address space</code>中的任何数据；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、eMMC地址空间（mapped-or-unmapped）&quot;&gt;&lt;a href=&quot;#一、eMMC地址空间（mapped-or-unmapped）&quot; class=&quot;headerlink&quot; title=&quot;一、eMMC地址空间（mapped o</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>16--eMMC命令整体概述</title>
    <link href="https://mkdbook.com/blog016.html"/>
    <id>https://mkdbook.com/blog016.html</id>
    <published>2023-03-26T10:01:13.000Z</published>
    <updated>2023-04-05T11:39:33.664Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="eMMC-5-1协议CMD中文翻译"><a href="#eMMC-5-1协议CMD中文翻译" class="headerlink" title="eMMC 5.1协议CMD中文翻译"></a>eMMC 5.1协议CMD中文翻译</h1><p><a href="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/pdf-share/eMMC5.1CMD%E4%B8%AD%E6%96%87%E8%A7%A3%E9%87%8A.pdf">下载地址</a></p><h1 id="一、CMD-line模式"><a href="#一、CMD-line模式" class="headerlink" title="一、CMD line模式"></a>一、CMD line模式</h1><ul><li>CMD line modes overview</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/16.1CMD%20line%20modes.png" width="80%" height="80%" alt="16.1 CMD line modes"/></center>    <p>如图16.1所示，eMMC设备共有16种状态，分别分类到5种操作模式中，CMD line mode又有两种类型。</p><h1 id="二、寄存器"><a href="#二、寄存器" class="headerlink" title="二、寄存器"></a>二、寄存器</h1><p>eMMC共有7种不同类型的寄存器。</p><ul><li><code>OCR</code>：Operation Conditons Register，<code>32-bit</code>；<strong>CMD1</strong>操作；</li><li><code>CID</code>：Device IDentification Register，<code>128bit</code>；<strong>CMD2</strong>操作；</li><li><code>CSD</code>：Device-Specific Data register，<code>128bit</code>；<strong>CMD9、27</strong>操作；</li><li><code>EXT_CSD</code>：Extend CSD，<code>512byte</code>，320（属性、不可被host更改）+192；<strong>CMD6</strong>操作；</li><li><code>RCA</code>：Relative Decive Address register，<code>16-bit</code>；<strong>CMD3</strong>操作；</li><li><code>DSR</code>：Driver Stage Register，<code>16bit</code>；<strong>CMD4</strong>操作；</li><li><code>QSR</code>：Queue Status Register，<code>32bit</code>；<strong>CMD13</strong>；</li></ul><h1 id="三、CMD"><a href="#三、CMD" class="headerlink" title="三、CMD"></a>三、CMD</h1><ul><li>Command Format，一条命令的格式如图所示：<blockquote><p>固定为48个bit；<br>起始位分别为0和1；<br>bit[46]，为1则命令由host发出，为0则为Device发出；<br>bit[39:8]，有些CMD需要带参数（例如带address）；<br>每条命令被7bit的CRC保护</p></blockquote></li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/16.2CMD%20Format.png" width="90%" height="90" alt="16.2 CMD token"/></center><p>eMMC的命令一共有64个，从<code>CMD0</code>-<code>CMD63</code> ，在Command token的bit[45:40]表征。它们按照不同的功能集划分，又隶属于13个Class。</p><h2 id="3-1-命令的13个Class："><a href="#3-1-命令的13个Class：" class="headerlink" title="3.1 命令的13个Class："></a>3.1 <strong>命令的13个Class：</strong></h2><ul><li>Class 0：<code>basic</code></li><li>Class 1：<code>Obsolete</code></li><li>Class 2：<code>block read</code></li><li>Class 3 ：<code>Obsolete</code></li><li>Class 4：<code>block write</code></li><li>Class 5：<code>erase</code></li><li>Class 6：<code>write protection</code></li><li>Class 7：<code>lock Device</code></li><li>Class 8：<code>Application-specific</code></li><li>Class 9：<code>I/O mode</code></li><li>Class10：<code>Security Protocols</code></li><li>Class11：<code>Command Queuing</code></li><li>Class12：<code>Reserved</code></li></ul><h2 id="3-2-命令一共有一共有4种类型："><a href="#3-2-命令一共有一共有4种类型：" class="headerlink" title="3.2 命令一共有一共有4种类型："></a>3.2 <strong>命令一共有一共有4种类型：</strong></h2><ul><li><code>bc</code>：Broadcast CMD，no Respose。</li><li><code>bcr</code>：广播、有应答。</li><li><code>ac</code>：Addressed（point-to-point）CMD，DAT线上无数据。</li><li><code>adtc</code>：Addressed（point-to-point）data transfer CMD，DAT线上有数据。</li></ul><h2 id="3-3-命令的应答一共有5种类型："><a href="#3-3-命令的应答一共有5种类型：" class="headerlink" title="3.3 命令的应答一共有5种类型："></a>3.3 <strong>命令的应答一共有5种类型：</strong></h2><ul><li><code>R1</code>：normal response command。响应常用命令。<br><code>R1b</code>：和R1区别是，有一个可选的busy信号（和R1属于同一类型）。</li><li><code>R2</code>：CID，CSD register。响应CMD2、10、9，并将CID和CSD的值作为响应的返回数据。</li><li><code>R3</code>：OCR register。OCR的值作为对CMD1的响应发送给host。</li><li><code>R4</code>：Fast I&#x2F;O。</li><li><code>R5</code>：Interrupt request。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;eMMC-5-1协议CMD中文翻译&quot;&gt;&lt;a href=&quot;#eMMC-5-1协议CMD中文翻译&quot; class=&quot;headerlink&quot; title=&quot;eMMC 5.1协议CMD中文翻译&quot;&gt;&lt;/a&gt;eMMC 5.1协议CMD中文翻译&lt;/h1&gt;</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="eMMC" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/eMMC/"/>
    
    
    <category term="eMMC" scheme="https://mkdbook.com/tags/eMMC/"/>
    
  </entry>
  
  <entry>
    <title>15--Program、Read、Erase实现逻辑-项目1-2</title>
    <link href="https://mkdbook.com/blog015.html"/>
    <id>https://mkdbook.com/blog015.html</id>
    <published>2023-03-21T14:20:46.000Z</published>
    <updated>2023-03-24T08:08:08.016Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><ol><li>图1</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.1.png" width="100%" height="100%" alt="图1"/></center><ol start="2"><li>图2</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.2.png" width="100%" height="100%" alt="图2"/></center><ol start="3"><li>图3</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.3.png" width="100%" height="100%" alt="图3"/></center> <ol start="4"><li>图4</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.4.png" width="100%" height="100%" alt="图4"/></center> <ol start="5"><li>图5</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.5.png" width="100%" height="100%" alt="图5"/></center> <ol start="6"><li>图6</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.6.png" width="100%" height="100%" alt="图6"/></center> <ol start="7"><li>图7</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.7.png" width="100%" height="100%" alt="图7"/></center>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;图1&lt;/li&gt;
&lt;/ol&gt;
&lt;center&gt;
&lt;img src=&quot;https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/15.1.png&quot; width=&quot;10</summary>
      
    
    
    
    <category term="项目" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="项目1-Nand_behavior_model" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1-Nand-behavior-model/"/>
    
    
    <category term="NAND" scheme="https://mkdbook.com/tags/NAND/"/>
    
  </entry>
  
  <entry>
    <title>14--NAND behavior model说明-项目1-1</title>
    <link href="https://mkdbook.com/blog014.html"/>
    <id>https://mkdbook.com/blog014.html</id>
    <published>2023-03-21T14:19:56.000Z</published>
    <updated>2023-03-24T08:08:02.722Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]<br>前言，本项目是我刚接触NAND，为了熟悉NAND其功能的一个练手项目。项目功能比较单一，Array的Size也比较小。</p><h1 id="一、项目功能描述"><a href="#一、项目功能描述" class="headerlink" title="一、项目功能描述"></a>一、项目功能描述</h1><ul><li><strong>Program</strong> （80h-10h）</li><li><strong>Read</strong>       （00h-30h）</li><li><strong>Erase</strong>      （60h-D0h）</li></ul><h1 id="二、Array-Size定义"><a href="#二、Array-Size定义" class="headerlink" title="二、Array Size定义:"></a>二、Array Size定义:</h1><ul><li>Plane： 1个   （total）</li><li>Block： 4个   （4 in a plane）</li><li>Page ：256个 （total 256，64 in a block）</li><li>Byte  ：128个 （128 in a page）</li></ul><h1 id="三、model文件说明"><a href="#三、model文件说明" class="headerlink" title="三、model文件说明"></a>三、model文件说明</h1><ul><li><code>nand_falsh_model.v</code>： 实现Program、Read、Erase功能的设计文件</li><li><code>parameters.vh</code> ： 设计和tb中的参数定义，包括容量、地址、时序等参数</li><li><code>subtest.v</code> ： 用于调用tb中相关task，实现定向测试</li><li><code>tb.v</code> ： 包含测试激励的产生和相关测试的task</li></ul><h1 id="四、NAND-Flash内部空间层次"><a href="#四、NAND-Flash内部空间层次" class="headerlink" title="四、NAND Flash内部空间层次"></a>四、NAND Flash内部空间层次</h1><p>如图14.1，对于单个LUN的NAND Flash的内部空间，从大到小排列如下：<br><code>LUN ——&gt; Plane ——&gt; block ——&gt; page ——&gt; byte</code></p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/14.1NAND%E5%86%85%E9%83%A8%E7%A9%BA%E9%97%B4%E5%B1%82%E6%AC%A1%E5%9B%BE.png" width="40%" height=40%" alt="14.1 NAND 内部空间层次"/></center><p>可以看到，这个LUN包含了4个Plane，<br>每一个Plane包含一个PAGE REGISTER；<br>每个Plane中Block的个数应该是1980&#x2F;4个；<br>每一个Block中包含了2304个page。</p><blockquote><p>注意：Block的编号问题，block 0，1，2，3分别属于四个不同的plane，所以每隔4个Block处于一个Plane。</p></blockquote><h1 id="五、本项目容量定义"><a href="#五、本项目容量定义" class="headerlink" title="五、本项目容量定义"></a>五、本项目容量定义</h1><ol><li>容量计算方式为：<code>plane数量 * block数量 * page数量 * 每个page里面byte的个数</code> <ul><li>1 byte &#x3D; 8 bits ；1 word &#x3D; 16 bits</li></ul></li><li>代码中对应参数设置如图14.2所示：</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/14.2%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E5%AE%9A%E4%B9%89.png" width="40%" height="40%" alt="14.2 容量相关参数定义"/></center><p><code>NUM_PLANES</code> ：总共的 plane 数</p><p><code>NUM_BLCK</code>    ：最大的 block 数（不代表一定有这么多，但是不能超过这个数）</p><p><code>NUM_PAGE</code>    ：1个 block 中包含的 page数</p><p><code>NUM_ROW</code>     ：总共的 page 数</p><p><code>NUM_COL</code>     ：每个 page 中的 byte 数</p><p><code>PAGE_SIZE</code>  ：每个 page 中的 bit 数</p><ol start="3"><li>如图14.3所示，我这里一共定义了256个page，分别平分给4个Block，每个Block有64个Page，它们的编号各自都从<code>Page 0</code>-<code>Page 63</code> 。</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/14.3Block%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" width="40%" height="40%" alt="14.3 Block层次结构"/></center><ol start="4"><li>如图14.4所示，1个Page定义了128个Byte，而每个Byte有8个BIt，故1个Page一共有1024个Bit，编号为<code>Bit 0</code>-<code>Bit 1023</code>。<br>注意：这里如果要在一个Memory Array中找到相应的Byte，应该<code>Byte 0：Bit 0-Bit 7</code>；<code>Byte 1：Bit 8-Bit 15</code>；以此类推。</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/14.4Page%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" width="40%" height="40%" alt="14.4 Page层次结构"/></center><h1 id="五、本项目地址处理"><a href="#五、本项目地址处理" class="headerlink" title="五、本项目地址处理"></a>五、本项目地址处理</h1><p>如图所示，</p><ul><li>Row address（行地址）：寻址 LUN、Block、Page</li><li>Column address（列地址）：寻址 Page 中的 Byte</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/14.5NAND%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" width="70%" height="70%" alt="14.5 NAND地址分类"/></center><p>TB中关于地址的处理如下：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/14.6TB%E5%A4%84%E7%90%86%E5%9C%B0%E5%9D%80.png" width="70%" height="70%" alt="14.6 TB处理地址"/></center><ul><li><p>function功能说明： block地址有10位，page地址有6位； 一次只能传8bit  第一个row地址由block_addr 低两位  + page_addr 组成。</p></li><li><p>CA 定义了12个 bit，RA定义了16个bit，而总线只有8个 IO 口，只能分两次传。</p></li><li><p>COL_BITS &#x3D;12；PAGE_BITS&#x3D;6。</p></li><li><p>col_addr_1 <code>传低八位</code>。</p></li><li><p>col_addr_2 的<code>低四位</code>传CA的<code>高四位</code>，col_addr_2的<code>高四位</code>用<code>0</code>填充。</p></li><li><p>row_addr_1 传 <code>[2bit block_addr + 6bit page_addr]</code>。</p></li><li><p>row_addr_2 传 <code>[8bit block地址]</code>。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;br&gt;前言，本项目是我刚接触NAND，为了熟悉NAND其功能的一个练手项目。项目功能比较单一，Array的Size也比较小。&lt;/p&gt;
&lt;h1 id=&quot;一、项目功能描述&quot;&gt;&lt;a href=&quot;#一、项目功能描述&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="项目" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="项目1-Nand_behavior_model" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1-Nand-behavior-model/"/>
    
    
    <category term="NAND" scheme="https://mkdbook.com/tags/NAND/"/>
    
  </entry>
  
  <entry>
    <title>13--perl练习-生成五组不同随机数-双色球</title>
    <link href="https://mkdbook.com/blog013.html"/>
    <id>https://mkdbook.com/blog013.html</id>
    <published>2023-03-20T14:07:47.000Z</published>
    <updated>2023-03-24T08:09:20.619Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="perl练习，源码"><a href="#perl练习，源码" class="headerlink" title="perl练习，源码"></a>perl练习，源码</h1><pre><code class="perl">#!/usr/bin/perl -w$zhu = 1;do&#123;    my %red;                         #hash    for (0..5) &#123;        my $no;        do &#123;            $no = int rand(33) +1;  # int [1:33]                 &#125; while (exists $red&#123;$no&#125;); # $no is hash&#39;s key           $red&#123;$no&#125; = 1;    &#125;    my $blue=int rand(16) +1;       #int [1:16]              print join(&quot;\t&quot;, keys %red, &quot;$blue&quot;), &quot;\n\n&quot;;    $zhu = $zhu +1;   #initial 5 zhu&#125;while($zhu &lt;= 5);</code></pre><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol><li><code>rand(16)</code>表示生成<code>0-15</code>的随机数，要生成<code>1-16</code>直接增加偏移量<code>+1</code>即可。</li><li>hash的用法：这里用到了hash的<code>exists</code>函数检测<code>key</code>，让随机产生的数不同。<br>这里是指，如果<strong>hash</strong><code>%red</code>中存在<strong>key</strong><code>$no</code>，则返回再生成一次随机数；</li></ol><pre><code class="perl">             #keys values my %hash = (&quot;a&quot; =&gt; 9, &quot;b&quot; =&gt; 1, &quot;c&quot; =&gt; 8);my @k = keys %hash;                #取出hash中的 key 或 value，列表上下文my @v = values %hash;my $x = keys %hash;               # 标量上下文，得到的是对数#exists 检测hash中是否存在某一个hashif (exists $hash&#123;&quot;b&quot;&#125;)&#123;    #用 $ 符号，别搞错了print &quot;hash里面有b&quot;&#125;</code></pre><ol start="3"><li><code>jonit</code> 函数是指用分隔符 <code>\t</code> 分割每一个<code>key</code>的值。</li><li><code>do&#123;&#125;…while()</code> 表达式产生5组数据。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;perl练习，源码&quot;&gt;&lt;a href=&quot;#perl练习，源码&quot; class=&quot;headerlink&quot; title=&quot;perl练习，源码&quot;&gt;&lt;/a&gt;perl练习，源码&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;#!/usr/b</summary>
      
    
    
    
    <category term="语言" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Perl" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/Perl/"/>
    
    
    <category term="perl" scheme="https://mkdbook.com/tags/perl/"/>
    
  </entry>
  
  <entry>
    <title>12--Perl模块-读取文件并修改然后保存</title>
    <link href="https://mkdbook.com/blog012.html"/>
    <id>https://mkdbook.com/blog012.html</id>
    <published>2023-03-20T14:07:20.000Z</published>
    <updated>2023-03-24T08:09:15.206Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、Perl模块，源码"><a href="#一、Perl模块，源码" class="headerlink" title="一、Perl模块，源码"></a>一、Perl模块，源码</h1><pre><code class="perl">#! /usr/bin/perl -wuse strict;open RH, &quot;test28.v&quot; or die $!;chomp(my @lines = &lt;RH&gt;);close (RH);open WH, &quot;&gt;test28.v&quot; or die $!;foreach my $line (@lines) &#123;  $line =~ s/a/b/gi;  print WH &quot;$line\n&quot;;&#125;close (WH);</code></pre><p>第一步，打开文件句柄（RH）读取文件，并将其一行一行地全部存入到数组<code>@lines</code>。</p><p>第二步，打开文件句柄（WH）写入文件通道，用foreach将数组<code>@lines</code>中的一个元素（一行内容）存入到变量<code>$lines</code>。</p><p>第三步，通过变量<code>$lines</code>，对这一行内容进行匹配替换，再重新保存到<code>$line</code>变量。</p><p>最后，将这一行修改后的内容打印出来通过句柄（WH）<code>写入</code>到源文件中。</p><h2 id="Perl文件句柄中的写入操作符"><a href="#Perl文件句柄中的写入操作符" class="headerlink" title="Perl文件句柄中的写入操作符"></a>Perl文件句柄中的写入操作符</h2><pre><code class="perl">&gt;    #覆盖写入， 如果不存在则会创建，然后清空，print重新写入&gt;&gt;   #追加写，文件指针指向末尾，再开始写+&gt;   #Reads, Writes, Creates, and Truncates+&gt;&gt;  #Reads, Writes, Appends, and Creates</code></pre><h2 id="Perl文件句柄中的读取操作符"><a href="#Perl文件句柄中的读取操作符" class="headerlink" title="Perl文件句柄中的读取操作符"></a>Perl文件句柄中的读取操作符</h2><pre><code class="perl">&lt;    #只读模式+&lt;   #Reads and Writes</code></pre><h2 id="为什么要chmop？"><a href="#为什么要chmop？" class="headerlink" title="为什么要chmop？"></a>为什么要chmop？</h2><p>如果文件元素为：</p><pre><code> aaaaaaaa    bbbbbbbbbbCccccccccccc</code></pre><pre><code class="perl">chomp(my @lines = &lt;RH&gt;);print &quot;@lines&quot;;#加上chmop，会删除换行，但是源文件每一行的空格还是会保留下来aaaaaaaa     bbbbbbbbbb Cccccccccccc#不加，原样保留，每一行的换行符被保留了下来aaaaaaaa     bbbbbbbbbb Cccccccccccc</code></pre><p>为了方便数据处理，所以一般加上<code>chomp</code>，比如再对一行元素进行拆分时，拆分后的最后一个元素就会带有换行符，与其他元素不同。如果最后需要加上换行符，可以这样操作：<code>print &quot;$_\n&quot;;</code></p><h1 id="二、通过命令行批量替换文件内容"><a href="#二、通过命令行批量替换文件内容" class="headerlink" title="二、通过命令行批量替换文件内容"></a>二、通过命令行批量替换文件内容</h1><p><code>find ./ -name &quot;*.v&quot; | xargs perl -pi.bak -e &quot;s/Lock &lt;= 1&#39;b0;/&quot;&quot;/gi&quot;</code></p><p><code>xargs</code>：是一个linux命令，作用是捕获一个命令的输出，然后传递给另一个命令（一般和管道一起使用）</p><p><code>perl -e</code>：在命令行中执行代码，即上面执行了通过这个option执行了<code>&quot;s/Lock &lt;= 1&#39;b0;/&quot;&quot;/gi&quot;</code>匹配替换</p><p><code>perl -p</code>：自动循环+自动输出，相当于<code>while(&lt;&gt;)&#123;替换语句;print;&#125;</code></p><p><code>perl -i&lt;扩展名&gt;</code>：原地替换文件，并将旧文件用指定的扩展名备份。不指定扩展名则不备份。</p><p><code>g</code>：修饰符，全局匹配（能匹配到所有的abc，不会因为匹配到一个就停止后面内容的匹配了）</p><p><code>i</code>：修饰符，匹配时忽略大小写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、Perl模块，源码&quot;&gt;&lt;a href=&quot;#一、Perl模块，源码&quot; class=&quot;headerlink&quot; title=&quot;一、Perl模块，源码&quot;&gt;&lt;/a&gt;一、Perl模块，源码&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;</summary>
      
    
    
    
    <category term="语言" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Perl" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/Perl/"/>
    
    
    <category term="perl" scheme="https://mkdbook.com/tags/perl/"/>
    
  </entry>
  
  <entry>
    <title>11--折腾Blog学到的一些东西</title>
    <link href="https://mkdbook.com/blog011.html"/>
    <id>https://mkdbook.com/blog011.html</id>
    <published>2023-03-20T12:32:51.000Z</published>
    <updated>2023-03-24T08:09:25.560Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、加深了对网络、网站搭建的理解"><a href="#一、加深了对网络、网站搭建的理解" class="headerlink" title="一、加深了对网络、网站搭建的理解"></a>一、加深了对网络、网站搭建的理解</h1><ol><li><p>互联网其实就是一个大型的局域网罢了，所有的网页、网上的资源都处于某一台（多台）实体电脑（服务器）中，然后接入这个大型的Internet，实现我们普通网民的冲浪。</p></li><li><p>关于域名，其实就是一种映射关系，将一些好记的字符映射到你这台服务器的IP地址，实现访问，因为IP地址人类不好记忆。</p></li><li><p>关于<code>https</code>和<code>http</code>：简而言之前者需要SSL&#x2F;TLS加密，而后者是明文更容易遭受中间人攻击。这也是我强迫症使用cloudflare中转的原因之一，如果访问一个网站是http时，浏览器网址栏会提示不安全；而使用https加密后，网址栏会显示一把小锁。</p></li></ol><h1 id="二、动态Blog和静态Blog"><a href="#二、动态Blog和静态Blog" class="headerlink" title="二、动态Blog和静态Blog"></a>二、动态Blog和静态Blog</h1><p>我试着折腾过两种，<code>动态：wordpress</code>。<code>静态：hexo</code>。我理解两者最直观的区别就是，动态的搭建在VPS上，可以访问后台实时修改和书写文章；静态是需要在本地搭建环境，生成好html文件，然后将这些页面上传到服务器。<br>比较而言，前者功能更加复杂，需要数据库等，可以用于网站的搭建，搭建博客只是其中一个功能。<br>而后者则相对纯粹，静态页面适合专注于文字的书写。</p><h1 id="三、Hexo-GitHub-自定义域名-Cloudflare做CDN中转"><a href="#三、Hexo-GitHub-自定义域名-Cloudflare做CDN中转" class="headerlink" title="三、Hexo+GitHub+自定义域名+Cloudflare做CDN中转"></a>三、Hexo+GitHub+自定义域名+Cloudflare做CDN中转</h1><p>这里不做详细教程，只记录大体步骤；</p><ol><li>Github创建个人仓库（“服务器端”）；</li><li>搭建本地环境（安装Git、Node.js、Hexo）；</li><li>生成本地页面（localhost:4000），则表明搭建成功；</li><li>将Hexo网站推送到Github中，实现互联网访问；</li><li>购买域名，并让其指向你的<code>http://xxxx.github.io/</code>地址，实现自定义域名访问；<ul><li>注：第五步有两种方法，一种是直接在域名购买商那里将DNS指向你的Github，一种是通过Cloudflare做中转解析；后者可以免费申请SSL证书，实现强制<code>https</code>代理，而非<code>http</code>。</li></ul></li><li>SEO配置，让搜索引擎收录你的网站，并允许爬虫你的内容。</li></ol><h1 id="四、踩坑记录"><a href="#四、踩坑记录" class="headerlink" title="四、踩坑记录"></a>四、踩坑记录</h1><ol><li>在添加百度SEO设置主动推送（API，要用到token那种方式），在根目录_config.yaml，修改deploy配置，添加<code>type: baidu_url_submitter</code>报错如下：<code>YAMLException: duplicated mapping key (126:3)</code>。</li></ol><blockquote><p>解决办法是：<code>type</code>变为 ”<code>- type</code>“，且要顶格，即“-”前面不能有空格，后面有空格，且冒号后有空格，如图11.1：</p></blockquote><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/11.1%E5%9D%91%E4%B8%80.png" width="70%" height="70%" alt="11.1 坑一"/></center><p>因为yml的特点是：</p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素<strong>左对齐</strong>即可</li><li>‘#’表示注释</li></ul><hr><br><ol start="2"><li>百度SEO通过文件验证网站后，<code>baidu_verify_codeva-u08yTssVjX.html</code>文件每次都会被Hexo编译，导致认证不成功。</li></ol><blockquote><p>解决办法是：将<code>baidu_verify_codeva-u08yTssVjX.html</code>文件放到<code>\themes\你的主题\source</code>中，而不是在blog根目录下的source文件夹中。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、加深了对网络、网站搭建的理解&quot;&gt;&lt;a href=&quot;#一、加深了对网络、网站搭建的理解&quot; class=&quot;headerlink&quot; title=&quot;一、加深了对网络、网站搭建的理解&quot;&gt;&lt;/a&gt;一、加深了对网络、网站搭建的理解&lt;/h1&gt;&lt;ol&gt;</summary>
      
    
    
    
    <category term="杂记" scheme="https://mkdbook.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>10--[TEST]Erase of NAND behavior model  验证计划-项目2-4</title>
    <link href="https://mkdbook.com/blog010.html"/>
    <id>https://mkdbook.com/blog010.html</id>
    <published>2023-03-20T11:59:40.000Z</published>
    <updated>2023-03-24T08:08:30.928Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><table><thead><tr><th>用例名称</th><th>用例描述</th><th>期望结果</th><th>验证结果</th><th>备注</th><th>验证人</th></tr></thead><tbody><tr><td>after_EraSus_PagePgm1</td><td>擦暂停后执行写操作（同一块）</td><td>数据不可以写入</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>after_EraSus_PagePgm2</td><td>擦暂停后执行写操作（同plane不同块）</td><td>数据可以写入</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>after_EraSus_PagePgm3</td><td>擦暂停后执行写操作（不同plane）</td><td>数据可以写入</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>after_EraSus_CachePgm1</td><td>擦暂停后执行写缓存操作（同一块）</td><td>数据不可以写入</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>after_EraSus_CachePgm2</td><td>擦暂停后执行写缓存操作（同plane不同块）</td><td>数据可以写入</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>after_EraSus_CachePgm3</td><td>擦暂停后执行写缓存操作（不同plane）</td><td>数据可以写入</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>multi_erase_D1</td><td>60–地址–61–delay–60–地址–D0</td><td>擦除成功</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>multi_erase_onfi</td><td>60–地址–60—地址—D0</td><td>擦除成功</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>multi_erase_D1_4P</td><td>D1模式下对4个plane进行擦除</td><td>擦除成功</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>multi_erase_onfi_4P</td><td>onfi模式下对4个plane进行擦除</td><td>擦除成功</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>multi_erase_D1_1P</td><td>D1模式下，发送同一plane的三个block的地址</td><td>只擦除最后一个地址（60–addr–D0）的block</td><td>OK</td><td>增加地址个数，结果一样</td><td>Mark</td></tr><tr><td>multi_erase_onfi_1P</td><td>onfi模式下，发送同一plane的三个block的地址</td><td>只擦除最后一个地址（60–addr–D0）的block</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>multi_erase_D1_4+1</td><td>D1模式下，输入5个block地址，其中四个为不同plande中的block，有两个block是属于同一个block的</td><td>重复的block擦除失败（只擦除同plane中最后出现的那一个block）</td><td>OK</td><td>增加重复地址个数，结果一样</td><td>Mark</td></tr><tr><td>multi_erase_onfi_4+1</td><td>onfi模式下，输入5个block地址，其中四个为不同plande中的block，有两个block是属于同一个block的</td><td>重复的block擦除失败（只擦除同plane中最后出现的那一个block）</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>normal_sus_erase</td><td>先对block 2，page 0，column 8’h0，写入15个数据。再对该位置发送Erase sequence，在wait_ready之前对同一位置发送Erase Suspend sequence，然后读取该位置的值。</td><td>如果Erase Suspend成功，该位置读出的值是不确定的，为x态。</td><td>Erase Suspend逻辑未触发</td><td>已解决。 1、”if (Io_mirror [7 : 0] &#x3D; &#x3D; &#x3D; 8’h60)”,改为else if； 2、 “if (lastCmd &#x3D;&#x3D;&#x3D; 8’h67 &amp;&amp; !cmnd_78h &amp;&amp; !cmnd_71h)”，改为”if (lastCmd &#x3D;&#x3D;&#x3D; 8’h67)”;</td><td>Mark</td></tr><tr><td>twice_sus_erase</td><td>在设备处于erase suspend状态下，再发一次erase suspend sequence。</td><td>第二次发送的suspend命令会被忽略，同时可以看到提示信息。</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>noerase_sus_erase</td><td>在设备未处于erase的状态下发送erase suspend sequence。</td><td>erase suspend命令会被忽略，同时可以看到提示信息。</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>program_sus_erase</td><td>设备处于erase suspend状态下，对同一个block进行program</td><td>program失败，该位置的数据读出来仍为 x。</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>multi_erase_sus</td><td>在进行multi_plane erase时，发送erase suspend命令</td><td>会同时暂停所有这些plane中的erase操作</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>A_era_sus_E_A</td><td>A处于erase suspend时，对A进行ERASE</td><td>Resume ERASE operation to block A</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>A_era_sus_E_B</td><td>A处于erase suspend时，对非suspend的B进行ERASE</td><td>开始B的normal erase，A的suspend状态被取消</td><td>OK</td><td>如何判断A是否处于SUSPEND状态：通过在对B ERASE的前后，各发一次ERASE Resume命令，A处于SUSPEND状态则 RESUME命令生效，否则SUSPEND状态被取消。</td><td>Mark</td></tr><tr><td>A_era_sus_mtE_AB</td><td>A处于erase suspend时，对A和非suspend的B进行multi_plane ERASE</td><td>开始A、B的normal multi_plane erase</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>mtE_ABsus_E_A</td><td>multi_plane erase A、B被suspend后，对A进行ERASE操作</td><td>Resume ERASE operation to block A and B</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>mtE_ABsus_E_B</td><td>multi_plane erase A、B被suspend后，对B进行ERASE操作</td><td></td><td>OK</td><td></td><td>Mark</td></tr><tr><td>mtE_ABsus_mtE_AB</td><td>multi_plane erase A、B被suspend后，对A、B进行mult_plane ERASE操作</td><td></td><td>OK</td><td></td><td>Mark</td></tr><tr><td>mtE_ABsus_mtE_AD</td><td>multi_plane erase A、B被suspend后，对A、D（未suspend）进行mult_plane ERASE操作</td><td>Start normal erase to block A and D. Suspend to block B is canceled</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>mtE_ABsus_mtE_CB</td><td>multi_plane erase A、B被suspend后，对C（未suspend）、B进行mult_plane ERASE操作</td><td>Start normal erase to block C and B. Suspend to block A is canceled</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>erase_resume</td><td>在normal_sus_erase的基础上，发送D7h，然后等待wait_ready后，再对该位置读取一次</td><td>该位置从X态变为FF，说明Erase Resume成功。</td><td>OK</td><td></td><td>Mark</td></tr><tr><td>nosus_erase_resume</td><td>在设备未处于erase suspend的状态下发送erase resume sequence。</td><td>erase resume命令会被忽略。</td><td>OK</td><td></td><td>Mark</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;用例名称&lt;/th&gt;
&lt;th&gt;用例描述&lt;/th&gt;
&lt;th&gt;期望结果&lt;/th&gt;
&lt;th&gt;验证结果&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;th&gt;验证人&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr</summary>
      
    
    
    
    <category term="项目" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="项目2-Erase_of_NAND_behavior_model" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE2-Erase-of-NAND-behavior-model/"/>
    
    
    <category term="NAND" scheme="https://mkdbook.com/tags/NAND/"/>
    
  </entry>
  
  <entry>
    <title>9--[Design]ERASE RESUME协议及代码实现-项目2-3</title>
    <link href="https://mkdbook.com/blog009.html"/>
    <id>https://mkdbook.com/blog009.html</id>
    <published>2023-03-19T12:59:07.000Z</published>
    <updated>2023-03-24T08:08:24.634Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、ERASE-Resume功能描述"><a href="#一、ERASE-Resume功能描述" class="headerlink" title="一、ERASE Resume功能描述"></a>一、ERASE Resume功能描述</h1><ul><li>重新开始指定LUN被Suspend的Erase操作。</li><li>如图3，发送Command D7h经tWB后，R&#x2F;B_n信号拉低，在tERES时间段内完成Erase Resume操作。</li><li>在发送D7h前，Host应选择被Erase Suspend的LUN。</li><li>如果Device未处于Erase Suspend状态，Erase Resume命令会被忽略。</li><li>如果Multi-Plane Erase 操作被Suspend，则发送 D7h 会同时恢复所有的Erase操作。</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/9.1Erase%20Resume%20Sequence.png" width="50%" height="50%" alt="9.1 Erase Resume Sequence"/></center><h1 id="二、ERASE-RESUME代码实现方案"><a href="#二、ERASE-RESUME代码实现方案" class="headerlink" title="二、ERASE RESUME代码实现方案"></a>二、<strong>ERASE RESUME代码实现方案</strong></h1><h2 id="2-1、Command-D7h"><a href="#2-1、Command-D7h" class="headerlink" title="2.1、Command D7h"></a>2.1、<strong>Command D7h</strong></h2><p>代码如下，当IO口的数值为8h’D7会触发此条件语句。</p><pre><code class="verilog">else if (Io_mirror [7 : 0] = = = 8&#39;hD7) begin      1、program cache 未完成时，报错ARRAY is still busy，直到状态变为E0h      2、判断是否处于OTP_mode，OTP mode 不允许 ERASE Resume      3、lastCmd = 8&#39;hD7      4、调用 clear_queued_planes、disable_rdStatus      5、当检测到处于suspend 状态时，则传递待 RESUME 的 block地址        else if (erase_susp_flag) begin              for (eb_thisPlane=0; eb_thisPlane &lt; NUM_PLANES; eb_thisPlane=eb_thisPlane+1) begin           if (erase_susp_blk_addr[eb_thisPlane] ! = = &#123;BLCK_BITS&#123;1&#39;bx&#125;&#125;) begin                queued_plane[eb_thisPlane] = 1;               row_addr[eb_thisPlane][BLCK_BITS+PAGE_BITS-1:PAGE_BITS] = erase_susp_blk_addr[eb_thisPlane];           end         end      6、erase_blk_en = ~ erase_blk_en;      7、调用 clear_erase_suspend，清除与 Erase Suspend 相关的寄存器      8、wait (erase_done);     endend</code></pre><h2 id="2-2、Erase-RESUME实现"><a href="#2-2、Erase-RESUME实现" class="headerlink" title="2.2、Erase RESUME实现"></a>2.2、<strong>Erase RESUME实现</strong></h2><p>如2.1所示，第14行第6点，当IO收到D7h命令后同时满足RESUME条件，则通过“erase_blk_en &#x3D; ~ erase_blk_en”产生擦除行为（如《7–[Design]ERASE BLOCK协议及代码实现-项目2-1》<a href="https://mkdbook.com/blog007.html#:~:text=3.4%E3%80%81Erase%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E7%9A%84always%E5%9D%97">3.4描述</a>）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、ERASE-Resume功能描述&quot;&gt;&lt;a href=&quot;#一、ERASE-Resume功能描述&quot; class=&quot;headerlink&quot; title=&quot;一、ERASE Resume功能描述&quot;&gt;&lt;/a&gt;一、ERASE Resume功能描述&lt;</summary>
      
    
    
    
    <category term="项目" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="项目2-Erase_of_NAND_behavior_model" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE2-Erase-of-NAND-behavior-model/"/>
    
    
    <category term="NAND" scheme="https://mkdbook.com/tags/NAND/"/>
    
  </entry>
  
  <entry>
    <title>8--[Design]ERASE SUSPEND协议及代码实现-项目2-2</title>
    <link href="https://mkdbook.com/blog008.html"/>
    <id>https://mkdbook.com/blog008.html</id>
    <published>2023-03-19T10:53:51.000Z</published>
    <updated>2023-03-24T08:08:18.238Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、ERASE-SUSPEND功能描述"><a href="#一、ERASE-SUSPEND功能描述" class="headerlink" title="一、ERASE SUSPEND功能描述"></a>一、ERASE SUSPEND<strong>功能描述</strong></h1><ul><li>打断指定LUN的Erase操作。</li><li>如图8.1，Command 67h后跟四个周期的Row地址，tESPD是Erase Suspend的操作时间。</li><li>当SR[6]由0变为1后，判断SR[3]，若SR[3]等于1，则Suspend成功；<br>若SR[3]等于0，则Suspend失败，Erase成功。</li><li>在Erase Suspend操作过程中，允许Reset Command、Page Read Command、Multi-Plane Command、Status Read Command、Mode Switching Command、Set Feature Command、Get Feature Command。</li><li>在Erase Suspend模式下，不能对同一个Block进行Program。</li><li>若在进行Multi-Plane Erase的过程中，发送Erase Suspend命令，会使所有Plane的Erase操作都暂停。</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/8.1Erase%20Suspend%20Sequence.png" width="75%" height="75%" alt="8.1 Erase Suspend Sequence"/></center><h1 id="二、ERASE-SUSPEND代码实现方案"><a href="#二、ERASE-SUSPEND代码实现方案" class="headerlink" title="二、ERASE SUSPEND代码实现方案"></a>二、<strong>ERASE SUSPEND代码实现方案</strong></h1><h2 id="2-1、Command-67h"><a href="#2-1、Command-67h" class="headerlink" title="2.1、Command 67h"></a>2.1、<strong>Command 67h</strong></h2><p>代码如下，当IO口的数值为8h’67会触发此条件语句。</p><pre><code class="verilog">else if (Io_mirror [7 : 0] = = = 8&#39;h67) begin     1、program cache 未完成时，67h会被忽略，直到状态变为E0h          LastCmd              = 8&#39;h67;                disable_rdStatus;         Row_valid           = 1&#39;b0;         saw_cmnd_00h_state = 1&#39;b0;         read_out                 = 1&#39;b0;         addr_start            = COL_BYTES +1;         addr_stop            = ADDR_BYTES;end</code></pre><h2 id="2-2、Erase-suspend-实现"><a href="#2-2、Erase-suspend-实现" class="headerlink" title="2.2、Erase suspend 实现"></a>2.2、<strong>Erase suspend 实现</strong></h2><p>主要实现方法是在Address input always块中将unlocked_erase_block擦除逻辑块disable。Address input always块中关于67h的逻辑如下：</p><pre><code class="verilog">    always @ (posedge row_valid) begin    ……      if (lastCmd = = = 8&#39;h67 ) begin : erase_suspend         1、program cache 未完成时，报错ARRAY is still busy，直到状态变为E0h         2、如果 erase_done = = 1 时，忽略 suspend 命令         3、如果 erase 操作正在进行中，67h命令有效            3.1、配置SR寄存器            3.2、开始suspend操作：disable unlocked_erase_block;             3.3、调用corrupt_block (erase_susp_blk_addr[eb_thisPlane]); 标记为坏块，数据为未定态      end    ……end</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、ERASE-SUSPEND功能描述&quot;&gt;&lt;a href=&quot;#一、ERASE-SUSPEND功能描述&quot; class=&quot;headerlink&quot; title=&quot;一、ERASE SUSPEND功能描述&quot;&gt;&lt;/a&gt;一、ERASE SUSPEND&lt;</summary>
      
    
    
    
    <category term="项目" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="项目2-Erase_of_NAND_behavior_model" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE2-Erase-of-NAND-behavior-model/"/>
    
    
    <category term="NAND" scheme="https://mkdbook.com/tags/NAND/"/>
    
  </entry>
  
  <entry>
    <title>7--[Design]ERASE BLOCK协议及代码实现-项目2-1</title>
    <link href="https://mkdbook.com/blog007.html"/>
    <id>https://mkdbook.com/blog007.html</id>
    <published>2023-03-19T10:31:20.000Z</published>
    <updated>2023-03-24T08:08:13.917Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、项目功能描述"><a href="#一、项目功能描述" class="headerlink" title="一、项目功能描述"></a>一、项目功能描述</h1><p>本项目基于长江存储NAND Datasheet，实现了NAND behavior model的<code>擦除功能（Erase Block）</code>，<code>擦除挂起功能（Erase Suspend）</code>，<code>擦除恢复功能（Erase Resume）</code>。</p><h1 id="二、Erase-Block功能描述"><a href="#二、Erase-Block功能描述" class="headerlink" title="二、Erase Block功能描述"></a>二、<strong>Erase Block功能描述</strong></h1><ul><li>以Block为单位对Array进行擦除。</li><li>如图7.1，Command 60h后跟四个周期的Row地址，再发送Command D0h，经tWB时间后，R&#x2F;B_n信号拉低，开始时长tBERS的擦除操作。</li><li>Host端通过监测R&#x2F;B_n信号或者Status Register，判断Erase操作是否完成，<br>SR[0]为0则表示Erase成功（SR[6]为1时，SR[0]才有效）。</li><li>在Erase过程中，只可接受Read Status Command、Reset Command、Suspend Command。</li></ul><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/7.1Block%20Erase%20Sequence.png" width="75%" height="75%" alt="7.1 Block Erase Sequence"/></center><h1 id="三、ERASE-BLOCK代码实现方案"><a href="#三、ERASE-BLOCK代码实现方案" class="headerlink" title="三、ERASE BLOCK代码实现方案"></a>三、<strong>ERASE BLOCK代码实现方案</strong></h1><h2 id="3-1、命令输入always块"><a href="#3-1、命令输入always块" class="headerlink" title="3.1、命令输入always块"></a>3.1、<strong>命令输入always块</strong></h2><p>如下所示，在We_n的上升沿会触发command input的always块。</p><pre><code class="verilog">always @ (posedge We_n) begin : cLatch          1、判断是否command_enable          2、判断power up后第一个命令是否为reset命令，会产生error信息          3、Command（60h）          4、Command（D0h）end</code></pre><p>command_enbale信号定义如下：</p><pre><code class="verilog">assign command_enable = (Cle &amp; ~Ale &amp; ~Ce_n_vol &amp; Re_n );</code></pre><h2 id="3-2、Command-60h"><a href="#3-2、Command-60h" class="headerlink" title="3.2、Command 60h"></a>3.2、Command 60h</h2><p>当IO口收到60h时，内部会进行如下操作：</p><pre><code class="verilog">if (Io_mirror [7 : 0] = = = 8&#39;h60) begin        1、program cache 未完成时，60h会被忽略，直到状态变为E0h        2、~Wp_n 和 OTP_mode 时均不允许 ERASE        3、60h有效时，判断是否处于Multi-Plane ERASE，           if lastCmd为60h，或D1h，则继续让lastCmd=60h        else if (~multiplane_op_erase) begin                              saw_cmnd_60h = 1&#39;b1;                              saw_cmnd_60h_clear = 1&#39;b1;                          end else begin                              saw_cmnd_60h = 1&#39;b1;                              saw_cmnd_60h_clear = 1&#39;b0;                          end        4、调用 disable_rdStatus，复位 status flag，让device返Read modeend</code></pre><h2 id="3-3、Command-D0h"><a href="#3-3、Command-D0h" class="headerlink" title="3.3、Command D0h"></a>3.3、<strong>Command D0h</strong></h2><p>当IO口收到D0h时，内部会进行如下操作：</p><pre><code class="verilog">else if (Io_mirror [7 : 0] = = = 8&#39;hD0) begin      1、program cache 未完成时，D0h会被忽略，直到状态变为E0h      2、判断是否 die_select，选择了才会往下执行      3、if ((lastCmd = = = 8&#39;h60) &amp;&amp; row_valid &amp;&amp; Wp_n) begin          3.1、lastCmd = 8&#39;hD0          3.2、判断当前LUN是否有被 Erase Suspend 的blcok，若地址相同，将会Resume 被Suspend 的block          3.3、调用clear_erase_suspend，清除和 Erase Suspend 相关的 reg          3.4、erase_blk_en = ~ erase_blk_en，产生沿降，调用后续always 块开始erase操作       end    end</code></pre><h2 id="3-4、Erase功能实现的always块"><a href="#3-4、Erase功能实现的always块" class="headerlink" title="3.4、Erase功能实现的always块"></a>3.4、<strong>Erase功能实现的always块</strong></h2><p>第一个always块的作用是通过erase_blk_en和erase_blk_en_r的异或逻辑，使得一旦产生erase_blk_en &#x3D; ~ erase_blk_en的变换时，确保erase_blk_pls都能产生上升沿逻辑，从而驱动Erase操作的always块。</p><pre><code class="verilog">always @(*)begin    erase_blk_pls &lt;= #tWB_delay ((erase_blk_en &amp; ~erase_blk_en_r) | (~erase_blk_en &amp; erase_blk_en_r));    erase_blk_en_r &lt;= #1 erase_blk_en;end</code></pre><p>当erase_blk_pls产生上升沿的跳变时，会触发如下具有擦除逻辑的always块，从而完成Erase操作。</p><pre><code class="verilog">always @(posedge erase_blk_pls) begin      1、进入busy状态，设置SR[5、6]为00；      2、调用 check_plane_addresses，检查排队的擦除块是否满足multi-plane寻址要求      3、擦除逻辑       if (eb_unlocked_erase) begin : unlocked_erase_block            3.1、截取擦除的 block 地址              erase_block_addr = row_addr [eb_thisPlane] [BLCK_BITS + PAGE_BITS – 1 : PAGE_BITS];                    3.2、采用循环将array进行写1擦除                      for (e=0; e&lt;memory_used; e=e+1) begin : mem_loop                          //check to see if existing used address location matches block being erased                          if (memory_addr[e] [BLCK_BITS + PAGE_BITS - 1 : PAGE_BITS] = = = erase_block_addr) begin                              mem_array[e] = &#123;PAGE_SIZE&#123;erase_data[0]&#125;&#125;;                              seq_page[erase_block_addr] = &#123;PAGE_BITS&#123;1&#39;b0&#125;&#125;;                                  mem_flag[e] = 0;  // 0: not programmed; 1: programmed.                                                  end                      end //mem_loop end         end  // unlocked_erase_blockend</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、项目功能描述&quot;&gt;&lt;a href=&quot;#一、项目功能描述&quot; class=&quot;headerlink&quot; title=&quot;一、项目功能描述&quot;&gt;&lt;/a&gt;一、项目功能描述&lt;/h1&gt;&lt;p&gt;本项目基于长江存储NAND Datasheet，实现了NAND b</summary>
      
    
    
    
    <category term="项目" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="项目2-Erase_of_NAND_behavior_model" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE2-Erase-of-NAND-behavior-model/"/>
    
    
    <category term="NAND" scheme="https://mkdbook.com/tags/NAND/"/>
    
  </entry>
  
  <entry>
    <title>6--NAND基本的读、写、擦除功能</title>
    <link href="https://mkdbook.com/blog006.html"/>
    <id>https://mkdbook.com/blog006.html</id>
    <published>2023-03-19T04:13:19.000Z</published>
    <updated>2023-03-24T08:09:03.390Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]<br>NAND Flash的读（READ）、写（PROGRAM）、擦除（ERASE）功能有很多种类型，例如就读而言，有READ page、READ ID等，这些功能和命令不同厂商可能不完全相同，具体要参照该NAND Flash厂商提供的Datasheet。本文总结一下NAND基本的几种读、写、擦除功能。</p><h1 id="一、NAND-Flash-读操作"><a href="#一、NAND-Flash-读操作" class="headerlink" title="一、NAND Flash 读操作"></a>一、NAND Flash 读操作</h1><p>这里介绍两种重要的读，一种是正常的<code>Page Read</code>：即读取由指定LUN的ROW地址表示的 一个page的数据；一种是<code>Cache Read</code>：当数据从Memory Array复制到Data Register的同时，允许前一拍数据从Cache Register读取出去，实现Pipeline方式工作。</p><h2 id="00h-30h：READ-PAGE-operation"><a href="#00h-30h：READ-PAGE-operation" class="headerlink" title="00h-30h：READ PAGE operation"></a>00h-30h：READ PAGE operation</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/6.1Read%20Page.png" width="40%" height="40%" alt="6.1 Read Page"/></center><p>如6.1所示，从Memory Array读出数据时，会经过Buffer。在每个Plane中会有两个Buffer：<code>Data Buffer</code>和<code>Cache Buffer</code>，它们的大小均为一个Page的大小。<br>当收到00h-30h命令串后，就会开始从指定位置读出Memory数据的功能。这种方式只能一次读取一个Page的数据，操作逻辑是数据从Memory Array到Cache Buffer，然后从Cache Buffer读出到IO口。</p><h2 id="Cache-read（31h和00h-31h）"><a href="#Cache-read（31h和00h-31h）" class="headerlink" title="Cache read（31h和00h-31h）"></a>Cache read（31h和00h-31h）</h2><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/6.2Cache%20Read.png" width="70%" height="70%" alt="6.2 Cache Read"/></center><p>Cache Read会同时用到Data Buffer和Cache Buffer。如6.2所示，当Page N的数据从Cache Buffer读出到IO口的同时，Page N+1的数据从Memory Array读出到了Data buffer。<br>Cache Read又分为两种，一种是了连续Cache Read（31h：Sequential Cache Read），一种是随机Cache Read（00h-31h：Cache Read Random）。它们的区别如下：</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/6.3Sequential%20Cache%20Read.png" width="75%" height="75%" alt="6.3 Sequential Cache Read"/></center><p><code>连续Cache Read</code>的操作逻辑如6.3序列图所示，00h-30h输入page M的地址后，后面输入一次31h命令，会读出page M中的数据，后面再输一次31h命令会读出page M+1的数据，以此类推。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/6.4Cache%20Read%20Random.png" width="75%" height="75%" alt="6.4 Cache Read Random"/></center><p><code>随机Cache Read</code>是指可以跳着读取不同Page的数据，如6.4序列图所示，第一次发00h-30h地址M后，第二次发00h-31h地址N之后，读出的是第一次Page M的数据，然后下一次输入Page P的地址之后，读取的是上一次Page N的数据，以此类推。</p><h1 id="二、NAND-Flash-写操作"><a href="#二、NAND-Flash-写操作" class="headerlink" title="二、NAND Flash 写操作"></a>二、NAND Flash 写操作</h1><p>写操作在NAND Flash中被称为Program，逻辑上是将1写成0。操作过程类似于读操作的反操作，数据从IO口进来然后经过两Buffer最后被写入到NAND Flash的Memory Array中。<br>写操作也有两种方式，<code>80h-10h：Program Page</code>；<code>80h-15h：Program Page Cache</code>。这里针对TLC不同厂商有不同的处理方式，例如长存使用One Pass Program，美光使用Two Pass Program。</p><h1 id="三、NAND-Flash-擦除操作"><a href="#三、NAND-Flash-擦除操作" class="headerlink" title="三、NAND Flash 擦除操作"></a>三、NAND Flash 擦除操作</h1><p>NAND Flash的Erase操作可以理解成一种特殊的写操作，它是将所有的数据都写成1（16进制读出来为FF）。命令为<code>60h-D0h</code>。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/6.5Erase%20Block.png" width="75%" height="75%" alt="6.5 Erase Block"/></center><p>如6.5序列图所示，擦除是以Block为单位的，所以只需要Row地址。扩展一下，ERASE相关的操作有如下几种：Erase Block、Multi_Plane Erase、Erase Suspend、 Erase Resume。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇记录了比较浅显的基本功能，个人认为学习一个功能应该先从功能的描述入手，然后对照这它的序列图理解其命令逻辑。虽然不同厂商的功能描述和实现会有区别，但是大体的功能应该都是类似的（前提都是基于<a href="http://www.onfi.org/">ONFI协议</a>）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;br&gt;NAND Flash的读（READ）、写（PROGRAM）、擦除（ERASE）功能有很多种类型，例如就读而言，有READ page、READ ID等，这些功能和命令不同厂商可能不完全相同，具体要参照该NAND Flash厂商提供的Datasheet。本文总</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="NAND" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/NAND/"/>
    
    
    <category term="NAND" scheme="https://mkdbook.com/tags/NAND/"/>
    
  </entry>
  
  <entry>
    <title>5--NAND基本概念简述</title>
    <link href="https://mkdbook.com/blog005.html"/>
    <id>https://mkdbook.com/blog005.html</id>
    <published>2023-03-18T06:49:14.000Z</published>
    <updated>2023-03-24T08:08:57.556Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>NAND Flash可以看作是一个单独的存储器也可以看作是一个存储单元，最早它可以直接和CPU连接，通过CPU发送指令实现对NAND Flash的控制，进行数据的存储和交换。由于计算机功能越来越复杂，通过CPU直接控制NAND Flash这种方式很影响性能，故而基于不同协议的controller作为host端来控制NAND Flash，可以产生不同的存储产品，如eMMC等。本篇主要对基本的NAND Flash做一个整体总结。</p><h1 id="二、接口描述"><a href="#二、接口描述" class="headerlink" title="二、接口描述"></a>二、接口描述</h1><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/5.1NAND%E5%8E%9F%E7%90%86%E5%9B%BE.png" width="50%" height="50%" alt="5.1 NAND原理图"/></center><p>如图5.1所示，黄色部分为NAND Flash原理图，可以看到此NAND flash有六个控制端口，分别是：</p><p><code>ALE</code>：Address Latch enable</p><p><code>CLE</code>：Command Latch enbale</p><p><code>CE_n</code>：Chip enable</p><p><code>RE_n</code>：Read enable，为低时为数据输出，表示允许host端从NAND Flash读取数据出来</p><p><code>WE_n</code>：Write_enable</p><p><code>R/B_n</code>：Ready&#x2F;Besy</p><p>通过控制这六个端口信号的高低状态，可实现对NAND Flash的操作，这里介绍几种基本操作状态的信号描述，详细的需要参考不同厂商的Datashee。</p><ol><li>命令输入模式：CE_n拉低，ALE拉低，CLE拉高，WE_n拉低，RE_n拉高</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/5.2NAND%E5%91%BD%E4%BB%A4%E8%BE%93%E5%85%A5%E6%97%B6%E5%BA%8F.png" width="50%" height="50%" alt="5.2 NAND命令输入时序"/></center><ol start="2"><li>地址输入模式：CE_n拉低，ALE拉高，CLE拉低，WE_n拉低，RE_n拉高</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/5.3NAND%E5%9C%B0%E5%9D%80%E8%BE%93%E5%85%A5%E6%97%B6%E5%BA%8F.png" width="50%" height="50%" alt="5.3 NAND地址输入时序"/></center><ol start="3"><li>数据输入模式：CE_n拉低，ALE拉低，CLE拉低，WE_n拉低，RE_n拉高</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/5.4NAND%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E6%97%B6%E5%BA%8F.png" width="50%" height="50%" alt="5.4 NAND数据输入时序"/></center><ol start="4"><li>数据输出模式：CE_n拉低，ALE拉低，CLE拉低，WE_n拉高，RE_n拉低</li></ol><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/5.5NAND%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E6%97%B6%E5%BA%8F.png" width="50%" height="50%" alt="5.5 NAND数据输出时序"/></center><h1 id="三、Flash-结构"><a href="#三、Flash-结构" class="headerlink" title="三、Flash 结构"></a>三、Flash 结构</h1><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/5.6NAND%20LUN%E7%BB%93%E6%9E%84%E5%9B%BE.png" width="30%" height="30%" alt="5.6 LUN结构图"/></center><p>图5.6所示，是NAND Flash的一个Die（LUN）的结构图，Logical Unit Number是指NAND Flash能够独立执行命令和报告状态的最小单元，即一个NAND Flash memory可以由多个LUN组成，也可以是单个LUN。</p><p>在单个LUN结构中各个结构从大到小排序依次为：<strong>LUN ——&gt; Plane ——&gt; block ——&gt; page ——&gt; byte</strong>。</p><h1 id="四、地址的寻址"><a href="#四、地址的寻址" class="headerlink" title="四、地址的寻址"></a>四、地址的寻址</h1><p>有两种类型的地址Row Address和Column Address，Row address用于寻址LUN、block、page ，Column address用于寻址page中的byte。不同产品的Flash地址周期可能不一样，一般Datasheet中会有地址表格说明每个周期的地址的意义。如图5.7所示，CA表示Column address，Low表示低电平，PA表示Page address，BA表示Block address，LA表示LUN address。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/5.7Flash%E5%9C%B0%E5%9D%80%E5%AE%9A%E4%B9%89.png" width="75%" height="75%" alt="5.7 Flash地址定义"/></center><h1 id="五、读、写、擦除操作"><a href="#五、读、写、擦除操作" class="headerlink" title="五、读、写、擦除操作"></a>五、读、写、擦除操作</h1><p>Read、Program、Erase是一款存储设备最基本的功能。对于NAND flash，读、写是以page为单位进行的，而擦除是以block为单位进行的；写操作是将1变为0，擦除操作时将0变为1，所以为写的memory array中读出来的数据为FF。</p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>如图5.8所示，NAND flash的IO口是双向的，在地址输入、命令输入、写操作是数据的流向都是从host端到NAND的，只有RE_n信号拉低处于数据输出模式才能从NAND flash中读出数据。</p><center><img src="https://blog-img-1317260263.cos.ap-shanghai.myqcloud.com/blog-pic/5.8NAND%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2.png" width="50%" height="50%" alt="5.8 NAND数据交换"/></center>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;NAND Flash可以看作是一个单独的存储器也可以看作是一个存储单元，最早它可以直接和CPU连接</summary>
      
    
    
    
    <category term="领域" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/"/>
    
    <category term="NAND" scheme="https://mkdbook.com/categories/%E9%A2%86%E5%9F%9F/NAND/"/>
    
    
    <category term="NAND" scheme="https://mkdbook.com/tags/NAND/"/>
    
  </entry>
  
  <entry>
    <title>4--Markdown简要速查笔记</title>
    <link href="https://mkdbook.com/blog004.html"/>
    <id>https://mkdbook.com/blog004.html</id>
    <published>2023-03-17T15:43:18.000Z</published>
    <updated>2023-04-28T02:14:27.277Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h1><ul><li><code>#(空格)一级标题</code></li><li><code>#(空格)二级标题</code></li></ul><h1 id="2、段落换行"><a href="#2、段落换行" class="headerlink" title="2、段落换行"></a>2、段落换行</h1><ul><li>末尾两个以上空格</li><li>句末加<code>&lt;br&gt;</code></li></ul><h1 id="3、强调语法"><a href="#3、强调语法" class="headerlink" title="3、强调语法"></a>3、强调语法</h1><ol><li><p>粗体：<code>**内容**</code></p></li><li><p>斜体：<code>*内容*</code></p></li><li><p>斜体+粗体：<code>***内容***</code></p></li></ol><h1 id="4、分割线"><a href="#4、分割线" class="headerlink" title="4、分割线"></a>4、分割线</h1><p>一行中三个“<code>-</code>”</p><h1 id="5、删除线"><a href="#5、删除线" class="headerlink" title="5、删除线"></a>5、删除线</h1><p><code>~~内容~~</code></p><h1 id="6、下划线"><a href="#6、下划线" class="headerlink" title="6、下划线"></a>6、下划线</h1><p><code>&lt;u&gt;带下划线文本&lt;/u&gt;</code></p><h1 id="7、列表和引用"><a href="#7、列表和引用" class="headerlink" title="7、列表和引用"></a>7、列表和引用</h1><p>第一种引用：<code>&gt;内容</code></p><p>数字：<code>1.（空格）内容</code></p><p>强调：<code>-（空格）内容</code></p><p>嵌套：</p><pre><code class="markdown">1.（空格）第一    （四个空格，或一个tab）- 小一</code></pre><h1 id="8、代码"><a href="#8、代码" class="headerlink" title="8、代码"></a>8、代码</h1><pre><code class="markdown">    ```代码类型    代码内容    ```</code></pre><p>句子中直接`内容`，内容会变成<code>内容</code></p><h1 id="9、链接"><a href="#9、链接" class="headerlink" title="9、链接"></a>9、链接</h1><p><code>[超链接名](http://XXX  &quot;说明&quot;)</code></p><p>鼠标悬停在链接名上，会显示说明内容</p><h1 id="10、图片插入"><a href="#10、图片插入" class="headerlink" title="10、图片插入"></a>10、图片插入</h1><ol><li>常规插入图片</li></ol><p><code>![alt 属性文本](XXX.img “可选标题”)</code></p><p>alt属性文本：当某种原因看不见图片时会显示该内容</p><p>可选标题：鼠标悬停图片显示该内容</p><ol start="2"><li>点击图片会跳转链接</li></ol><p> <code>[![alt 属性文本](XXX.img “可选标题”)](http://XXX)</code></p><ol start="3"><li>居左</li></ol><pre><code class="markdown">![在这里插入图片描述](https://img-blog.csdnimg.cn/20200822014538211.png#pic_left)</code></pre><ol start="4"><li>居中：<code>#pic_center</code></li></ol><p><strong>5. 等比缩放</strong></p><p><code>&lt;img src=https://xxx.img width=60% /&gt;</code></p><ol start="6"><li>固定宽高</li></ol><p><code>&lt;img src=https://xxx.img width=200 height=100 /&gt;</code></p><p><strong>7. 利用html终极格式</strong></p><pre><code class="html">&lt;center&gt;&lt;img src=&quot;链接&quot; width=&quot;75%&quot; height=&quot;75%&quot; alt=&quot;属性说明&quot;/&gt;&lt;/center&gt;</code></pre><h1 id="11、表格"><a href="#11、表格" class="headerlink" title="11、表格"></a>11、表格</h1><p>可直接通过网址生成markdown语句</p><p><a href="https://www.tablesgenerator.com/markdown_tables">Markdown Tables generator - TablesGenerator.com</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1、标题&quot;&gt;&lt;a href=&quot;#1、标题&quot; class=&quot;headerlink&quot; title=&quot;1、标题&quot;&gt;&lt;/a&gt;1、标题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#(空格)一级标题&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#(空格)</summary>
      
    
    
    
    <category term="语言" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Markdown" scheme="https://mkdbook.com/categories/%E8%AF%AD%E8%A8%80/Markdown/"/>
    
    
    <category term="速查笔记" scheme="https://mkdbook.com/tags/%E9%80%9F%E6%9F%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Markdown" scheme="https://mkdbook.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>3--perl生成html table报告-项目3.3</title>
    <link href="https://mkdbook.com/blog003.html"/>
    <id>https://mkdbook.com/blog003.html</id>
    <published>2023-03-17T15:22:13.000Z</published>
    <updated>2023-03-24T08:08:47.470Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、主要功能"><a href="#一、主要功能" class="headerlink" title="一、主要功能"></a>一、主要功能</h1><ul><li>生成html table</li><li>CSS美化表格</li></ul><h1 id="二、html头文件代码"><a href="#二、html头文件代码" class="headerlink" title="二、html头文件代码"></a>二、html头文件代码</h1><p>在perl中定义<code>$html</code>变量，当生成好html代码后，通过文件句柄导出<code>$html</code>中所有内容到<code>verification.html</code>文件，就可以<code>firefox verification.html &amp;</code>看到最终结果的表格文件。</p><pre><code class="perl">my $html = &quot;&lt;html lang=&#39;en&#39;&gt;    &lt;head&gt;        &lt;meta charset=&#39;utf8&#39; /&gt;        &lt;link rel=&#39;stylesheet&#39; href=&#39;css/styles.css&#39;&gt;        &lt;title&gt;            verification table        &lt;/title&gt;    &lt;/head&gt;    &lt;style&gt;    $CSS       ##### CSS 美化代码    &lt;/style&gt;    &lt;body&gt;  &lt;table border=1&gt;      &lt;tr&gt;       &lt;th&gt;Test Case &lt;/th&gt;       &lt;th&gt;Description &lt;/th&gt;       &lt;th&gt;Dir &lt;/th&gt;       &lt;th&gt;Result &lt;/th&gt;       &lt;th&gt;Time &lt;/th&gt;      &lt;/tr&gt;      $table       ### 表格一行内容的 html table代码  &lt;/table&gt;      &lt;/body&gt;&lt;/html&gt;&quot;;##########---------------export html and clear some logopen(FILE,&quot;&gt;verification.html&quot;);say FILE &quot;$html&quot;;close (FILE);</code></pre><h1 id="三、-table中的html-table代码"><a href="#三、-table中的html-table代码" class="headerlink" title="三、$table中的html table代码"></a>三、$table中的html table代码</h1><p>将for循环产生的相关单元格变量填入html table中相应位置，每一次for循环都会产生一行数据</p><pre><code class="perl">$table .= &quot;&lt;tr&gt;\n\t\t              &lt;td&gt;&lt;a href= \&quot;../tb/$case_name.v\&quot;&gt;test_$i&lt;/a&gt;&lt;/td&gt;\n\t\t              &lt;td&gt;$description&lt;/td&gt;\n\t\t              &lt;td&gt;&lt;a href= \&quot;**$dir_log\**&quot;&gt;log_file_test_$i&lt;/a&gt;&lt;/td&gt;\n\t\t              &lt;td bgcolor= $color &gt; $result&lt;/td&gt;\n\t\t              &lt;td&gt;$time&lt;/td&gt;\n           &lt;/tr&gt;\n&quot;</code></pre><h1 id="四、html-table-CSS美化代码"><a href="#四、html-table-CSS美化代码" class="headerlink" title="四、html table CSS美化代码"></a>四、html table CSS美化代码</h1><pre><code class="perl">#########-------------------------CSS for table style$CSS=&#39;table &#123;    width: 90%;    background: #ccc;    margin: 10px auto;    border-collapse: collapse;    border: 2px inset black;&#125;th,td &#123;    height: 25px;    line-height: 25px;    text-align: center;    border: 1px solid #ccc;&#125;th &#123;    background: #eee;    font-weight: bold;    font-size:15px;&#125;tr &#123;    background: #fff;&#125;tr:hover &#123;    background: #cc0;&#125;td a &#123;    color: #06f;    text-decoration: none;&#125;td a:hover &#123;    color: #06f;    text-decoration: underline;&#125;&#39;;</code></pre><p>注意，这里使用的单引号对<code>$CSS</code>变量赋值，防止其中内容在双引号中当作perl的关键字被识别导致语法错误。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>到这，此次简单的perl回归测试报告脚本就完成了。这算是学完perl后，第一次写的一个原创的perl脚本，中间的逻辑可能不是最优解，但好歹能完成基本功能。通过这个脚本的书写，我第一次体会到了perl的强大和复杂，也深知自己之前仅仅学习了皮毛而已。同时我也了解了html、CSS相关的一些网页知识，这和我搭建blog的想法正不谋而合，高级的用法虽然不会，但底层逻辑大概了解了，算是打开了又一个世界的大门了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、主要功能&quot;&gt;&lt;a href=&quot;#一、主要功能&quot; class=&quot;headerlink&quot; title=&quot;一、主要功能&quot;&gt;&lt;/a&gt;一、主要功能&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;生成html table&lt;/li&gt;
&lt;li&gt;CSS美化表格&lt;/li&gt;
</summary>
      
    
    
    
    <category term="项目" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="项目3-Perl回归测试脚本" scheme="https://mkdbook.com/categories/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE3-Perl%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="perl" scheme="https://mkdbook.com/tags/perl/"/>
    
  </entry>
  
</feed>
